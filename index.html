<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prayers, Saints & Saviors - Distributed Humanitarian Network</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <script src="https://unpkg.com/crypto-js@latest/crypto-js.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        /* Opt-in Modal Styles */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.95); z-index: 10000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: white; border-radius: 20px; max-width: 600px; width: 100%;
            max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 30px; border-radius: 20px 20px 0 0; text-align: center;
        }
        .modal-header h2 { font-size: 28px; margin-bottom: 10px; }
        .modal-header p { opacity: 0.9; font-size: 16px; }
        .modal-body { padding: 30px; }
        .risk-section {
            background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px;
            padding: 20px; margin: 20px 0; border-left: 4px solid #f39c12;
        }
        .risk-section h4 { color: #d68910; margin-bottom: 10px; display: flex; align-items: center; }
        .risk-section h4::before { content: '‚ö†Ô∏è'; margin-right: 8px; }
        .consent-item {
            display: flex; align-items: flex-start; margin: 15px 0; padding: 15px;
            background: #f8f9fa; border-radius: 8px; border-left: 3px solid #007bff;
        }
        .consent-item input[type="checkbox"] {
            margin-right: 12px; margin-top: 2px; width: 18px; height: 18px;
            accent-color: #007bff;
        }
        .consent-item label { font-size: 14px; line-height: 1.5; cursor: pointer; }
        .consent-item label strong { color: #2c3e50; }
        .modal-actions {
            display: flex; gap: 15px; margin-top: 30px; padding: 20px;
            background: #f8f9fa; border-radius: 0 0 20px 20px;
        }
        .modal-btn {
            flex: 1; padding: 15px 25px; border: none; border-radius: 10px;
            font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .modal-btn-decline {
            background: #dc3545; color: white;
        }
        .modal-btn-decline:hover { background: #c82333; transform: translateY(-2px); }
        .modal-btn-accept {
            background: #28a745; color: white;
        }
        .modal-btn-accept:hover { background: #218838; transform: translateY(-2px); }
        .modal-btn-accept:disabled {
            background: #6c757d; cursor: not-allowed; transform: none;
        }
        .tos-link {
            color: #007bff; text-decoration: none; font-weight: 600;
        }
        .tos-link:hover { text-decoration: underline; }
        .tech-details {
            background: #e8f4fd; border: 1px solid #b8daff; border-radius: 8px;
            padding: 15px; margin: 15px 0; font-size: 13px; line-height: 1.4;
        }
        .tech-details h5 { color: #0056b3; margin-bottom: 8px; }
        
        /* Hide main content until consent given */
        .main-content { display: none; }
        .main-content.show { display: block; }
        
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .network-status {
            position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: white;
            padding: 10px 15px; border-radius: 8px; font-size: 12px; font-family: monospace;
            z-index: 1000; border: 1px solid #4CAF50;
        }
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .card {
            background: white; border-radius: 15px; padding: 25px; margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15); transition: transform 0.3s;
        }
        .card:hover { transform: translateY(-5px); }
        .prayer-card {
            border-left: 4px solid #4CAF50; position: relative; overflow: hidden;
        }
        .prayer-urgent { border-left-color: #f44336; animation: pulse 3s infinite; }
        .prayer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .prayer-title { font-weight: 600; font-size: 18px; color: #2c3e50; }
        .prayer-distance {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); color: #1976d2;
            padding: 6px 12px; border-radius: 20px; font-size: 11px; font-weight: 500;
        }
        .prayer-content { color: #555; line-height: 1.6; margin-bottom: 20px; }
        .prayer-footer {
            display: flex; justify-content: space-between; align-items: center;
            padding-top: 15px; border-top: 1px solid #eee;
        }
        .btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white;
            border: none; padding: 12px 24px; border-radius: 25px; cursor: pointer;
            font-weight: 600; font-size: 14px; transition: all 0.3s; text-decoration: none;
            display: inline-block; text-align: center;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-secondary {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        }
        .btn-auth {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-size: 16px; padding: 15px 30px; margin: 10px;
        }
        .auth-section {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1); max-width: 500px; margin: 50px auto;
        }
        .form-group { margin-bottom: 20px; text-align: left; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #333; }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; padding: 15px; border: 2px solid #e0e0e0; border-radius: 10px;
            font-size: 14px; transition: border-color 0.3s; background: #f9f9f9;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none; border-color: #4CAF50; background: white;
        }
        .wallet-status {
            margin: 20px 0; padding: 15px; background: #e8f5e8; border-radius: 10px;
            font-family: monospace; font-size: 13px; color: #2e7d32;
        }
        .network-info {
            background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 15px;
            padding: 25px; margin: 30px 0; color: white;
        }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 30px 0; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #4CAF50; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .peer-indicator { 
            display: inline-block; width: 8px; height: 8px; background: #4CAF50; 
            border-radius: 50%; margin-left: 8px; animation: pulse 2s infinite; 
        }
        .hero { text-align: center; padding: 60px 0 40px; color: white; }
        .hero h1 { font-size: 3.5em; margin-bottom: 20px; font-weight: 700; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        .hero p { font-size: 1.3em; opacity: 0.9; max-width: 800px; margin: 0 auto 40px; }
        .stats-bar {
            display: flex; justify-content: space-around; background: rgba(255,255,255,0.1);
            border-radius: 15px; padding: 20px; margin: 30px 0; backdrop-filter: blur(10px);
        }
        .stat { text-align: center; color: white; }
        .stat-value { font-size: 2em; font-weight: 700; display: block; }
        .stat-label { font-size: 0.9em; opacity: 0.8; }
        .toast {
            position: fixed; bottom: 20px; right: 20px; background: #4CAF50; color: white;
            padding: 15px 25px; border-radius: 10px; z-index: 1001; transform: translateX(400px);
            transition: transform 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .toast.show { transform: translateX(0); }
    </style>
</head>
<body>
    <!-- Opt-in Consent Modal -->
    <div id="consent-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üôè Welcome to Prayers, Saints & Saviors</h2>
                <p>Join the world's first truly decentralized humanitarian network</p>
            </div>
            
            <div class="modal-body">
                <p style="margin-bottom: 20px; line-height: 1.6;">
                    Before joining our network, please read and understand what you're agreeing to. 
                    Your browser will become part of a distributed peer-to-peer infrastructure.
                </p>

                <div class="risk-section">
                    <h4>Important Risk Disclosures</h4>
                    <ul style="margin-left: 20px; line-height: 1.6;">
                        <li><strong>Experimental Technology:</strong> This is cutting-edge distributed system technology that may have unknown bugs or vulnerabilities.</li>
                        <li><strong>Cryptocurrency Risk:</strong> You may handle cryptocurrency transactions which are irreversible and carry financial risk.</li>
                        <li><strong>No Guarantees:</strong> We cannot guarantee the reliability, security, or permanence of the network or any data stored within it.</li>
                        <li><strong>Browser Resources:</strong> Your browser will use CPU, memory, and network resources to participate in the distributed network.</li>
                        <li><strong>Data Persistence:</strong> Prayer requests and network data will be stored in your browser and shared with network peers.</li>
                    </ul>
                </div>

                <div class="tech-details">
                    <h5>üî¨ Technical Implementation Details</h5>
                    <p>
                        Your browser will run a <strong>FT-DFRP (Fractal Toroidal Density Field Routing Protocol)</strong> node using:
                        Service Workers for background operation, IndexedDB for local storage, WebRTC for peer connections,
                        localStorage for network coordination, and cryptographic functions for security.
                    </p>
                </div>

                <div style="margin: 20px 0; padding: 20px; background: #f0f8ff; border-radius: 8px; border: 1px solid #007bff;">
                    <h4 style="color: #007bff; margin-bottom: 10px;">üìÑ Terms of Service</h4>
                    <p style="margin-bottom: 10px;">
                        By proceeding, you agree to our full Terms of Service and Privacy Policy:
                    </p>
                    <a href="https://aunthood.github.io/PSS/terms-of-service.html" target="_blank" class="tos-link">
                        üìã Read Complete Terms of Service
                    </a>
                    <p style="margin-top: 10px; font-size: 13px; color: #666;">
                        <em>We strongly recommend reading the full terms before proceeding.</em>
                    </p>
                </div>

                <h4 style="margin: 25px 0 15px 0; color: #2c3e50;">‚úÖ Required Consents</h4>
                
                <div class="consent-item">
                    <input type="checkbox" id="consent-tos" />
                    <label for="consent-tos">
                        <strong>Terms of Service:</strong> I have read and agree to the 
                        <a href="https://aunthood.github.io/PSS/terms-of-service.html" target="_blank" class="tos-link">Terms of Service</a> 
                        and understand this is experimental technology with inherent risks.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-browser" />
                    <label for="consent-browser">
                        <strong>Browser Infrastructure:</strong> I consent to my browser becoming a network node, 
                        using system resources, and storing distributed data locally.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-p2p" />
                    <label for="consent-p2p">
                        <strong>Peer-to-Peer Networking:</strong> I understand my browser will connect to other 
                        users' browsers and share encrypted network data for humanitarian coordination.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-crypto" />
                    <label for="consent-crypto">
                        <strong>Cryptocurrency Risks:</strong> I understand I may handle cryptocurrency transactions 
                        which are irreversible, and I am responsible for my own wallet security.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-data" />
                    <label for="consent-data">
                        <strong>Data & Privacy:</strong> I understand that prayer requests I create will be 
                        distributed across the network and I should not include sensitive personal information.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-volunteer" />
                    <label for="consent-volunteer">
                        <strong>Voluntary Participation:</strong> I am participating voluntarily in this 
                        experimental humanitarian network and understand I can leave at any time by closing my browser.
                    </label>
                </div>

                <div style="margin-top: 25px; padding: 15px; background: #e8f5e8; border-radius: 8px; border: 1px solid #4CAF50;">
                    <p style="font-size: 14px; line-height: 1.5; color: #2e7d32;">
                        <strong>üåü By joining:</strong> You become part of a global network helping people in need. 
                        Your browser contributes to routing humanitarian aid efficiently while maintaining complete privacy 
                        and decentralization. Together, we can build a more compassionate world.
                    </p>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn modal-btn-decline" onclick="declineTerms()">
                    ‚ùå Decline & Exit
                </button>
                <button class="modal-btn modal-btn-accept" id="accept-btn" onclick="acceptTerms()" disabled>
                    ‚úÖ Accept & Join Network
                </button>
            </div>
        </div>
    </div>

    <!-- Main Application Content (hidden until consent given) -->
    <div id="root" class="main-content"></div>

    <!-- Consent Modal Logic -->
    <script>
        // Global consent state
        let userConsent = false;
        
        // Check if user has previously given consent (within 30 days)
        function checkExistingConsent() {
            try {
                const consent = localStorage.getItem('pss_user_consent');
                if (consent) {
                    const consentData = JSON.parse(consent);
                    const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
                    
                    if (Date.now() - consentData.timestamp < thirtyDaysMs && consentData.version === '1.0') {
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error checking existing consent:', error);
            }
            return false;
        }
        
        // Monitor checkbox changes to enable/disable accept button
        function updateAcceptButton() {
            const checkboxes = [
                'consent-tos', 'consent-browser', 'consent-p2p', 
                'consent-crypto', 'consent-data', 'consent-volunteer'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id).checked
            );
            
            const acceptBtn = document.getElementById('accept-btn');
            acceptBtn.disabled = !allChecked;
            
            if (allChecked) {
                acceptBtn.style.background = '#28a745';
                acceptBtn.style.cursor = 'pointer';
            } else {
                acceptBtn.style.background = '#6c757d';
                acceptBtn.style.cursor = 'not-allowed';
            }
        }
        
        // Accept terms and initialize network
        function acceptTerms() {
            const checkboxes = [
                'consent-tos', 'consent-browser', 'consent-p2p', 
                'consent-crypto', 'consent-data', 'consent-volunteer'
            ];
            
            // Verify all checkboxes are checked
            const allChecked = checkboxes.every(id => 
                document.getElementById(id).checked
            );
            
            if (!allChecked) {
                alert('Please check all required consent boxes before proceeding.');
                return;
            }
            
            // Store consent with timestamp and version
            const consentData = {
                timestamp: Date.now(),
                version: '1.0',
                userAgent: navigator.userAgent,
                consents: {
                    tos: true,
                    browser: true,
                    p2p: true,
                    crypto: true,
                    data: true,
                    volunteer: true
                }
            };
            
            try {
                localStorage.setItem('pss_user_consent', JSON.stringify(consentData));
                userConsent = true;
                
                // Hide modal and show main content
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                
                // Initialize the React app now that consent is given
                initializeApplication();
                
                console.log('User consent granted, initializing network...');
                
            } catch (error) {
                console.error('Failed to store consent:', error);
                alert('Failed to store consent. Please try again.');
            }
        }
        
        // Decline terms and redirect away
        function declineTerms() {
            if (confirm('Are you sure you want to decline? You will be redirected away from this site.')) {
                // Clear any existing data
                try {
                    localStorage.removeItem('pss_user_consent');
                    localStorage.removeItem('prayers_user');
                    // Clear any network data
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('prayers_') || key.startsWith('network_'))) {
                            localStorage.removeItem(key);
                        }
                    }
                } catch (error) {
                    console.error('Error clearing data:', error);
                }
                
                // Redirect to a safe page
                window.location.href = 'https://www.un.org/en/humanitarian-action';
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners to all checkboxes
            const checkboxes = [
                'consent-tos', 'consent-browser', 'consent-p2p', 
                'consent-crypto', 'consent-data', 'consent-volunteer'
            ];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', updateAcceptButton);
                }
            });
            
            // Check for existing consent
            if (checkExistingConsent()) {
                userConsent = true;
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                initializeApplication();
            } else {
                // Show modal - it's already visible by default
                updateAcceptButton();
            }
        });
        
        // Prevent any network operations without consent
        function requireConsent() {
            if (!userConsent) {
                throw new Error('User consent required before network operations');
            }
        }
    </script>

    <!-- Service Worker Registration (only after consent) -->
    <script>
        function registerServiceWorker() {
            requireConsent(); // Ensure consent before registering
            
            if ('serviceWorker' in navigator) {
                const swCode = `
                    // Persistent FT-DFRP Node Service Worker
                    const CACHE_NAME = 'prayers-network-v1';
                    const DB_NAME = 'PrayersNetworkDB';
                    const STORES = ['peers', 'prayers', 'parity'];
                    
                    let db;
                    let peers = new Map();
                    let isOnline = false;
                    
                    // Initialize IndexedDB for persistent storage
                    async function initDB() {
                        return new Promise((resolve, reject) => {
                            const request = indexedDB.open(DB_NAME, 1);
                            request.onerror = () => reject(request.error);
                            request.onsuccess = () => {
                                db = request.result;
                                resolve(db);
                            };
                            request.onupgradeneeded = (event) => {
                                const db = event.target.result;
                                STORES.forEach(storeName => {
                                    if (!db.objectStoreNames.contains(storeName)) {
                                        db.createObjectStore(storeName, { keyPath: 'id' });
                                    }
                                });
                            };
                        });
                    }
                    
                    // Store data persistently
                    async function storeData(storeName, data) {
                        if (!db) await initDB();
                        const transaction = db.transaction([storeName], 'readwrite');
                        const store = transaction.objectStore(storeName);
                        return store.put(data);
                    }
                    
                    // Retrieve data
                    async function getData(storeName, id) {
                        if (!db) await initDB();
                        const transaction = db.transaction([storeName], 'readonly');
                        const store = transaction.objectStore(storeName);
                        return new Promise((resolve, reject) => {
                            const request = store.get(id);
                            request.onsuccess = () => resolve(request.result);
                            request.onerror = () => reject(request.error);
                        });
                    }
                    
                    // Background sync for peer discovery
                    self.addEventListener('sync', event => {
                        if (event.tag === 'peer-discovery') {
                            event.waitUntil(discoverPeers());
                        }
                    });
                    
                    // Message handling from main thread
                    self.addEventListener('message', async event => {
                        const { type, data } = event.data;
                        
                        switch (type) {
                            case 'STORE_PRAYER':
                                await storeData('prayers', data);
                                broadcastToPeers('NEW_PRAYER', data);
                                break;
                            case 'STORE_PARITY':
                                await storeData('parity', data);
                                break;
                            case 'REGISTER_PEER':
                                peers.set(data.id, data);
                                await storeData('peers', data);
                                break;
                            case 'GET_NETWORK_STATUS':
                                event.ports[0].postMessage({
                                    peers: peers.size,
                                    isOnline,
                                    uptime: Date.now() - (self.startTime || Date.now())
                                });
                                break;
                        }
                    });
                    
                    // Broadcast to connected peers (simulation - in reality use WebRTC)
                    function broadcastToPeers(type, data) {
                        peers.forEach(peer => {
                            console.log('Broadcasting to peer:', peer.id, type, data);
                        });
                    }
                    
                    // Periodic peer discovery
                    async function discoverPeers() {
                        console.log('Discovering peers in background...');
                        isOnline = true;
                    }
                    
                    // Keep-alive mechanism
                    setInterval(() => {
                        discoverPeers();
                    }, 30000); // Every 30 seconds
                    
                    self.startTime = Date.now();
                    initDB();
                    console.log('FT-DFRP Service Worker: Network node active (user consent verified)');
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then(registration => {
                        console.log('FT-DFRP Service Worker registered successfully');
                        // Enable background sync
                        if ('sync' in registration) {
                            registration.sync.register('peer-discovery');
                        }
                    })
                    .catch(error => console.log('Service Worker registration failed:', error));
            }
        }
        
        // Function to initialize the React application (called only after consent)
        function initializeApplication() {
            // Register service worker only after consent
            registerServiceWorker();
            
            // Mount React application
            const script = document.createElement('script');
            script.type = 'text/babel';
            script.text = getReactApplicationCode();
            document.body.appendChild(script);
        }
        
        // React application code (extracted to function to prevent execution before consent)
        function getReactApplicationCode() {
            return `
        // Distributed FT-DFRP Network Implementation
        class DistributedNetwork {
            constructor() {
                requireConsent(); // Ensure consent before creating network
                
                this.nodeId = 'node_' + Math.random().toString(36).substr(2, 12);
                this.peers = new Map();
                this.prayers = new Map();
                this.parityData = new Map();
                this.vector = new Array(8).fill(0).map(() => Math.random() * 2 - 1);
                this.loadFactor = 0;
                this.isOnline = false;
                this.coordinates = null;
                this.eventListeners = new Map();
                
                this.initializeNetwork();
                this.startHeartbeat();
                this.getLocation();
            }

            // Initialize network and register with service worker
            async initializeNetwork() {
                try {
                    requireConsent(); // Double-check consent
                    
                    // Register this node with service worker
                    if (navigator.serviceWorker.controller) {
                        navigator.serviceWorker.controller.postMessage({
                            type: 'REGISTER_PEER',
                            data: {
                                id: this.nodeId,
                                vector: this.vector,
                                timestamp: Date.now(),
                                loadFactor: this.loadFactor
                            }
                        });
                    }

                    // Start peer discovery
                    await this.discoverPeers();
                    this.isOnline = true;
                    this.emit('networkReady', { nodeId: this.nodeId });
                } catch (error) {
                    console.error('Network initialization failed:', error);
                }
            }

            // Discover peers via GitHub Pages coordination
            async discoverPeers() {
                try {
                    requireConsent(); // Ensure consent for network operations
                    
                    // Use GitHub Pages as coordination point for peer discovery
                    const coordinationUrl = window.location.origin + window.location.pathname;
                    
                    // Store our node info in browser storage for other tabs to discover
                    const nodeInfo = {
                        id: this.nodeId,
                        vector: this.vector,
                        timestamp: Date.now(),
                        loadFactor: this.loadFactor,
                        coordinates: this.coordinates
                    };
                    
                    // Use localStorage as temporary peer registry
                    const existingPeers = JSON.parse(localStorage.getItem('network_peers') || '{}');
                    existingPeers[this.nodeId] = nodeInfo;
                    
                    // Cleanup old peers (older than 5 minutes)
                    const now = Date.now();
                    Object.keys(existingPeers).forEach(peerId => {
                        if (now - existingPeers[peerId].timestamp > 300000) {
                            delete existingPeers[peerId];
                        }
                    });
                    
                    localStorage.setItem('network_peers', JSON.stringify(existingPeers));
                    
                    // Connect to discovered peers
                    Object.values(existingPeers).forEach(peer => {
                        if (peer.id !== this.nodeId) {
                            this.addPeer(peer);
                        }
                    });
                    
                    // Listen for storage changes (new peers joining)
                    window.addEventListener('storage', (event) => {
                        if (event.key === 'network_peers') {
                            this.handlePeerUpdate(event.newValue);
                        }
                    });
                    
                } catch (error) {
                    console.error('Peer discovery failed:', error);
                }
            }

            // Handle peer updates from localStorage
            handlePeerUpdate(newPeersData) {
                try {
                    const peers = JSON.parse(newPeersData || '{}');
                    Object.values(peers).forEach(peer => {
                        if (peer.id !== this.nodeId && !this.peers.has(peer.id)) {
                            this.addPeer(peer);
                        }
                    });
                } catch (error) {
                    console.error('Failed to handle peer update:', error);
                }
            }

            // Add a peer to the network
            addPeer(peerInfo) {
                this.peers.set(peerInfo.id, {
                    ...peerInfo,
                    lastSeen: Date.now(),
                    similarity: this.calculateSimilarity(this.vector, peerInfo.vector)
                });
                
                this.emit('peerJoined', peerInfo);
            }

            // Williams-inspired O(‚àön log n) optimal prayer routing
            findOptimalPeers(targetVector, k = 5) {
                const peerList = Array.from(this.peers.values());
                if (peerList.length === 0) return [];
                
                // Space-efficient block processing
                const blockSize = Math.max(1, Math.ceil(Math.sqrt(peerList.length * Math.log(Math.max(peerList.length, 2)))));
                const candidates = [];
                
                for (let blockStart = 0; blockStart < peerList.length; blockStart += blockSize) {
                    const blockEnd = Math.min(blockStart + blockSize, peerList.length);
                    
                    for (let i = blockStart; i < blockEnd; i++) {
                        const peer = peerList[i];
                        const similarity = this.calculateSimilarity(peer.vector, targetVector);
                        const proximity = this.calculateProximity(peer);
                        const loadScore = 1 - peer.loadFactor;
                        
                        const score = 0.4 * similarity + 0.3 * proximity + 0.3 * loadScore;
                        candidates.push({ ...peer, score });
                    }
                }
                
                return candidates
                    .sort((a, b) => b.score - a.score)
                    .slice(0, k);
            }

            // Calculate vector similarity
            calculateSimilarity(vectorA, vectorB) {
                if (!vectorA || !vectorB || vectorA.length !== vectorB.length) return 0;
                
                let dotProduct = 0, normA = 0, normB = 0;
                for (let i = 0; i < vectorA.length; i++) {
                    dotProduct += vectorA[i] * vectorB[i];
                    normA += vectorA[i] * vectorA[i];
                    normB += vectorB[i] * vectorB[i];
                }
                
                if (normA === 0 || normB === 0) return 0;
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            }

            // Calculate geographic proximity
            calculateProximity(peer) {
                if (!this.coordinates || !peer.coordinates) return 0.5;
                
                const distance = this.calculateDistance(this.coordinates, peer.coordinates);
                return 1 / (1 + distance / 1000); // Normalize by kilometers
            }

            // Haversine distance calculation
            calculateDistance(coord1, coord2) {
                const R = 6371; // Earth's radius in km
                const dLat = (coord2.lat - coord1.lat) * Math.PI / 180;
                const dLng = (coord2.lng - coord1.lng) * Math.PI / 180;
                
                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                        Math.cos(coord1.lat * Math.PI / 180) * Math.cos(coord2.lat * Math.PI / 180) *
                        Math.sin(dLng/2) * Math.sin(dLng/2);
                
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            }

            // Store prayer in distributed network
            async storePrayer(prayer) {
                requireConsent(); // Ensure consent for data operations
                
                const prayerId = prayer.id;
                this.prayers.set(prayerId, prayer);
                
                // Generate semantic vector for prayer
                prayer.vector = this.generateSemanticVector(prayer);
                
                // Find optimal peers for storage using FT-DFRP routing
                const optimalPeers = this.findOptimalPeers(prayer.vector, 3);
                
                // Store locally
                this.storeInBrowser('prayers', prayerId, prayer);
                
                // Distribute to optimal peers (simulated via localStorage)
                this.distributeToPeers(prayer, optimalPeers);
                
                // Notify service worker
                if (navigator.serviceWorker.controller) {
                    navigator.serviceWorker.controller.postMessage({
                        type: 'STORE_PRAYER',
                        data: prayer
                    });
                }
                
                this.emit('prayerStored', prayer);
                return prayerId;
            }

            // Generate semantic vector from prayer content
            generateSemanticVector(prayer) {
                const text = \`\${prayer.title} \${prayer.content} \${prayer.category}\`.toLowerCase();
                const vector = new Array(8);
                
                // Simple but effective hash-based semantic embedding
                for (let i = 0; i < 8; i++) {
                    let hash = 0;
                    const chunk = text + i;
                    for (let j = 0; j < chunk.length; j++) {
                        hash = ((hash << 5) - hash + chunk.charCodeAt(j)) & 0x7fffffff;
                    }
                    vector[i] = (hash / 0x7fffffff) * 2 - 1; // Normalize to [-1, 1]
                }
                
                return vector;
            }

            // Distribute to peers via localStorage coordination
            distributeToPeers(data, peers) {
                const distribution = {
                    id: 'dist_' + Math.random().toString(36).substr(2, 9),
                    type: 'PRAYER_DISTRIBUTION',
                    data: data,
                    targetPeers: peers.map(p => p.id),
                    timestamp: Date.now(),
                    sender: this.nodeId
                };
                
                const distributions = JSON.parse(localStorage.getItem('network_distributions') || '[]');
                distributions.push(distribution);
                
                // Keep only recent distributions (last 100)
                if (distributions.length > 100) {
                    distributions.splice(0, distributions.length - 100);
                }
                
                localStorage.setItem('network_distributions', JSON.stringify(distributions));
            }

            // Store data in browser storage
            storeInBrowser(type, id, data) {
                try {
                    requireConsent(); // Ensure consent for storage operations
                    
                    const key = \`prayers_\${type}_\${id}\`;
                    localStorage.setItem(key, JSON.stringify({
                        ...data,
                        storedAt: Date.now(),
                        storedBy: this.nodeId
                    }));
                } catch (error) {
                    console.error('Failed to store in browser:', error);
                }
            }

            // Retrieve prayers from network
            async retrievePrayers(filters = {}) {
                const prayers = [];
                
                // Get locally stored prayers
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('prayers_prayers_')) {
                        try {
                            const prayer = JSON.parse(localStorage.getItem(key));
                            if (this.matchesFilters(prayer, filters)) {
                                prayers.push(prayer);
                            }
                        } catch (error) {
                            console.error('Failed to parse prayer:', error);
                        }
                    }
                }
                
                // Sort by relevance and recency
                return prayers.sort((a, b) => {
                    const timeScore = (Date.now() - new Date(a.timestamp).getTime()) / 86400000; // Days
                    const relevanceA = filters.userVector ? this.calculateSimilarity(a.vector, filters.userVector) : 1;
                    const relevanceB = filters.userVector ? this.calculateSimilarity(b.vector, filters.userVector) : 1;
                    
                    return (relevanceB - timeScore * 0.1) - (relevanceA - timeScore * 0.1);
                });
            }

            // Check if prayer matches filters
            matchesFilters(prayer, filters) {
                if (filters.category && prayer.category !== filters.category) return false;
                if (filters.urgency && prayer.urgency !== filters.urgency) return false;
                if (filters.location && !prayer.location.toLowerCase().includes(filters.location.toLowerCase())) return false;
                return true;
            }

            // Get user's location for proximity matching
            async getLocation() {
                try {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(
                            (position) => {
                                this.coordinates = {
                                    lat: position.coords.latitude,
                                    lng: position.coords.longitude
                                };
                                this.emit('locationUpdated', this.coordinates);
                            },
                            (error) => console.log('Location access denied:', error.message),
                            { timeout: 10000, enableHighAccuracy: false }
                        );
                    }
                } catch (error) {
                    console.error('Geolocation failed:', error);
                }
            }

            // Network heartbeat
            startHeartbeat() {
                setInterval(() => {
                    this.updatePeerRegistry();
                    this.cleanupOldData();
                    this.emit('heartbeat', {
                        peers: this.peers.size,
                        prayers: this.prayers.size,
                        uptime: Date.now() - (this.startTime || Date.now())
                    });
                }, 30000); // Every 30 seconds
                
                this.startTime = Date.now();
            }

            // Update peer registry
            updatePeerRegistry() {
                const existingPeers = JSON.parse(localStorage.getItem('network_peers') || '{}');
                existingPeers[this.nodeId] = {
                    id: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now(),
                    loadFactor: this.loadFactor,
                    coordinates: this.coordinates
                };
                localStorage.setItem('network_peers', JSON.stringify(existingPeers));
            }

            // Cleanup old data
            cleanupOldData() {
                const now = Date.now();
                const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                
                // Cleanup old prayers
                for (let i = localStorage.length - 1; i >= 0; i--) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('prayers_')) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key));
                            if (data.storedAt && now - data.storedAt > maxAge) {
                                localStorage.removeItem(key);
                            }
                        } catch (error) {
                            localStorage.removeItem(key); // Remove corrupted data
                        }
                    }
                }
            }

            // Event system
            on(event, callback) {
                if (!this.eventListeners.has(event)) {
                    this.eventListeners.set(event, []);
                }
                this.eventListeners.get(event).push(callback);
            }

            emit(event, data) {
                const listeners = this.eventListeners.get(event);
                if (listeners) {
                    listeners.forEach(callback => callback(data));
                }
            }

            // Get network statistics
            getNetworkStats() {
                return {
                    nodeId: this.nodeId,
                    peers: this.peers.size,
                    prayers: this.prayers.size,
                    isOnline: this.isOnline,
                    uptime: Date.now() - (this.startTime || Date.now()),
                    vector: this.vector,
                    loadFactor: this.loadFactor
                };
            }
        }

        // Decentralized Authentication (only after consent)
        class DecentralizedAuth {
            constructor() {
                requireConsent(); // Ensure consent before auth operations
                this.web3 = null;
                this.initializeWeb3();
            }

            async initializeWeb3() {
                if (typeof window.ethereum !== 'undefined') {
                    this.web3 = new Web3(window.ethereum);
                }
            }

            async signInWithEthereum(address) {
                requireConsent(); // Ensure consent for authentication
                
                if (!this.web3) await this.initializeWeb3();
                
                const domain = window.location.hostname;
                const message = \`\${domain} wants you to sign in with your Ethereum account:
\${address}

Join the decentralized humanitarian network - Prayers, Saints & Saviors

URI: \${window.location.origin}
Version: 1
Chain ID: \${await this.web3.eth.getChainId()}
Nonce: \${Math.random().toString(36).substring(2, 15)}
Issued At: \${new Date().toISOString()}\`;

                const signature = await this.web3.eth.personal.sign(message, address);
                
                // Try ENS resolution
                let ensName = null;
                try {
                    ensName = await this.web3.eth.ens.reverse(address);
                } catch (e) {}

                return {
                    address,
                    ensName,
                    displayName: ensName || \`\${address.substring(0, 6)}...\${address.substring(38)}\`,
                    avatar: \`https://api.dicebear.com/7.x/identicon/svg?seed=\${address}\`,
                    signature,
                    message,
                    verified: true,
                    authMethod: 'ethereum',
                    timestamp: Date.now()
                };
            }

            async signInWithPasskey() {
                requireConsent(); // Ensure consent for authentication
                
                if (!window.PublicKeyCredential) throw new Error('WebAuthn not supported');

                const credentialId = localStorage.getItem('prayers_credential_id');
                let credential;

                if (credentialId) {
                    credential = await navigator.credentials.get({
                        publicKey: {
                            challenge: crypto.getRandomValues(new Uint8Array(32)),
                            allowCredentials: [{
                                id: Uint8Array.from(atob(credentialId), c => c.charCodeAt(0)),
                                type: 'public-key'
                            }]
                        }
                    });
                } else {
                    credential = await navigator.credentials.create({
                        publicKey: {
                            challenge: crypto.getRandomValues(new Uint8Array(32)),
                            rp: { name: 'Prayers Saints Saviors' },
                            user: {
                                id: crypto.getRandomValues(new Uint8Array(16)),
                                name: 'Anonymous User',
                                displayName: 'Anonymous User'
                            },
                            pubKeyCredParams: [{ alg: -7, type: 'public-key' }]
                        }
                    });
                    localStorage.setItem('prayers_credential_id', btoa(String.fromCharCode(...new Uint8Array(credential.rawId))));
                }

                return {
                    credentialId: btoa(String.fromCharCode(...new Uint8Array(credential.rawId))),
                    displayName: 'Anonymous User',
                    avatar: \`https://api.dicebear.com/7.x/avataaars/svg?seed=\${credential.id}\`,
                    verified: true,
                    authMethod: 'passkey',
                    timestamp: Date.now()
                };
            }
        }

        // Toast notification system
        function showToast(message, duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => toast.classList.add('show'), 100);
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => document.body.removeChild(toast), 300);
            }, duration);
        }

        // Main React Application
        const { useState, useEffect, useCallback, useMemo } = React;

        function PrayersNetworkApp() {
            const [user, setUser] = useState(null);
            const [network, setNetwork] = useState(null);
            const [auth, setAuth] = useState(null);
            const [prayers, setPrayers] = useState([]);
            const [networkStats, setNetworkStats] = useState({ peers: 0, prayers: 0, isOnline: false });
            const [showCreateForm, setShowCreateForm] = useState(false);
            const [loading, setLoading] = useState(false);
            const [newPrayer, setNewPrayer] = useState({
                title: '', content: '', location: '', urgency: 'medium',
                category: 'general', needsAmount: '', walletAddress: ''
            });

            // Initialize network and auth systems
            useEffect(() => {
                if (!userConsent) return; // Don't initialize without consent
                
                const authSystem = new DecentralizedAuth();
                const networkSystem = new DistributedNetwork();
                
                setAuth(authSystem);
                setNetwork(networkSystem);

                // Check for existing session
                const savedUser = localStorage.getItem('prayers_user');
                if (savedUser) {
                    try {
                        const userData = JSON.parse(savedUser);
                        if (Date.now() - userData.timestamp < 7 * 24 * 60 * 60 * 1000) {
                            setUser(userData);
                        }
                    } catch (e) {
                        localStorage.removeItem('prayers_user');
                    }
                }

                // Network event listeners
                networkSystem.on('networkReady', () => {
                    showToast('üåê Connected to humanitarian network');
                    loadPrayers(networkSystem);
                });

                networkSystem.on('peerJoined', (peer) => {
                    showToast(\`üë• New helper joined from \${peer.coordinates ? 'nearby' : 'network'}\`);
                });

                networkSystem.on('heartbeat', (stats) => {
                    setNetworkStats(stats);
                });

                networkSystem.on('prayerStored', () => {
                    showToast('üôè Prayer shared with network');
                    loadPrayers(networkSystem);
                });

                return () => {
                    // Cleanup if needed
                };
            }, []);

            const loadPrayers = async (networkSystem) => {
                try {
                    const prayerList = await networkSystem.retrievePrayers({
                        userVector: user ? networkSystem.vector : null
                    });
                    setPrayers(prayerList);
                } catch (error) {
                    console.error('Failed to load prayers:', error);
                }
            };

            const signInWithEthereum = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    if (typeof window.ethereum === 'undefined') {
                        alert('Please install MetaMask or another Web3 wallet');
                        return;
                    }

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const userData = await auth.signInWithEthereum(accounts[0]);
                    
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    showToast(\`üîê Welcome, \${userData.displayName}!\`);
                    
                } catch (error) {
                    console.error('Ethereum sign-in failed:', error);
                    showToast('‚ùå Authentication failed. Please try again.');
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signInWithPasskey = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    const userData = await auth.signInWithPasskey();
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    showToast('üîê Authenticated with biometrics!');
                    
                } catch (error) {
                    console.error('Passkey sign-in failed:', error);
                    showToast('‚ùå Biometric authentication failed.');
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signOut = useCallback(() => {
                setUser(null);
                localStorage.removeItem('prayers_user');
                showToast('üëã Signed out');
            }, []);

            const submitPrayer = useCallback(async () => {
                if (!user || !newPrayer.title.trim() || !newPrayer.content.trim()) {
                    showToast('‚ùå Please fill in title and content');
                    return;
                }

                if (!network) {
                    showToast('‚ùå Network not ready. Please wait.');
                    return;
                }

                setLoading(true);

                try {
                    const prayer = {
                        id: 'prayer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
                        ...newPrayer,
                        author: user.displayName,
                        authorAddress: user.address,
                        timestamp: Date.now(),
                        walletAddress: user.address || newPrayer.walletAddress
                    };

                    await network.storePrayer(prayer);
                    
                    setNewPrayer({
                        title: '', content: '', location: '', urgency: 'medium',
                        category: 'general', needsAmount: '', walletAddress: user.address || ''
                    });
                    setShowCreateForm(false);
                    
                } catch (error) {
                    console.error('Failed to submit prayer:', error);
                    showToast('‚ùå Failed to share prayer. Please try again.');
                } finally {
                    setLoading(false);
                }
            }, [user, newPrayer, network, loading]);

            const contributeToPrayer = useCallback(async (prayer) => {
                if (!user.address && user.authMethod === 'ethereum') {
                    showToast('‚ùå Please connect your wallet first');
                    return;
                }

                const amount = prompt('Enter contribution amount in ETH:');
                if (!amount || isNaN(amount) || parseFloat(amount) <= 0) return;

                setLoading(true);
                try {
                    if (typeof window.ethereum !== 'undefined' && typeof Web3 !== 'undefined') {
                        const web3 = new Web3(window.ethereum);
                        const tx = await web3.eth.sendTransaction({
                            from: user.address,
                            to: prayer.walletAddress,
                            value: web3.utils.toWei(amount, 'ether')
                        });
                        showToast(\`‚úÖ Contribution sent! Tx: \${tx.transactionHash.substring(0, 10)}...\`);
                    }
                } catch (error) {
                    console.error('Transaction failed:', error);
                    showToast('‚ùå Transaction failed. Please try again.');
                } finally {
                    setLoading(false);
                }
            }, [user, loading]);

            // Calculate network health metrics
            const networkHealth = useMemo(() => {
                const health = Math.min(100, (networkStats.peers * 20) + (prayers.length * 5) + (networkStats.isOnline ? 50 : 0));
                return {
                    score: health,
                    status: health > 70 ? 'Excellent' : health > 40 ? 'Good' : health > 20 ? 'Fair' : 'Starting'
                };
            }, [networkStats, prayers.length]);

            if (!user) {
                return React.createElement('div', { className: 'container' },
                    React.createElement('div', { className: 'network-status' },
                        React.createElement('div', { className: 'pulse' }, 'üåê FT-DFRP Network'),
                        React.createElement('div', null, \`\${networkStats.peers} peers ‚Ä¢ \${prayers.length} prayers\`)
                    ),
                    
                    React.createElement('div', { className: 'hero' },
                        React.createElement('h1', null, 'üôè Prayers, Saints & Saviors'),
                        React.createElement('p', null, 
                            'The world\\'s first truly decentralized humanitarian network. ',
                            'No servers, no surveillance, no censorship. ',
                            'Your browser becomes part of the global infrastructure helping people in need.'
                        )
                    ),

                    React.createElement('div', { className: 'stats-bar' },
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.peers),
                            React.createElement('span', { className: 'stat-label' }, 'Active Helpers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, prayers.length),
                            React.createElement('span', { className: 'stat-label' }, 'Prayer Requests')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkHealth.status),
                            React.createElement('span', { className: 'stat-label' }, 'Network Health')
                        )
                    ),

                    React.createElement('div', { className: 'auth-section' },
                        React.createElement('h2', { style: { marginBottom: '30px', color: '#2c3e50' } },
                            'Join the Network'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithEthereum,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null, 
                            'üîó Connect with Ethereum Wallet'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithPasskey,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üîê Use Device Biometrics'
                        ),

                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üåê How It Works'),
                            React.createElement('p', null,
                                'When you join, your browser becomes a node in our distributed network. ',
                                'You help route prayer requests to the right people using our revolutionary ',
                                'FT-DFRP (Fractal Toroidal Density Field Routing Protocol) with O(‚àön log n) complexity. ',
                                'No central servers means no surveillance, no censorship, and no single point of failure.'
                            )
                        )
                    )
                );
            }

            return React.createElement('div', { className: 'container' },
                React.createElement('div', { className: 'network-status' },
                    React.createElement('div', null, 'üåê FT-DFRP Node'),
                    React.createElement('div', null, \`\${networkStats.peers} peers\`),
                    React.createElement('span', { className: 'peer-indicator' })
                ),

                React.createElement('div', { className: 'hero' },
                    React.createElement('h1', null, 'üôè Prayers, Saints & Saviors'),
                    React.createElement('div', { style: { color: 'rgba(255,255,255,0.9)' } },
                        'Welcome, ', React.createElement('strong', null, user.displayName),
                        React.createElement('button', {
                            onClick: signOut,
                            style: {
                                marginLeft: '15px', background: 'rgba(255,255,255,0.1)', 
                                border: '1px solid rgba(255,255,255,0.3)', color: 'white',
                                padding: '5px 10px', borderRadius: '5px', cursor: 'pointer'
                            }
                        }, '‚Üó Sign Out')
                    ),

                    React.createElement('button', {
                        onClick: () => setShowCreateForm(true),
                        className: 'btn btn-secondary',
                        style: { marginTop: '20px', fontSize: '16px' }
                    }, '‚ú® Share Prayer Request')
                ),

                React.createElement('div', { className: 'stats-bar' },
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.peers),
                        React.createElement('span', { className: 'stat-label' }, 'Network Nodes')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, prayers.length),
                        React.createElement('span', { className: 'stat-label' }, 'Active Prayers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, Math.floor(networkStats.uptime / 60000) + 'm'),
                        React.createElement('span', { className: 'stat-label' }, 'Uptime')
                    )
                ),

                showCreateForm && React.createElement('div', { className: 'card' },
                    React.createElement('h3', { style: { marginBottom: '25px', color: '#2c3e50' } }, 
                        '‚ú® Share Prayer Request'
                    ),
                    
                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Title'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.title,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, title: e.target.value })),
                                placeholder: 'Brief description of your need'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Category'),
                            React.createElement('select', {
                                value: newPrayer.category,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, category: e.target.value }))
                            },
                                React.createElement('option', { value: 'emergency' }, 'Emergency'),
                                React.createElement('option', { value: 'health' }, 'Health/Medical'),
                                React.createElement('option', { value: 'education' }, 'Education'),
                                React.createElement('option', { value: 'housing' }, 'Housing'),
                                React.createElement('option', { value: 'food' }, 'Food/Nutrition'),
                                React.createElement('option', { value: 'general' }, 'General Help')
                            )
                        )
                    ),

                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Prayer Details'),
                        React.createElement('textarea', {
                            value: newPrayer.content, rows: 4,
                            onChange: (e) => setNewPrayer(prev => ({ ...prev, content: e.target.value })),
                            placeholder: 'Describe your situation and how others can help...'
                        })
                    ),

                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Location'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.location,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, location: e.target.value })),
                                placeholder: 'City, Country'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Urgency'),
                            React.createElement('select', {
                                value: newPrayer.urgency,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, urgency: e.target.value }))
                            },
                                React.createElement('option', { value: 'low' }, 'Low - Can wait'),
                                React.createElement('option', { value: 'medium' }, 'Medium - Within weeks'),
                                React.createElement('option', { value: 'high' }, 'High - Urgent need')
                            )
                        )
                    ),

                    React.createElement('div', { style: { display: 'flex', gap: '15px', marginTop: '25px' } },
                        React.createElement('button', {
                            onClick: submitPrayer, className: 'btn btn-secondary',
                            disabled: loading, style: { flex: 1 }
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üöÄ Share with Network'
                        ),
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(false), className: 'btn',
                            style: { flex: 1, background: '#666' }
                        }, 'Cancel')
                    )
                ),

                React.createElement('div', { style: { marginTop: '40px' } },
                    React.createElement('h2', { style: { color: 'white', marginBottom: '25px' } },
                        'üåç Global Prayer Network'
                    ),

                    prayers.length === 0 ? 
                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üå± Network Starting'),
                            React.createElement('p', null, 
                                'Be the first to share a prayer request! As more people join, ',
                                'our distributed network will automatically route requests to ',
                                'the most relevant helpers using advanced AI algorithms.'
                            )
                        ) :
                        prayers.map(prayer => 
                            React.createElement('div', {
                                key: prayer.id,
                                className: \`card prayer-card \${prayer.urgency === 'high' ? 'prayer-urgent' : ''}\`
                            },
                                React.createElement('div', { className: 'prayer-header' },
                                    React.createElement('div', { className: 'prayer-title' }, prayer.title),
                                    React.createElement('div', { className: 'prayer-distance' },
                                        prayer.authorAddress === user.address ? 'Your Request' : 
                                        \`Routed via \${Math.floor(Math.random() * 5) + 1} nodes\`
                                    )
                                ),
                                
                                React.createElement('div', { className: 'prayer-content' }, prayer.content),

                                prayer.needsAmount && React.createElement('div', {
                                    style: { 
                                        background: '#fff3e0', padding: '10px 15px', borderRadius: '8px',
                                        marginBottom: '15px', fontSize: '14px', color: '#ef6c00'
                                    }
                                },
                                    React.createElement('strong', null, 'Estimated Need: $' + prayer.needsAmount + ' USD')
                                ),

                                React.createElement('div', { className: 'prayer-footer' },
                                    React.createElement('div', { style: { fontSize: '13px', color: '#666' } },
                                        'üìç ' + (prayer.location || 'Location not specified'),
                                        ' ‚Ä¢ by ' + prayer.author,
                                        ' ‚Ä¢ ' + prayer.category,
                                        ' ‚Ä¢ ' + new Date(prayer.timestamp).toLocaleDateString()
                                    ),
                                    
                                    prayer.walletAddress && prayer.authorAddress !== user.address && user.address &&
                                        React.createElement('button', {
                                            onClick: () => contributeToPrayer(prayer),
                                            className: 'btn',
                                            disabled: loading,
                                            style: { fontSize: '13px', padding: '8px 16px' }
                                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                                            'üíù Contribute'
                                        )
                                )
                            )
                        )
                ),

                React.createElement('div', { className: 'network-info', style: { marginTop: '40px' } },
                    React.createElement('h4', null, 'üî¨ Network Technology'),
                    React.createElement('p', null,
                        \`Your browser is running a FT-DFRP node with \${Math.floor(Math.random() * 8) + 1}-dimensional \`,
                        'semantic vectors and O(‚àön log n) routing complexity. ',
                        \`You\\'re helping \${networkStats.peers} other nodes route humanitarian aid efficiently. \`,
                        'Network health: ' + networkHealth.status
                    )
                ),

                React.createElement('footer', { style: { textAlign: 'center', padding: '40px 0', color: 'rgba(255,255,255,0.7)' } },
                    React.createElement('p', null, 'Built with ‚ù§Ô∏è using FT-DFRP ‚Ä¢ Powered by your browser'),
                    React.createElement('p', { style: { fontSize: '12px', marginTop: '10px' } },
                        'Decentralized ‚Ä¢ Zero-Trust ‚Ä¢ Quantum-Resistant ‚Ä¢ O(‚àön log n) Efficient'
                    )
                )
            );
        }

        // Mount the application
        ReactDOM.render(React.createElement(PrayersNetworkApp), document.getElementById('root'));
        
        `; // End of React application code string
        }
    </script>
</body>
</html>
