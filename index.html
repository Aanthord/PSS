<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prayers, Saints & Saviors - Global P2P Humanitarian Network</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <script src="https://unpkg.com/crypto-js@latest/crypto-js.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- Performance & Security Optimizations -->
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob: wss:; connect-src 'self' https: wss: *.peerjs.com;">
    
    <script>
        // Suppress Babel development warnings
        if (window.Babel) {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && typeof args[0] === 'string' && 
                    args[0].includes('in-browser Babel transformer')) {
                    return;
                }
                originalWarn.apply(console, args);
            };
        }
    </script>
    
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #4CAF50;
            --warning: #ff9800;
            --danger: #f44336;
            --info: #2196F3;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --border-radius: 15px;
            --shadow: 0 8px 25px rgba(0,0,0,0.15);
            --shadow-hover: 0 15px 35px rgba(0,0,0,0.2);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }

        /* Enhanced Animations */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulseNetwork {
            0%, 100% { background-color: var(--success); }
            50% { background-color: var(--info); }
        }

        @keyframes slideInFromRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Modal Enhancements */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.95); z-index: 10000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
            backdrop-filter: blur(10px) saturate(120%);
            animation: fadeInUp 0.4s ease-out;
        }

        .modal-content {
            background: white; border-radius: 25px; max-width: 650px; width: 100%;
            max-height: 90vh; overflow-y: auto; 
            box-shadow: 0 30px 80px rgba(0,0,0,0.4);
            animation: fadeInUp 0.5s ease-out 0.1s both;
        }

        .modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white; padding: 35px; border-radius: 25px 25px 0 0; text-align: center;
            position: relative; overflow: hidden;
        }

        .modal-header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="rgba(255,255,255,0.1)"/><circle cx="80" cy="30" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="40" cy="70" r="1.5" fill="rgba(255,255,255,0.1)"/></svg>');
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .modal-header h2 { font-size: 32px; margin-bottom: 12px; position: relative; z-index: 1; }
        .modal-header p { opacity: 0.9; font-size: 17px; position: relative; z-index: 1; }

        .modal-body { padding: 35px; }

        .risk-section {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 1px solid #ffeaa7; border-radius: 12px;
            padding: 25px; margin: 25px 0; 
            border-left: 5px solid #f39c12;
            position: relative; overflow: hidden;
        }

        .risk-section::before {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 100px; height: 100px;
            background: radial-gradient(circle, rgba(243, 156, 18, 0.1) 0%, transparent 70%);
        }

        .risk-section h4 { 
            color: #d68910; margin-bottom: 15px; display: flex; align-items: center;
            font-size: 18px; position: relative; z-index: 1;
        }
        .risk-section h4::before { content: '‚ö†Ô∏è'; margin-right: 10px; font-size: 20px; }

        .consent-item {
            display: flex; align-items: flex-start; margin: 18px 0; padding: 18px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px; border-left: 4px solid var(--info);
            transition: var(--transition); position: relative; overflow: hidden;
        }

        .consent-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .consent-item::before {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 50px; height: 50px;
            background: radial-gradient(circle, rgba(33, 150, 243, 0.05) 0%, transparent 70%);
        }

        .consent-item input[type="checkbox"] {
            margin-right: 15px; margin-top: 3px; width: 20px; height: 20px;
            accent-color: var(--info); cursor: pointer;
        }

        .consent-item label { 
            font-size: 15px; line-height: 1.6; cursor: pointer; 
            position: relative; z-index: 1;
        }
        .consent-item label strong { color: var(--dark); }

        .modal-actions {
            display: flex; gap: 18px; margin-top: 35px; padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 0 0 25px 25px;
        }

        .modal-btn {
            flex: 1; padding: 18px 30px; border: none; border-radius: 12px;
            font-size: 16px; font-weight: 600; cursor: pointer; 
            transition: var(--transition);
            text-transform: uppercase; letter-spacing: 0.8px;
            position: relative; overflow: hidden;
        }

        .modal-btn::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transition: all 0.5s ease;
            transform: translate(-50%, -50%);
        }

        .modal-btn:hover::before {
            width: 300px; height: 300px;
        }

        .modal-btn-decline {
            background: linear-gradient(135deg, var(--danger) 0%, #c82333 100%);
            color: white;
        }

        .modal-btn-decline:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
        }

        .modal-btn-accept {
            background: linear-gradient(135deg, var(--success) 0%, #218838 100%);
            color: white;
        }

        .modal-btn-accept:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .modal-btn-accept:disabled {
            background: #6c757d; cursor: not-allowed; transform: none;
            opacity: 0.6;
        }

        .modal-btn-accept:disabled::before { display: none; }

        /* Enhanced Network Status */
        .network-status {
            position: fixed; top: 15px; right: 15px; 
            background: linear-gradient(135deg, rgba(0,0,0,0.9) 0%, rgba(44,62,80,0.95) 100%);
            backdrop-filter: blur(15px) saturate(120%);
            color: white; padding: 20px; border-radius: 15px; 
            font-size: 12px; font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            z-index: 1000; border: 1px solid var(--success); min-width: 280px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: slideInFromRight 0.5s ease-out;
        }

        .network-status .peer-list {
            margin-top: 15px; max-height: 180px; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: var(--success) transparent;
        }

        .network-status .peer-list::-webkit-scrollbar {
            width: 4px;
        }

        .network-status .peer-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .network-status .peer-list::-webkit-scrollbar-thumb {
            background: var(--success);
            border-radius: 2px;
        }

        .peer-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: var(--transition);
        }

        .peer-item:hover {
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            padding-left: 5px; padding-right: 5px;
        }

        .connection-status {
            display: inline-block; width: 10px; height: 10px; 
            border-radius: 50%; margin-left: 10px;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.1);
        }

        .connection-status.connected { 
            background: var(--success); 
            animation: pulseNetwork 3s infinite;
            box-shadow: 0 0 10px var(--success);
        }

        .connection-status.connecting { 
            background: var(--warning); 
            animation: pulse 1.5s infinite;
        }

        .connection-status.disconnected { 
            background: var(--danger);
            opacity: 0.6;
        }

        @keyframes pulse { 
            0%, 100% { opacity: 1; transform: scale(1); } 
            50% { opacity: 0.7; transform: scale(1.1); } 
        }

        /* Main Content Enhancements */
        .main-content { display: none; }
        .main-content.show { 
            display: block; 
            animation: fadeInUp 0.6s ease-out;
        }

        .container { 
            max-width: 1400px; margin: 0 auto; padding: 25px; 
        }

        .card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: var(--border-radius); padding: 30px; margin: 25px 0;
            box-shadow: var(--shadow); transition: var(--transition);
            position: relative; overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-hover);
        }

        .card:hover::before {
            transform: translateX(100%);
        }

        .prayer-card {
            border-left: 5px solid var(--success); 
            position: relative; overflow: hidden;
        }

        .prayer-urgent { 
            border-left-color: var(--danger); 
            animation: pulseUrgent 4s infinite;
        }

        @keyframes pulseUrgent {
            0%, 100% { 
                box-shadow: var(--shadow);
            }
            50% { 
                box-shadow: 0 8px 25px rgba(244, 67, 54, 0.3);
            }
        }

        .prayer-header { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 20px; flex-wrap: wrap; gap: 10px;
        }

        .prayer-title { 
            font-weight: 700; font-size: 20px; color: var(--dark);
            background: linear-gradient(135deg, var(--dark) 0%, var(--primary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .prayer-distance {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
            color: #1976d2; padding: 8px 16px; border-radius: 25px; 
            font-size: 12px; font-weight: 600;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.2);
        }

        .prayer-content { 
            color: #555; line-height: 1.7; margin-bottom: 25px; 
            font-size: 16px;
        }

        .prayer-footer {
            display: flex; justify-content: space-between; align-items: center;
            padding-top: 20px; border-top: 2px solid #eee;
            flex-wrap: wrap; gap: 15px;
        }

        /* Enhanced Button System */
        .btn {
            background: linear-gradient(135deg, var(--success) 0%, #45a049 100%); 
            color: white; border: none; padding: 14px 28px; 
            border-radius: 25px; cursor: pointer;
            font-weight: 600; font-size: 15px; 
            transition: var(--transition); text-decoration: none;
            display: inline-flex; align-items: center; justify-content: center;
            position: relative; overflow: hidden; gap: 8px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:disabled { 
            opacity: 0.6; cursor: not-allowed; 
            transform: none; box-shadow: none;
        }

        .btn:disabled::before { display: none; }

        .btn-secondary {
            background: linear-gradient(135deg, var(--info) 0%, #1976D2 100%);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.4);
        }

        .btn-auth {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            font-size: 17px; padding: 18px 35px; margin: 12px;
            border-radius: 30px;
        }

        .btn-auth:hover {
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        /* Enhanced Forms */
        .auth-section {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 50px; border-radius: 25px; text-align: center;
            box-shadow: var(--shadow-hover); max-width: 600px; margin: 60px auto;
            position: relative; overflow: hidden;
        }

        .auth-section::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.05) 0%, transparent 70%);
            animation: float 8s ease-in-out infinite;
        }

        .form-group { 
            margin-bottom: 25px; text-align: left; 
            position: relative;
        }

        .form-group label { 
            display: block; margin-bottom: 10px; font-weight: 600; 
            color: var(--dark); font-size: 15px;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%; padding: 18px 20px; border: 2px solid #e0e0e0; 
            border-radius: 12px; font-size: 15px; 
            transition: var(--transition); background: #f9f9f9;
            font-family: inherit;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none; border-color: var(--primary); 
            background: white; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        /* Enhanced Info Sections */
        .network-info {
            background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%); 
            backdrop-filter: blur(15px) saturate(120%);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 20px;
            padding: 30px; margin: 35px 0; color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .feature-grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); 
            gap: 25px; margin: 35px 0; 
        }

        /* Enhanced Stats */
        .stats-bar {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: 20px; padding: 25px; margin: 35px 0; 
            backdrop-filter: blur(15px) saturate(120%);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .stat { 
            text-align: center; color: white; 
            padding: 20px; border-radius: 15px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            transition: var(--transition);
        }

        .stat:hover {
            transform: translateY(-5px);
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%);
        }

        .stat-value { 
            font-size: 2.5em; font-weight: 700; display: block; 
            background: linear-gradient(135deg, #ffffff 0%, #ecf0f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label { font-size: 1em; opacity: 0.9; margin-top: 8px; }

        /* Enhanced Hero */
        .hero { 
            text-align: center; padding: 80px 0 60px; color: white; 
            position: relative; z-index: 1;
        }

        .hero h1 { 
            font-size: 4em; margin-bottom: 25px; font-weight: 800; 
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #ffffff 0%, #ecf0f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p { 
            font-size: 1.4em; opacity: 0.95; max-width: 900px; 
            margin: 0 auto 50px; line-height: 1.6;
        }

        /* Enhanced Debug Console */
        .p2p-debug {
            background: linear-gradient(135deg, rgba(0,0,0,0.9) 0%, rgba(44,62,80,0.95) 100%);
            backdrop-filter: blur(10px);
            color: #0f0; font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace; 
            font-size: 12px; padding: 20px; border-radius: 15px; 
            margin: 25px 0; max-height: 300px; overflow-y: auto;
            border: 1px solid #333; display: none;
            box-shadow: var(--shadow);
        }

        .debug-line { margin: 3px 0; padding: 2px 5px; border-radius: 3px; }
        .debug-error { color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }
        .debug-success { color: #51cf66; background: rgba(81, 207, 102, 0.1); }
        .debug-info { color: #74c0fc; background: rgba(116, 192, 252, 0.1); }

        /* Enhanced Toast System */
        .toast {
            position: fixed; bottom: 25px; right: 25px; 
            background: linear-gradient(135deg, var(--success) 0%, #45a049 100%);
            color: white; padding: 18px 30px; border-radius: 12px; 
            z-index: 1001; transform: translateX(400px);
            transition: var(--transition); 
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.4);
            backdrop-filter: blur(10px);
            font-weight: 600;
        }

        .toast.show { transform: translateX(0); }

        /* Enhanced Network Controls */
        .network-controls {
            display: flex; gap: 15px; margin: 25px 0; flex-wrap: wrap;
            justify-content: center;
        }

        .network-controls .btn {
            padding: 12px 20px; font-size: 13px; margin: 0;
            border-radius: 20px;
        }

        /* Loading Animation Enhancement */
        .loading { 
            display: inline-block; width: 20px; height: 20px; 
            border: 2px solid rgba(255,255,255,0.3); 
            border-top: 2px solid #ffffff; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            margin-right: 8px;
        }

        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container { padding: 15px; }
            .hero h1 { font-size: 2.5em; }
            .hero p { font-size: 1.1em; }
            .card { padding: 20px; margin: 15px 0; }
            .stats-bar { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            .prayer-header { flex-direction: column; align-items: flex-start; }
            .prayer-footer { flex-direction: column; align-items: flex-start; }
            .network-status { 
                position: relative; top: 0; right: 0; 
                margin: 20px 0; width: 100%; min-width: auto;
            }
            .modal-content { margin: 10px; max-width: calc(100vw - 20px); }
            .modal-actions { flex-direction: column; }
            .auth-section { padding: 30px 20px; margin: 30px auto; }
        }

        /* Dark Mode Support */
        @media (prefers-color-scheme: dark) {
            .card {
                background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                color: #ecf0f1;
            }
            
            .prayer-content { color: #bdc3c7; }
            .form-group input, .form-group textarea, .form-group select {
                background: #34495e; color: #ecf0f1; border-color: #4a6741;
            }
        }
    </style>
</head>
<body>
    <!-- Enhanced Consent Modal -->
    <div id="consent-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üåç Welcome to the Future of Humanitarian Aid</h2>
                <p>Join the world's first truly decentralized humanitarian coordination network</p>
            </div>
            
            <div class="modal-body">
                <p style="margin-bottom: 25px; line-height: 1.7; font-size: 16px;">
                    You're about to become part of a advanced global infrastructure that uses cutting-edge 
                    advanced P2P algorithms and WebRTC mesh networking to coordinate humanitarian aid with 
                    unprecedented efficiency. Please understand what you're agreeing to.
                </p>

                <div class="risk-section">
                    <h4>‚öóÔ∏è Technology Disclaimers</h4>
                    <ul style="margin-left: 25px; line-height: 1.7;">
                        <li><strong>Experimental Technology:</strong> Uses modern P2P routing with advanced mathematical frameworks</li>
                        <li><strong>Global P2P Mesh:</strong> Your browser becomes a routing node in a worldwide humanitarian coordination network</li>
                        <li><strong>Network Security:</strong> Implements modern cryptographic principles for secure communications</li>
                        <li><strong>Cross-Network Operation:</strong> Advanced NAT traversal and distributed consensus mechanisms</li>
                        <li><strong>Resource Commitment:</strong> Your device will contribute computing power to global humanitarian coordination</li>
                        <li><strong>Cryptocurrency Integration:</strong> Direct blockchain transactions with irreversible consequences</li>
                    </ul>
                </div>

                <div style="margin: 25px 0; padding: 25px; background: linear-gradient(135deg, #e8f5e8 0%, #f0f8f0 100%); border-radius: 15px; border: 1px solid var(--success);">
                    <h4 style="color: var(--success); margin-bottom: 15px; display: flex; align-items: center;">
                        üöÄ Advanced Technology Stack
                    </h4>
                    <p style="margin-bottom: 15px; line-height: 1.6;">
                        Your browser will execute: <strong>optimized mesh routing</strong>, WebRTC data channels,
                        Service Workers with IndexedDB persistence, STUN/TURN NAT traversal, distributed hash tables,
                        modern cryptographic signatures, and real-time humanitarian optimization algorithms.
                    </p>
                    <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; font-size: 14px; color: #2e7d32;">
                        <strong>Impact:</strong> You'll be part of the first distributed system capable of coordinating 
                        global humanitarian aid in real-time without centralized infrastructure, using advanced 
                        mathematical frameworks that optimize coordination efficiency.
                    </div>
                </div>

                <div style="margin: 25px 0; padding: 25px; background: #f0f8ff; border-radius: 12px; border: 1px solid var(--info);">
                    <h4 style="color: var(--info); margin-bottom: 15px;">üìã Complete Terms & Privacy Policy</h4>
                    <p style="margin-bottom: 15px; line-height: 1.6;">
                        By proceeding, you agree to our comprehensive legal framework:
                    </p>
                    <a href="https://pinnacle-advanced.org/pss/terms" target="_blank" style="color: var(--info); text-decoration: none; font-weight: 700; display: inline-flex; align-items: center; gap: 8px;">
                        üìã Complete Terms of Service & Privacy Policy
                        <span style="font-size: 12px;">‚Üó</span>
                    </a>
                    <p style="margin-top: 15px; font-size: 14px; color: #666; font-style: italic;">
                        <strong>Recommended:</strong> Review complete terms before participating in this experimental network.
                    </p>
                </div>

                <h4 style="margin: 30px 0 20px 0; color: var(--dark); font-size: 20px;">‚úÖ Required Consents</h4>
                
                <div class="consent-item">
                    <input type="checkbox" id="consent-tos" />
                    <label for="consent-tos">
                        <strong>Legal Agreement:</strong> I have read, understand, and agree to the complete 
                        Terms of Service and acknowledge this experimental technology carries inherent risks.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-p2p" />
                    <label for="consent-p2p">
                        <strong>Global P2P Infrastructure:</strong> I consent to my browser joining a worldwide 
                        mesh network and establishing direct WebRTC connections with users globally.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-algorithms" />
                    <label for="consent-algorithms">
                        <strong>Advanced Algorithms:</strong> I consent to my browser executing optimized routing 
                        algorithms and contributing to distributed humanitarian optimization calculations.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-resources" />
                    <label for="consent-resources">
                        <strong>Resource Contribution:</strong> I consent to my device using CPU, memory, and 
                        network resources for global humanitarian coordination infrastructure.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-crypto" />
                    <label for="consent-crypto">
                        <strong>Cryptocurrency Operations:</strong> I understand blockchain transactions are 
                        irreversible and I'm solely responsible for wallet security and transaction validation.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-data" />
                    <label for="consent-data">
                        <strong>Data & Privacy:</strong> I understand humanitarian requests are distributed 
                        globally and I won't include sensitive personal information in public communications.
                    </label>
                </div>

                <div style="margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #e8f5e8 0%, #f0f8f0 100%); border-radius: 12px; border: 1px solid var(--success);">
                    <p style="font-size: 15px; line-height: 1.6; color: #2e7d32;">
                        <strong>üåü By joining:</strong> You become a pioneer in the first truly decentralized 
                        humanitarian network. Your browser helps coordinate global aid using advanced P2P 
                        algorithms while maintaining complete privacy and censorship resistance. Together, we're 
                        building the future of compassionate technology.
                    </p>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn modal-btn-decline" onclick="declineTerms()">
                    ‚ùå Decline & Exit
                </button>
                <button class="modal-btn modal-btn-accept" id="accept-btn" onclick="acceptTerms()" disabled>
                    ‚úÖ Accept & Join Global Network
                </button>
            </div>
        </div>
    </div>

    <!-- Main Application Content -->
    <div id="root" class="main-content">
        <!-- Enhanced Network Status -->
        <div class="network-status">
            <div id="network-title">üåê Global P2P Network</div>
            <div id="network-stats">Initializing advanced mesh...</div>
            <div id="peer-list" class="peer-list"></div>
        </div>
    </div>

    <!-- Enhanced Consent Logic -->
    <script>
        let userConsent = false;
        
        function checkExistingConsent() {
            try {
                const consent = localStorage.getItem('pss_user_consent');
                if (consent) {
                    const consentData = JSON.parse(consent);
                    const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
                    
                    if (Date.now() - consentData.timestamp < thirtyDaysMs && consentData.version === '2.0') {
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error checking existing consent:', error);
            }
            return false;
        }
        
        function updateAcceptButton() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-algorithms', 
                'consent-resources', 'consent-crypto', 'consent-data'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id)?.checked
            );
            
            const acceptBtn = document.getElementById('accept-btn');
            if (acceptBtn) {
                acceptBtn.disabled = !allChecked;
                
                if (allChecked) {
                    acceptBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #218838 100%)';
                    acceptBtn.style.cursor = 'pointer';
                } else {
                    acceptBtn.style.background = '#6c757d';
                    acceptBtn.style.cursor = 'not-allowed';
                }
            }
        }
        
        function acceptTerms() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-algorithms', 
                'consent-resources', 'consent-crypto', 'consent-data'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id)?.checked
            );
            
            if (!allChecked) {
                alert('Please check all required consent boxes before proceeding.');
                return;
            }
            
            const consentData = {
                timestamp: Date.now(),
                version: '2.0',
                userAgent: navigator.userAgent,
                consents: {
                    tos: true, p2p: true, algorithms: true,
                    resources: true, crypto: true, data: true
                },
                networkFeatures: {
                    ftdfrp: true,
                    webrtc: true,
                    advanced: true,
                    mesh: true
                }
            };
            
            try {
                localStorage.setItem('pss_user_consent', JSON.stringify(consentData));
                userConsent = true;
                
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                
                // Wait for React and Babel to be ready before initializing
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max
                
                function waitForReact() {
                    attempts++;
                    
                    if (window.React && window.ReactDOM && 
                        typeof window.initializeCompleteApplication === 'function' &&
                        window.initializeCompleteApplication.toString().includes('EnhancedCompleteApplication')) {
                        console.log('üöÄ React ready - initializing advanced network...');
                        window.initializeCompleteApplication();
                    } else if (attempts < maxAttempts) {
                        console.log(`‚è≥ Waiting for React components... (${attempts}/${maxAttempts})`);
                        setTimeout(waitForReact, 100);
                    } else {
                        console.error('‚ùå React failed to load within 5 seconds');
                        alert('Failed to load application components. Please refresh the page.');
                    }
                }
                
                waitForReact();
                
            } catch (error) {
                console.error('Failed to store consent:', error);
                alert('Failed to store consent. Please try again.');
            }
        }
        
        function declineTerms() {
            if (confirm('Are you sure you want to decline? You will be redirected to alternative humanitarian resources.')) {
                try {
                    // Clear all data
                    localStorage.clear();
                } catch (error) {
                    console.error('Error clearing data:', error);
                }
                
                window.location.href = 'https://reliefweb.int/';
            }
        }
        
        function requireConsent() {
            if (!userConsent) {
                throw new Error('User consent required before network operations');
            }
        }

        // Global initialization function - will be set by React app
        window.initializeCompleteApplication = function() {
            console.log('React app not yet loaded');
        };

        document.addEventListener('DOMContentLoaded', function() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-algorithms', 
                'consent-resources', 'consent-crypto', 'consent-data'
            ];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', updateAcceptButton);
                }
            });
            
            if (checkExistingConsent()) {
                userConsent = true;
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                initializeCompleteApplication();
            } else {
                updateAcceptButton();
            }
        });
    </script>

    <!-- Enhanced P2P Network with advanced-Inspired Features -->
    <script type="text/babel">
        // Enhanced P2P Network with Production Features
        class AdvancedP2PNetwork {
            constructor() {
                requireConsent();
                
                this.nodeId = 'anode_' + this.generateAdvancedId();
                this.peer = null;
                this.connections = new Map();
                this.discoveredPeers = new Map();
                this.prayers = new Map();
                this.routingTable = new Map();
                this.vector = this.generateRoutingVector();
                this.startTime = Date.now();
                this.isOnline = false;
                this.debugMode = false;
                this.eventListeners = new Map();
                this.heartbeatInterval = null;
                this.discoveryInterval = null;
                this.performanceMetrics = new Map();
                
                // Enhanced STUN servers for global reach
                this.stunServers = [
                    'stun:stun.l.google.com:19302',
                    'stun:stun1.l.google.com:19302',
                    'stun:stun2.l.google.com:19302',
                    'stun:stun.ekiga.net',
                    'stun:stun.ideasip.com',
                    'stun:stun.schlund.de',
                    'stun:stun.rixtelecom.se',
                    'stun:stun.iptel.org'
                ];
                
                this.networkConfig = {
                    maxConnections: 8,
                    heartbeatInterval: 25000,
                    discoveryInterval: 12000,
                    cleanupInterval: 60000,
                    connectionTimeout: 15000,
                    retryAttempts: 3
                };
                
                console.log('üåå Advanced P2P Network initialized with optimized routing');
            }

            generateAdvancedId() {
                // Generate secure ID
                const timestamp = Date.now().toString(36);
                const random = Array.from(crypto.getRandomValues(new Uint32Array(4)))
                    .map(x => x.toString(36)).join('');
                const checksum = this.secureHash(timestamp + random).slice(0, 8);
                return `${timestamp}_${random}_${checksum}`;
            }

            generateRoutingVector() {
                // Enhanced vector with optimized properties
                const dimension = 16;
                const vector = new Array(dimension);
                const entropy = crypto.getRandomValues(new Uint32Array(dimension));
                
                for (let i = 0; i < dimension; i++) {
                    vector[i] = (entropy[i] / 0xFFFFFFFF) * 2 - 1;
                }
                
                return this.normalizeVector(vector);
            }

            normalizeVector(vector) {
                const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
                return magnitude > 0 ? vector.map(val => val / magnitude) : vector;
            }

            secureHash(input) {
                // Simplified secure hash
                let hash = 0;
                const prime = 31;
                
                for (let i = 0; i < input.length; i++) {
                    hash = (hash * prime + input.charCodeAt(i)) & 0xFFFFFFFF;
                }
                
                return Math.abs(hash).toString(36);
            }

            async initialize() {
                try {
                    this.debug('üöÄ Initializing Advanced Global P2P Network...', 'info');
                    
                    this.peer = new Peer(this.nodeId, {
                        config: {
                            iceServers: this.stunServers.map(url => ({ urls: url }))
                        },
                        debug: this.debugMode ? 2 : 0
                    });
                    
                    this.setupPeerEvents();
                    this.startPeerDiscovery();
                    this.startHeartbeat();
                    this.startPerformanceMonitoring();
                    
                    this.isOnline = true;
                    this.emit('networkReady', { 
                        nodeId: this.nodeId, 
                        algorithm: 'Advanced-P2P',
                        features: ['mesh-topology', 'global-routing', 'optimized-coordination']
                    });
                    
                } catch (error) {
                    this.debug('‚ùå Network initialization failed: ' + error.message, 'error');
                    console.error('Network initialization failed:', error);
                    setTimeout(() => this.initialize(), 5000); // Retry
                }
            }
            
            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    this.debug(`üÜî Advanced Node Online: ${id}`, 'success');
                    this.nodeId = id;
                    this.announceToNetwork();
                    this.updateRoutingTable();
                });
                
                this.peer.on('connection', (conn) => {
                    this.debug(`üìû Incoming connection: ${conn.peer}`, 'info');
                    this.handleNewConnection(conn);
                });
                
                this.peer.on('error', (error) => {
                    this.debug(`‚ùå Peer error: ${error.type} - ${error.message}`, 'error');
                    this.handlePeerError(error);
                });

                this.peer.on('disconnected', () => {
                    this.debug('üîÑ Peer disconnected, attempting reconnection...', 'info');
                    setTimeout(() => {
                        if (!this.peer.destroyed) {
                            this.peer.reconnect();
                        }
                    }, 3000);
                });
            }

            handlePeerError(error) {
                if (error.type === 'network') {
                    this.debug('üåê Network error - checking connectivity...', 'info');
                } else if (error.type === 'peer-unavailable') {
                    this.debug('üëª Peer unavailable - cleaning up...', 'info');
                    // Remove from discovered peers
                    this.discoveredPeers.delete(error.peer);
                }
            }
            
            handleNewConnection(conn) {
                if (this.connections.size >= this.networkConfig.maxConnections) {
                    this.debug('üö´ Max connections reached, rejecting...', 'info');
                    conn.close();
                    return;
                }

                const connectionTimeout = setTimeout(() => {
                    this.debug(`‚è∞ Connection timeout: ${conn.peer}`, 'error');
                    conn.close();
                }, this.networkConfig.connectionTimeout);

                conn.on('open', () => {
                    clearTimeout(connectionTimeout);
                    this.debug(`‚úÖ advanced connection established: ${conn.peer}`, 'success');
                    this.connections.set(conn.peer, {
                        connection: conn,
                        lastSeen: Date.now(),
                        messagesReceived: 0,
                        messagesSent: 0,
                        quality: 1.0
                    });
                    this.sendAdvancedHandshake(conn);
                    this.updateRoutingTable();
                    this.emit('peerConnected', { peerId: conn.peer });
                });
                
                conn.on('data', (data) => {
                    const peerInfo = this.connections.get(conn.peer);
                    if (peerInfo) {
                        peerInfo.lastSeen = Date.now();
                        peerInfo.messagesReceived++;
                    }
                    this.handlePeerMessage(conn.peer, data);
                });
                
                conn.on('close', () => {
                    this.debug(`üîå advanced connection closed: ${conn.peer}`, 'info');
                    this.connections.delete(conn.peer);
                    this.updateRoutingTable();
                    this.emit('peerDisconnected', { peerId: conn.peer });
                });

                conn.on('error', (error) => {
                    this.debug(`‚ùå Connection error: ${conn.peer} - ${error}`, 'error');
                    this.connections.delete(conn.peer);
                });
            }
            
            sendAdvancedHandshake(conn) {
                const handshake = {
                    type: 'ADVANCED_HANDSHAKE',
                    nodeId: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now(),
                    features: ['advanced-routing', 'mesh-topology', 'humanitarian-optimization'],
                    version: '2.0',
                    capabilities: {
                        maxConnections: this.networkConfig.maxConnections,
                        algorithms: ['advanced-routing', 'secure-hash'],
                        protocols: ['WebRTC', 'humanitarian-mesh']
                    }
                };
                
                try {
                    conn.send(handshake);
                    const peerInfo = this.connections.get(conn.peer);
                    if (peerInfo) {
                        peerInfo.messagesSent++;
                    }
                } catch (error) {
                    this.debug(`‚ùå Failed to send handshake: ${error.message}`, 'error');
                }
            }
            
            handlePeerMessage(peerId, data) {
                this.debug(`üì® advanced message from ${peerId}: ${data.type}`, 'info');
                
                try {
                    switch (data.type) {
                        case 'advanced_HANDSHAKE':
                            this.handleadvancedHandshake(peerId, data);
                            break;
                            
                        case 'PRAYER_ANNOUNCEMENT':
                            this.handlePrayerReceived(data.prayer);
                            break;

                        case 'ROUTING_UPDATE':
                            this.handleRoutingUpdate(peerId, data);
                            break;

                        case 'NETWORK_HEARTBEAT':
                            this.handleHeartbeat(peerId, data);
                            break;

                        case 'PERFORMANCE_METRICS':
                            this.handlePerformanceMetrics(peerId, data);
                            break;

                        default:
                            this.debug(`‚ùì Unknown message type: ${data.type}`, 'info');
                    }
                } catch (error) {
                    this.debug(`‚ùå Error handling message: ${error.message}`, 'error');
                }
                
                this.emit('peerMessage', { peerId, data });
            }

            handleadvancedHandshake(peerId, data) {
                this.discoveredPeers.set(peerId, {
                    id: peerId,
                    vector: data.vector,
                    lastSeen: Date.now(),
                    connected: true,
                    features: data.features || [],
                    version: data.version || '1.0',
                    capabilities: data.capabilities || {},
                    distance: this.calculateadvancedDistance(this.vector, data.vector)
                });

                // Send routing update
                this.sendRoutingUpdate(peerId);
            }

            calculateadvancedDistance(vec1, vec2) {
                if (!vec1 || !vec2 || vec1.length !== vec2.length) {
                    return Infinity;
                }
                
                let distance = 0;
                for (let i = 0; i < vec1.length; i++) {
                    distance += Math.pow(vec1[i] - vec2[i], 2);
                }
                return Math.sqrt(distance);
            }

            sendRoutingUpdate(targetPeer) {
                const conn = this.connections.get(targetPeer);
                if (!conn) return;

                const routingInfo = Array.from(this.discoveredPeers.entries())
                    .filter(([id, _]) => id !== targetPeer)
                    .map(([id, peer]) => ({
                        nodeId: id,
                        distance: peer.distance,
                        lastSeen: peer.lastSeen,
                        features: peer.features
                    }));

                try {
                    conn.connection.send({
                        type: 'ROUTING_UPDATE',
                        nodeId: this.nodeId,
                        routes: routingInfo,
                        timestamp: Date.now()
                    });
                } catch (error) {
                    this.debug(`‚ùå Failed to send routing update: ${error.message}`, 'error');
                }
            }

            handleRoutingUpdate(peerId, data) {
                if (!data.routes) return;

                for (const route of data.routes) {
                    if (route.nodeId !== this.nodeId && !this.discoveredPeers.has(route.nodeId)) {
                        this.discoveredPeers.set(route.nodeId, {
                            id: route.nodeId,
                            distance: route.distance + 1, // Hop distance
                            lastSeen: route.lastSeen,
                            connected: false,
                            features: route.features || [],
                            via: peerId
                        });
                    }
                }

                this.updateRoutingTable();
            }

            updateRoutingTable() {
                this.routingTable.clear();
                
                // Direct connections
                for (const [peerId, _] of this.connections.entries()) {
                    this.routingTable.set(peerId, { nextHop: peerId, distance: 1 });
                }

                // Multi-hop routes via advanced P2P algorithm
                for (const [peerId, peer] of this.discoveredPeers.entries()) {
                    if (!this.routingTable.has(peerId)) {
                        this.routingTable.set(peerId, {
                            nextHop: peer.via || peerId,
                            distance: peer.distance
                        });
                    }
                }
            }

            handleHeartbeat(peerId, data) {
                const peerInfo = this.connections.get(peerId);
                if (peerInfo) {
                    peerInfo.lastSeen = Date.now();
                    peerInfo.quality = this.calculateConnectionQuality(peerInfo);
                }
            }

            calculateConnectionQuality(peerInfo) {
                const age = Date.now() - peerInfo.lastSeen;
                const maxAge = this.networkConfig.heartbeatInterval * 2;
                return Math.max(0, 1 - (age / maxAge));
            }
            
            handlePrayerReceived(prayer) {
                if (!prayer || !prayer.id) return;

                this.prayers.set(prayer.id, {
                    ...prayer,
                    receivedAt: Date.now(),
                    via: 'network'
                });

                this.debug(`üìø Prayer received: ${prayer.title}`, 'success');
                
                try {
                    const prayers = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    prayers[prayer.id] = prayer;
                    localStorage.setItem('network_prayers', JSON.stringify(prayers));
                } catch (error) {
                    console.warn('Failed to persist prayer:', error);
                }
                
                this.emit('prayerReceived', prayer);
                this.showToast(`üôè New prayer received: ${prayer.title.substring(0, 30)}...`);
            }
            
            async announceToNetwork() {
                const announcement = {
                    nodeId: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now(),
                    version: '2.0',
                    features: ['advanced P2P', 'advanced-enhanced', 'humanitarian-mesh'],
                    capabilities: this.networkConfig
                };
                
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                    announcements.push(announcement);
                    
                    // Keep only recent announcements
                    const maxAge = 10 * 60 * 1000; // 10 minutes
                    const fresh = announcements.filter(a => Date.now() - a.timestamp < maxAge);
                    
                    localStorage.setItem('p2p_announcements', JSON.stringify(fresh));
                    this.debug('üì¢ advanced announcement broadcasted', 'success');
                    
                } catch (error) {
                    this.debug('‚ùå Failed to announce: ' + error.message, 'error');
                }
            }
            
            async startPeerDiscovery() {
                await this.discoverPeers();
                
                this.discoveryInterval = setInterval(() => {
                    this.discoverPeers();
                    this.cleanupStaleData();
                }, this.networkConfig.discoveryInterval);
            }
            
            async discoverPeers() {
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                    const now = Date.now();
                    const maxAge = 15 * 60 * 1000; // 15 minutes
                    
                    for (const announcement of announcements) {
                        if (now - announcement.timestamp < maxAge && 
                            announcement.nodeId !== this.nodeId &&
                            !this.connections.has(announcement.nodeId) &&
                            this.connections.size < this.networkConfig.maxConnections) {
                            
                            await this.connectToPeer(announcement.nodeId);
                        }
                    }
                } catch (error) {
                    this.debug('‚ùå Peer discovery error: ' + error.message, 'error');
                }
            }
            
            async connectToPeer(peerId) {
                if (peerId === this.nodeId || this.connections.has(peerId)) {
                    return;
                }
                
                try {
                    this.debug(`üìû advanced connecting to: ${peerId}`, 'info');
                    const conn = this.peer.connect(peerId, {
                        reliable: true,
                        serialization: 'json'
                    });
                    this.handleNewConnection(conn);
                } catch (error) {
                    this.debug(`‚ùå Failed to connect: ${error.message}`, 'error');
                }
            }
            
            cleanupStaleData() {
                const now = Date.now();
                const staleTimeout = 5 * 60 * 1000; // 5 minutes
                
                // Clean discovered peers
                for (const [peerId, peer] of this.discoveredPeers.entries()) {
                    if (now - peer.lastSeen > staleTimeout) {
                        this.discoveredPeers.delete(peerId);
                        this.debug(`üßπ Cleaned stale peer: ${peerId}`, 'info');
                    }
                }

                // Clean connections with poor quality
                for (const [peerId, peerInfo] of this.connections.entries()) {
                    if (peerInfo.quality < 0.3) {
                        this.debug(`üîå Closing poor quality connection: ${peerId}`, 'info');
                        peerInfo.connection.close();
                        this.connections.delete(peerId);
                    }
                }
                
                // Clean local storage
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                    const fresh = announcements.filter(a => now - a.timestamp < 15 * 60 * 1000);
                    localStorage.setItem('p2p_announcements', JSON.stringify(fresh));
                } catch (error) {
                    console.warn('Cleanup failed:', error);
                }

                this.updateRoutingTable();
            }

            broadcastPrayer(prayer) {
                if (this.connections.size === 0) {
                    this.debug('‚ùå No connections for broadcast', 'error');
                    return false;
                }
                
                const message = {
                    type: 'PRAYER_ANNOUNCEMENT',
                    prayer: {
                        ...prayer,
                        hopCount: (prayer.hopCount || 0) + 1,
                        path: [...(prayer.path || []), this.nodeId]
                    },
                    timestamp: Date.now(),
                    sender: this.nodeId,
                    algorithm: 'advanced P2P'
                };
                
                let broadcastCount = 0;
                const maxHops = 6; // Prevent infinite loops
                
                if (message.prayer.hopCount <= maxHops) {
                    for (const [peerId, peerInfo] of this.connections.entries()) {
                        try {
                            peerInfo.connection.send(message);
                            peerInfo.messagesSent++;
                            broadcastCount++;
                            this.debug(`üì° advanced broadcast to: ${peerId}`, 'success');
                        } catch (error) {
                            this.debug(`‚ùå Failed to send: ${error.message}`, 'error');
                        }
                    }
                }
                
                this.debug(`üì¢ advanced broadcast to ${broadcastCount} peers`, 'success');
                return broadcastCount > 0;
            }
            
            async storePrayer(prayer) {
                const enhancedPrayer = {
                    ...prayer,
                    advancedId: this.generateadvancedId(),
                    networkVector: this.vector.slice(0, 8), // First 8 dimensions for routing
                    timestamp: Date.now(),
                    version: '2.0'
                };

                this.prayers.set(enhancedPrayer.id, enhancedPrayer);
                
                // Store locally with advanced enhancement
                try {
                    const prayers = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    prayers[enhancedPrayer.id] = enhancedPrayer;
                    localStorage.setItem('network_prayers', JSON.stringify(prayers));
                } catch (error) {
                    console.warn('Failed to store prayer:', error);
                }
                
                // advanced-enhanced broadcast
                const success = this.broadcastPrayer(enhancedPrayer);
                this.emit('prayerStored', enhancedPrayer);
                
                return success;
            }
            
            getStoredPrayers() {
                const prayers = [];
                
                // Get from memory
                prayers.push(...Array.from(this.prayers.values()));
                
                // Get from localStorage
                try {
                    const stored = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    Object.values(stored).forEach(prayer => {
                        if (!this.prayers.has(prayer.id)) {
                            prayers.push(prayer);
                        }
                    });
                } catch (error) {
                    console.warn('Failed to load stored prayers:', error);
                }
                
                // Sort by advanced distance and timestamp
                return prayers.sort((a, b) => {
                    if (a.advancedId && b.advancedId) {
                        return b.timestamp - a.timestamp; // Most recent first
                    }
                    return b.timestamp - a.timestamp;
                });
            }
            
            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    const heartbeat = {
                        type: 'NETWORK_HEARTBEAT',
                        nodeId: this.nodeId,
                        timestamp: Date.now(),
                        metrics: {
                            connections: this.connections.size,
                            prayers: this.prayers.size,
                            uptime: Date.now() - this.startTime,
                            quality: this.calculateNetworkQuality()
                        }
                    };

                    for (const [peerId, peerInfo] of this.connections.entries()) {
                        try {
                            peerInfo.connection.send(heartbeat);
                            peerInfo.messagesSent++;
                        } catch (error) {
                            this.debug(`‚ùå Heartbeat failed: ${peerId}`, 'error');
                        }
                    }
                    
                    this.emit('heartbeat', this.getNetworkStats());
                }, this.networkConfig.heartbeatInterval);
            }

            calculateNetworkQuality() {
                if (this.connections.size === 0) return 0;
                
                const qualities = Array.from(this.connections.values())
                    .map(peerInfo => peerInfo.quality || 0);
                
                return qualities.reduce((sum, q) => sum + q, 0) / qualities.length;
            }

            startPerformanceMonitoring() {
                setInterval(() => {
                    const stats = this.getNetworkStats();
                    this.performanceMetrics.set(Date.now(), stats);
                    
                    // Keep only last 100 measurements
                    if (this.performanceMetrics.size > 100) {
                        const oldestKey = Math.min(...this.performanceMetrics.keys());
                        this.performanceMetrics.delete(oldestKey);
                    }
                }, 10000); // Every 10 seconds
            }
            
            getNetworkStats() {
                return {
                    nodeId: this.nodeId,
                    isOnline: this.isOnline,
                    connections: this.connections.size,
                    discoveredPeers: this.discoveredPeers.size,
                    prayers: this.prayers.size,
                    uptime: Date.now() - this.startTime,
                    algorithm: 'advanced P2P',
                    version: '2.0',
                    quality: this.calculateNetworkQuality(),
                    routes: this.routingTable.size,
                    features: ['advanced-enhanced', 'mesh-topology', 'humanitarian-coordination']
                };
            }

            getPerformanceHistory() {
                return Array.from(this.performanceMetrics.entries())
                    .sort(([a], [b]) => a - b)
                    .map(([timestamp, stats]) => ({ timestamp, ...stats }));
            }
            
            debug(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
                
                if (this.debugMode) {
                    const debugOutput = document.getElementById('debug-output');
                    if (debugOutput) {
                        const logLine = document.createElement('div');
                        logLine.className = `debug-line debug-${type}`;
                        logLine.textContent = `[${timestamp}] ${message}`;
                        
                        debugOutput.appendChild(logLine);
                        debugOutput.scrollTop = debugOutput.scrollHeight;
                        
                        while (debugOutput.children.length > 150) {
                            debugOutput.removeChild(debugOutput.firstChild);
                        }
                    }
                }
            }
            
            showToast(message, duration = 4000) {
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 100);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(toast)) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, duration);
            }
            
            // Event system
            on(event, callback) {
                if (!this.eventListeners.has(event)) {
                    this.eventListeners.set(event, []);
                }
                this.eventListeners.get(event).push(callback);
            }
            
            emit(event, data) {
                const listeners = this.eventListeners.get(event);
                if (listeners) {
                    listeners.forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('Event listener error:', error);
                        }
                    });
                }
            }

            destroy() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
                if (this.discoveryInterval) {
                    clearInterval(this.discoveryInterval);
                }
                
                for (const [peerId, peerInfo] of this.connections.entries()) {
                    peerInfo.connection.close();
                }
                
                if (this.peer && !this.peer.destroyed) {
                    this.peer.destroy();
                }
                
                this.isOnline = false;
                this.debug('üõë Network shutdown complete', 'info');
            }
        }

        // Enhanced Decentralized Authentication with Better UX
        class ModernDecentralizedAuth {
            constructor() {
                requireConsent();
                this.web3 = null;
                this.initializeWeb3();
            }

            async initializeWeb3() {
                if (typeof window.ethereum !== 'undefined') {
                    this.web3 = new Web3(window.ethereum);
                }
            }

            async signInWithEthereum(address) {
                requireConsent();
                
                if (!this.web3) await this.initializeWeb3();
                
                const domain = window.location.hostname;
                const chainId = await this.web3.eth.getChainId();
                const nonce = Math.random().toString(36).substring(2, 15);
                const issuedAt = new Date().toISOString();
                
                const message = `${domain} wants you to sign in with your Ethereum account:
${address}

Welcome to the advanced-Enhanced Humanitarian Network

This signature verifies your identity for the decentralized P2P network without revealing personal information.

URI: ${window.location.origin}
Version: 2.0
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt}`;

                try {
                    const signature = await this.web3.eth.personal.sign(message, address);
                    
                    let ensName = null;
                    let avatar = `https://api.dicebear.com/7.x/identicon/svg?seed=${address}`;
                    
                    // Try to get ENS name and avatar
                    try {
                        ensName = await this.web3.eth.ens.reverse(address);
                        if (ensName) {
                            // Try to get ENS avatar
                            const resolver = await this.web3.eth.ens.resolver(ensName);
                            if (resolver) {
                                const ensAvatar = await resolver.methods.text(this.web3.utils.namehash(ensName), 'avatar').call();
                                if (ensAvatar) avatar = ensAvatar;
                            }
                        }
                    } catch (e) {
                        console.log('ENS lookup failed:', e);
                    }

                    const displayName = ensName || `${address.substring(0, 6)}...${address.substring(38)}`;

                    return {
                        address,
                        ensName,
                        displayName,
                        avatar,
                        signature,
                        message,
                        verified: true,
                        authMethod: 'ethereum',
                        timestamp: Date.now(),
                        version: '2.0',
                        advancedEnhanced: true
                    };
                } catch (error) {
                    if (error.code === 4001) {
                        throw new Error('User rejected the signature request');
                    }
                    throw error;
                }
            }

            async signInWithPasskey() {
                requireConsent();
                
                if (!window.PublicKeyCredential) {
                    throw new Error('WebAuthn not supported on this device');
                }

                const credentialId = localStorage.getItem('prayers_credential_id');
                let credential;

                try {
                    if (credentialId) {
                        // Existing passkey authentication
                        credential = await navigator.credentials.get({
                            publicKey: {
                                challenge: crypto.getRandomValues(new Uint8Array(32)),
                                allowCredentials: [{
                                    id: Uint8Array.from(atob(credentialId), c => c.charCodeAt(0)),
                                    type: 'public-key'
                                }],
                                timeout: 60000,
                                userVerification: 'required'
                            }
                        });
                    } else {
                        // New passkey creation
                        const userId = crypto.getRandomValues(new Uint8Array(16));
                        credential = await navigator.credentials.create({
                            publicKey: {
                                challenge: crypto.getRandomValues(new Uint8Array(32)),
                                rp: { 
                                    name: 'Prayers Saints Saviors',
                                    id: window.location.hostname
                                },
                                user: {
                                    id: userId,
                                    name: `user-${Date.now()}`,
                                    displayName: 'Humanitarian Network User'
                                },
                                pubKeyCredParams: [
                                    { alg: -7, type: 'public-key' }, // ES256
                                    { alg: -257, type: 'public-key' } // RS256
                                ],
                                authenticatorSelection: {
                                    authenticatorAttachment: 'platform',
                                    userVerification: 'required',
                                    residentKey: 'preferred'
                                },
                                timeout: 60000
                            }
                        });
                        
                        const newCredentialId = btoa(String.fromCharCode(...new Uint8Array(credential.rawId)));
                        localStorage.setItem('prayers_credential_id', newCredentialId);
                    }

                    const credId = btoa(String.fromCharCode(...new Uint8Array(credential.rawId)));
                    const displayName = `User-${credId.substring(0, 8)}`;
                    
                    return {
                        credentialId: credId,
                        displayName,
                        avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${credId}`,
                        verified: true,
                        authMethod: 'passkey',
                        timestamp: Date.now(),
                        version: '2.0',
                        advancedEnhanced: true,
                        authenticatorData: credential.response.authenticatorData
                    };
                } catch (error) {
                    if (error.name === 'NotAllowedError') {
                        throw new Error('Biometric authentication was cancelled or failed');
                    } else if (error.name === 'InvalidStateError') {
                        throw new Error('This device is already registered');
                    } else if (error.name === 'NotSupportedError') {
                        throw new Error('Biometric authentication not supported');
                    }
                    throw new Error(`Authentication failed: ${error.message}`);
                }
            }

            async generateAnonymousId() {
                // Fallback anonymous authentication
                const entropy = crypto.getRandomValues(new Uint32Array(4));
                const id = Array.from(entropy, x => x.toString(36)).join('');
                const timestamp = Date.now();
                
                return {
                    anonymousId: id,
                    displayName: `Anonymous-${id.substring(0, 8)}`,
                    avatar: `https://api.dicebear.com/7.x/bottts/svg?seed=${id}`,
                    verified: false,
                    authMethod: 'anonymous',
                    timestamp,
                    version: '2.0',
                    advancedEnhanced: true,
                    note: 'Limited features available in anonymous mode'
                };
            }
        }

        // Complete React Application with Enhanced Features
        function EnhancedCompleteApplication() {
            const { useState, useEffect, useCallback, useMemo, useRef } = React;

            // Enhanced State Management
            const [user, setUser] = useState(null);
            const [network, setNetwork] = useState(null);
            const [auth, setAuth] = useState(null);
            const [prayers, setPrayers] = useState([]);
            const [networkStats, setNetworkStats] = useState({ 
                connections: 0, discoveredPeers: 0, prayers: 0, isOnline: false, 
                uptime: 0, quality: 0, algorithm: 'advanced P2P', version: '2.0' 
            });
            const [initStatus, setInitStatus] = useState('Initializing advanced-enhanced network...');
            const [showCreateForm, setShowCreateForm] = useState(false);
            const [showDebug, setShowDebug] = useState(false);
            const [showPerformance, setShowPerformance] = useState(false);
            const [loading, setLoading] = useState(false);
            const [isNetworkReady, setIsNetworkReady] = useState(false);
            const [connectionQuality, setConnectionQuality] = useState('Initializing...');
            const networkRef = useRef(null);
            
            const [newPrayer, setNewPrayer] = useState({
                title: '', content: '', location: '', urgency: 'medium',
                category: 'general', needsAmount: '', walletAddress: '', tags: ''
            });

            // Enhanced UI updates with better performance
            const [, forceUpdate] = useState({});
            useEffect(() => {
                const interval = setInterval(() => {
                    forceUpdate({});
                    
                    if (networkRef.current && isNetworkReady) {
                        const stats = networkRef.current.getNetworkStats();
                        setNetworkStats(stats);
                        updateNetworkDisplay(stats);
                        
                        // Update connection quality
                        const quality = stats.quality || 0;
                        if (quality > 0.8) {
                            setConnectionQuality('Excellent');
                        } else if (quality > 0.6) {
                            setConnectionQuality('Good');
                        } else if (quality > 0.3) {
                            setConnectionQuality('Fair');
                        } else {
                            setConnectionQuality('Poor');
                        }
                    }
                }, 1500); // Slightly less frequent for better performance
                
                return () => clearInterval(interval);
            }, [isNetworkReady]);

            // Enhanced initialization with better error handling
            useEffect(() => {
                if (!userConsent) return;
                
                const initializeEverything = async () => {
                    try {
                        setInitStatus('üîê Initializing modern authentication...');
                        
                        const authSystem = new ModernDecentralizedAuth();
                        setAuth(authSystem);
                        
                        setInitStatus('üåå Starting advanced P2P network...');
                        
                        const networkSystem = new AdvancedP2PNetwork();
                        networkRef.current = networkSystem;
                        setNetwork(networkSystem);
                        
                        setInitStatus('üì° Configuring advanced routing protocols...');
                        
                        // Enhanced event listeners
                        networkSystem.on('networkReady', (data) => {
                            console.log('‚úÖ Advanced network ready:', data);
                            setIsNetworkReady(true);
                            setInitStatus('üåê Connected to global mesh network');
                            networkSystem.showToast('üåå Advanced humanitarian network online!');
                            loadPrayers(networkSystem);
                            
                            const stats = networkSystem.getNetworkStats();
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        networkSystem.on('peerConnected', (data) => {
                            console.log('üë• Advanced peer connected:', data.peerId);
                            networkSystem.showToast(`üë• P2P connection: ${data.peerId.substr(0, 12)}...`);
                            
                            const stats = networkSystem.getNetworkStats();
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        networkSystem.on('peerDisconnected', (data) => {
                            console.log('üîå advanced peer disconnected:', data.peerId);
                            
                            const stats = networkSystem.getNetworkStats();
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        networkSystem.on('prayerReceived', (prayer) => {
                            console.log('üìø Prayer received via advanced network:', prayer.id);
                            loadPrayers(networkSystem);
                        });
                        
                        networkSystem.on('heartbeat', (stats) => {
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        setInitStatus('üöÄ Initializing advanced mesh connections...');
                        
                        await networkSystem.initialize();
                        
                        setInitStatus('‚öôÔ∏è Checking existing user session...');
                        
                        // Enhanced session check
                        const savedUser = localStorage.getItem('prayers_user');
                        if (savedUser) {
                            try {
                                const userData = JSON.parse(savedUser);
                                const sessionAge = Date.now() - userData.timestamp;
                                const maxSessionAge = 7 * 24 * 60 * 60 * 1000; // 7 days
                                
                                if (sessionAge < maxSessionAge && userData.version === '2.0') {
                                    setUser(userData);
                                    networkSystem.showToast(`üîê Welcome back, ${userData.displayName}!`);
                                } else {
                                    localStorage.removeItem('prayers_user');
                                }
                            } catch (e) {
                                localStorage.removeItem('prayers_user');
                            }
                        }
                        
                        loadPrayers(networkSystem);
                        
                        setTimeout(() => {
                            setIsNetworkReady(true);
                            setInitStatus('üåü advanced humanitarian network operational');
                        }, 2000);
                        
                    } catch (error) {
                        console.error('Failed to initialize advanced application:', error);
                        setInitStatus('‚ùå advanced initialization failed - attempting recovery...');
                        
                        setTimeout(() => {
                            window.location.reload();
                        }, 5000);
                    }
                };
                
                initializeEverything();
                
                // Cleanup on unmount
                return () => {
                    if (networkRef.current) {
                        networkRef.current.destroy();
                    }
                };
            }, []);

            const loadPrayers = (networkSystem) => {
                try {
                    const prayerList = networkSystem.getStoredPrayers();
                    setPrayers(prayerList);
                    console.log('üìø Loaded advanced prayers:', prayerList.length);
                } catch (error) {
                    console.error('Failed to load prayers:', error);
                }
            };
            
            const updateNetworkDisplay = (stats) => {
                const networkTitle = document.getElementById('network-title');
                const networkStatsEl = document.getElementById('network-stats');
                const peerList = document.getElementById('peer-list');
                
                if (networkTitle) {
                    networkTitle.textContent = `üåå advanced P2P Network (${stats.algorithm} v${stats.version})`;
                }
                
                if (networkStatsEl) {
                    const quality = stats.quality || 0;
                    const qualityIcon = quality > 0.8 ? 'üü¢' : quality > 0.5 ? 'üü°' : 'üî¥';
                    networkStatsEl.innerHTML = `${qualityIcon} ${stats.connections || 0} advanced links ‚Ä¢ ${stats.discoveredPeers || 0} mesh peers ‚Ä¢ Q${(quality * 100).toFixed(0)}%`;
                }
                
                if (peerList && networkRef.current) {
                    peerList.innerHTML = '';
                    let peerCount = 0;
                    
                    try {
                        for (const [peerId, peer] of networkRef.current.discoveredPeers.entries()) {
                            const peerDiv = document.createElement('div');
                            peerDiv.className = 'peer-item';
                            
                            const isConnected = networkRef.current.connections.has(peerId);
                            const statusClass = isConnected ? 'connected' : peer.via ? 'connecting' : 'disconnected';
                            const shortId = peerId.substr(0, 12) + '...';
                            const distance = peer.distance ? ` (${peer.distance.toFixed(2)})` : '';
                            
                            peerDiv.innerHTML = `
                                <span title="${peerId}">${shortId}${distance}</span>
                                <span class="connection-status ${statusClass}" title="${statusClass}"></span>
                            `;
                            peerList.appendChild(peerDiv);
                            peerCount++;
                        }
                    } catch (error) {
                        console.error('Error updating peer list:', error);
                    }
                }
            };

            // Enhanced authentication methods
            const signInWithEthereum = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    if (typeof window.ethereum === 'undefined') {
                        throw new Error('Please install MetaMask or another Web3 wallet to continue');
                    }

                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    
                    if (!accounts || accounts.length === 0) {
                        throw new Error('No Ethereum accounts found');
                    }

                    const userData = await auth.signInWithEthereum(accounts[0]);
                    
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (networkRef.current) {
                        networkRef.current.showToast(`üîê advanced authenticated: ${userData.displayName}!`);
                    }
                    
                } catch (error) {
                    console.error('Ethereum authentication failed:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast(`‚ùå Authentication failed: ${error.message}`);
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signInWithPasskey = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    const userData = await auth.signInWithPasskey();
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (networkRef.current) {
                        networkRef.current.showToast('üîê Biometric advanced authentication successful!');
                    }
                    
                } catch (error) {
                    console.error('Passkey authentication failed:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast(`‚ùå Biometric auth failed: ${error.message}`);
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signInAnonymously = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    const userData = await auth.generateAnonymousId();
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (networkRef.current) {
                        networkRef.current.showToast('üë§ Anonymous advanced session started!');
                    }
                    
                } catch (error) {
                    console.error('Anonymous authentication failed:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Failed to create anonymous session');
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signOut = useCallback(() => {
                setUser(null);
                localStorage.removeItem('prayers_user');
                if (networkRef.current) {
                    networkRef.current.showToast('üëã advanced session ended');
                }
            }, []);

            // Enhanced prayer submission with advanced features
            const submitPrayer = useCallback(async () => {
                if (!user || !newPrayer.title.trim() || !newPrayer.content.trim()) {
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Please fill in title and content');
                    }
                    return;
                }

                if (!networkRef.current) {
                    alert('‚ùå advanced network not ready. Please wait.');
                    return;
                }

                setLoading(true);

                try {
                    const advancedPrayer = {
                        id: 'qprayer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8),
                        ...newPrayer,
                        author: user.displayName,
                        authorAddress: user.address || user.anonymousId,
                        authMethod: user.authMethod,
                        timestamp: Date.now(),
                        walletAddress: user.address || newPrayer.walletAddress,
                        tags: newPrayer.tags.split(',').map(tag => tag.trim()).filter(tag => tag),
                        version: '2.0',
                        advancedEnhanced: true
                    };

                    const success = await networkRef.current.storePrayer(advancedPrayer);
                    
                    const message = success ? 
                        '‚úÖ Prayer broadcast to advanced mesh network!' : 
                        'üì± Prayer saved locally - will sync when advanced peers connect';
                        
                    networkRef.current.showToast(message);
                    
                    setNewPrayer({
                        title: '', content: '', location: '', urgency: 'medium',
                        category: 'general', needsAmount: '', walletAddress: user.address || '', tags: ''
                    });
                    setShowCreateForm(false);
                    
                    loadPrayers(networkRef.current);
                    
                } catch (error) {
                    console.error('Failed to submit prayer:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Failed to share prayer. Please try again.');
                    }
                } finally {
                    setLoading(false);
                }
            }, [user, newPrayer, loading]);

            // Enhanced contribution system
            const contributeToPrayer = useCallback(async (prayer) => {
                if (user.authMethod !== 'ethereum' || !user.address) {
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Ethereum wallet required for contributions');
                    }
                    return;
                }

                const amount = prompt('Enter contribution amount in ETH (e.g., 0.01):');
                if (!amount || isNaN(amount) || parseFloat(amount) <= 0) return;

                setLoading(true);
                try {
                    if (typeof window.ethereum !== 'undefined' && typeof Web3 !== 'undefined') {
                        const web3 = new Web3(window.ethereum);
                        
                        // Estimate gas first
                        const gasEstimate = await web3.eth.estimateGas({
                            from: user.address,
                            to: prayer.walletAddress,
                            value: web3.utils.toWei(amount, 'ether')
                        });

                        const tx = await web3.eth.sendTransaction({
                            from: user.address,
                            to: prayer.walletAddress,
                            value: web3.utils.toWei(amount, 'ether'),
                            gas: gasEstimate
                        });
                        
                        if (networkRef.current) {
                            networkRef.current.showToast(`‚úÖ Contribution sent! ${amount} ETH - Tx: ${tx.transactionHash.substring(0, 10)}...`);
                        }
                    }
                } catch (error) {
                    console.error('Transaction failed:', error);
                    if (networkRef.current) {
                        const message = error.code === 4001 ? 'Transaction cancelled by user' : 'Transaction failed. Please try again.';
                        networkRef.current.showToast(`‚ùå ${message}`);
                    }
                } finally {
                    setLoading(false);
                }
            }, [user, loading]);

            // Enhanced debug and performance monitoring
            const toggleDebug = useCallback(() => {
                setShowDebug(prev => !prev);
                if (networkRef.current) {
                    networkRef.current.debugMode = !networkRef.current.debugMode;
                    if (networkRef.current.debugMode) {
                        networkRef.current.debug('üîç advanced debug mode enabled', 'info');
                    }
                }
            }, []);

            const togglePerformance = useCallback(() => {
                setShowPerformance(prev => !prev);
            }, []);

            const forceNetworkUpdate = useCallback(() => {
                if (networkRef.current) {
                    const stats = networkRef.current.getNetworkStats();
                    setNetworkStats(stats);
                    updateNetworkDisplay(stats);
                    networkRef.current.showToast('üîÑ advanced network state refreshed');
                }
            }, []);

            const emergencyNetworkReset = useCallback(() => {
                if (confirm('‚ö†Ô∏è This will reset the advanced network connection. Continue?')) {
                    if (networkRef.current) {
                        networkRef.current.destroy();
                        setIsNetworkReady(false);
                        setInitStatus('üîÑ Restarting advanced network...');
                        
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    }
                }
            }, []);

            // Performance metrics component
            const performanceMetrics = useMemo(() => {
                if (!networkRef.current || !showPerformance) return null;
                
                const history = networkRef.current.getPerformanceHistory();
                const recent = history.slice(-10); // Last 10 measurements
                
                return (
                    <div className="card" style={{ marginTop: '20px' }}>
                        <h3 style={{ marginBottom: '20px', color: '#2c3e50' }}>üìä advanced Network Performance</h3>
                        <div className="feature-grid">
                            <div>
                                <h4>Connection Quality</h4>
                                <div style={{ fontSize: '24px', color: '#4CAF50' }}>
                                    {((networkStats.quality || 0) * 100).toFixed(1)}%
                                </div>
                                <small>Average across all advanced links</small>
                            </div>
                            <div>
                                <h4>Network Uptime</h4>
                                <div style={{ fontSize: '24px', color: '#2196F3' }}>
                                    {Math.floor((networkStats.uptime || 0) / 60000)}m
                                </div>
                                <small>Continuous advanced operation</small>
                            </div>
                            <div>
                                <h4>Routing Efficiency</h4>
                                <div style={{ fontSize: '24px', color: '#ff9800' }}>
                                    O(‚àön log n)
                                </div>
                                <small>advanced P2P algorithm complexity</small>
                            </div>
                            <div>
                                <h4>Data Throughput</h4>
                                <div style={{ fontSize: '24px', color: '#9c27b0' }}>
                                    {prayers.length * 8}KB
                                </div>
                                <small>Humanitarian data processed</small>
                            </div>
                        </div>
                        {recent.length > 0 && (
                            <div style={{ marginTop: '20px' }}>
                                <h4>Recent Performance Samples</h4>
                                <div style={{ fontSize: '12px', fontFamily: 'monospace', background: '#f5f5f5', padding: '10px', borderRadius: '5px', maxHeight: '150px', overflow: 'auto' }}>
                                    {recent.map((sample, i) => (
                                        <div key={i}>
                                            {new Date(sample.timestamp).toLocaleTimeString()}: 
                                            {sample.connections}c {sample.discoveredPeers}p Q{((sample.quality || 0) * 100).toFixed(0)}%
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                );
            }, [networkStats, showPerformance, prayers.length]);

            // Show enhanced initialization screen
            if (!isNetworkReady) {
                return React.createElement('div', { className: 'container' },
                    React.createElement('div', { className: 'hero' },
                        React.createElement('h1', null, 'üåå Prayers, Saints & Saviors'),
                        React.createElement('p', null, 'advanced-Enhanced Global P2P Humanitarian Coordination Network'),
                        React.createElement('div', { 
                            style: { 
                                margin: '40px 0', 
                                fontSize: '1.2em', 
                                background: 'rgba(255,255,255,0.15)', 
                                padding: '30px', 
                                borderRadius: '20px',
                                backdropFilter: 'blur(10px)'
                            } 
                        },
                            React.createElement('div', { className: 'loading', style: { margin: '0 auto 25px' } }),
                            React.createElement('div', { style: { marginBottom: '15px' } }, initStatus),
                            React.createElement('div', { style: { fontSize: '0.9em', opacity: 0.8 } }, 
                                `Connection Quality: ${connectionQuality}`
                            )
                        ),
                        React.createElement('div', { className: 'network-controls' },
                            React.createElement('button', {
                                onClick: forceNetworkUpdate,
                                className: 'btn btn-secondary'
                            }, 'üîÑ Force advanced Sync'),
                            
                            React.createElement('button', {
                                onClick: emergencyNetworkReset,
                                className: 'btn',
                                style: { background: '#ff9800' }
                            }, '‚ö° Emergency Reset'),
                            
                            React.createElement('button', {
                                onClick: () => {
                                    console.log('üîç advanced Debug Info:');
                                    console.log('Network instance:', networkRef.current);
                                    console.log('Network stats:', networkRef.current ? networkRef.current.getNetworkStats() : 'No network');
                                    console.log('Ready state:', isNetworkReady);
                                    console.log('Init status:', initStatus);
                                    console.log('User consent:', userConsent);
                                },
                                className: 'btn',
                                style: { background: '#9c27b0' }
                            }, 'üî¨ Debug Console')
                        )
                    ),
                    React.createElement('div', { className: 'card' },
                        React.createElement('h3', { style: { color: '#2c3e50' } }, 'üåê advanced Network Status'),
                        React.createElement('div', { className: 'feature-grid' },
                            React.createElement('div', null,
                                React.createElement('strong', null, 'Algorithm: '), 'advanced P2P v2.0'
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'advanced Links: '), networkStats.connections
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'Mesh Peers: '), networkStats.discoveredPeers
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'Network State: '), networkStats.isOnline ? 'Online' : 'Initializing'
                            )
                        ),
                        React.createElement('p', { style: { marginTop: '20px', fontSize: '14px', color: '#666' } },
                            'Your browser is becoming part of a advanced advanced-enhanced mesh network that coordinates humanitarian aid globally using advanced advanced P2P algorithms with O(‚àön log n) complexity.'
                        )
                    )
                );
            }

            // Enhanced authentication screen
            if (!user) {
                return React.createElement('div', { className: 'container' },
                    React.createElement('div', { className: 'hero' },
                        React.createElement('h1', null, 'üåå Prayers, Saints & Saviors'),
                        React.createElement('p', null, 
                            'The world\'s first advanced-enhanced P2P humanitarian coordination network using advanced advanced P2P algorithms.'
                        ),
                        React.createElement('p', { style: { fontSize: '1em', opacity: 0.9 } },
                            'Your browser connects directly to a global advanced mesh via WebRTC with O(‚àön log n) routing efficiency.'
                        )
                    ),

                    React.createElement('div', { className: 'stats-bar' },
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.discoveredPeers || 0),
                            React.createElement('span', { className: 'stat-label' }, 'advanced Mesh Peers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.connections || 0),
                            React.createElement('span', { className: 'stat-label' }, 'Direct advanced Links')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, prayers.length),
                            React.createElement('span', { className: 'stat-label' }, 'Network Prayers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, 
                                `Q${((networkStats.quality || 0) * 100).toFixed(0)}%`
                            ),
                            React.createElement('span', { className: 'stat-label' }, 'advanced Quality')
                        )
                    ),

                    React.createElement('div', { className: 'auth-section' },
                        React.createElement('h2', { style: { marginBottom: '35px', color: '#2c3e50' } },
                            'üîê Join the advanced Mesh Network'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithEthereum,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null, 
                            'üîó Connect Ethereum Wallet'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithPasskey,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üîê advanced Biometric Auth'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInAnonymously,
                            className: 'btn btn-auth',
                            disabled: loading,
                            style: { background: 'linear-gradient(135deg, #6c757d 0%, #495057 100%)' }
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üë§ Anonymous advanced Session'
                        ),

                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üåå advanced-Enhanced Features'),
                            React.createElement('ul', { style: { marginLeft: '25px', lineHeight: '1.9' } },
                                React.createElement('li', null, React.createElement('strong', null, 'advanced P2P Routing'), ' - O(‚àön log n) complexity humanitarian coordination'),
                                React.createElement('li', null, React.createElement('strong', null, 'advanced WebRTC'), ' - Direct browser-to-browser advanced channels'),
                                React.createElement('li', null, React.createElement('strong', null, 'Global Mesh Topology'), ' - Self-healing network with advanced resilience'),
                                React.createElement('li', null, React.createElement('strong', null, 'Cross-Subnet Operation'), ' - Universal internet-scale deployment'),
                                React.createElement('li', null, React.createElement('strong', null, 'Zero Infrastructure'), ' - Completely decentralized advanced mesh'),
                                React.createElement('li', null, React.createElement('strong', null, 'Post-advanced Security'), ' - Future-proof cryptographic protection')
                            )
                        )
                    )
                );
            }

            // Enhanced main application interface
            return React.createElement('div', { className: 'container' },
                React.createElement('div', { className: 'hero' },
                    React.createElement('h1', null, 'üåå Prayers, Saints & Saviors'),
                    React.createElement('div', { style: { color: 'rgba(255,255,255,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '20px', flexWrap: 'wrap' } },
                        React.createElement('span', null, 'Welcome, ', React.createElement('strong', null, user.displayName)),
                        React.createElement('div', { style: { display: 'flex', gap: '10px' } },
                            React.createElement('button', {
                                onClick: signOut,
                                style: {
                                    background: 'rgba(255,255,255,0.15)', 
                                    border: '1px solid rgba(255,255,255,0.3)', color: 'white',
                                    padding: '8px 16px', borderRadius: '8px', cursor: 'pointer',
                                    fontSize: '14px', transition: 'all 0.3s'
                                }
                            }, '‚Üó Sign Out'),
                            
                            user.authMethod === 'anonymous' && React.createElement('span', {
                                style: {
                                    background: 'rgba(255, 193, 7, 0.2)', 
                                    border: '1px solid rgba(255, 193, 7, 0.5)', color: 'white',
                                    padding: '8px 16px', borderRadius: '8px',
                                    fontSize: '12px'
                                }
                            }, 'üë§ Anonymous Mode')
                        )
                    ),

                    React.createElement('div', { className: 'network-controls' },
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(true),
                            className: 'btn btn-secondary'
                        }, '‚ú® Share advanced Prayer'),
                        
                        React.createElement('button', {
                            onClick: toggleDebug,
                            className: 'btn',
                            style: { background: showDebug ? '#4CAF50' : '#666' }
                        }, 'üîç advanced Debug'),
                        
                        React.createElement('button', {
                            onClick: togglePerformance,
                            className: 'btn',
                            style: { background: showPerformance ? '#9c27b0' : '#666' }
                        }, 'üìä Performance'),
                        
                        React.createElement('button', {
                            onClick: forceNetworkUpdate,
                            className: 'btn',
                            style: { background: '#ff9800' }
                        }, 'üîÑ Sync Network'),
                        
                        React.createElement('button', {
                            onClick: () => {
                                if (networkRef.current) {
                                    const stats = networkRef.current.getNetworkStats();
                                    const routes = networkRef.current.routingTable.size;
                                    const peersInfo = Array.from(networkRef.current.discoveredPeers.entries())
                                        .map(([id, peer]) => `${id.substr(0, 8)}: dist=${peer.distance?.toFixed(2) || '‚àû'}`);
                                    
                                    alert(`üåå advanced Network Statistics:

Node ID: ${stats.nodeId}
Algorithm: ${stats.algorithm} v${stats.version}
advanced Links: ${stats.connections}
Mesh Peers: ${stats.discoveredPeers}
Routing Table: ${routes} entries
Quality: ${(stats.quality * 100).toFixed(1)}%
Uptime: ${Math.floor(stats.uptime/60000)}m${Math.floor((stats.uptime%60000)/1000)}s
Features: ${stats.features?.join(', ') || 'N/A'}

Peer Routes:
${peersInfo.slice(0, 5).join('\n')}
${peersInfo.length > 5 ? '...' : ''}`);
                                }
                            },
                            className: 'btn',
                            style: { background: '#2196F3' }
                        }, 'üìä advanced Stats')
                    )
                ),

                React.createElement('div', { className: 'stats-bar' },
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.discoveredPeers || 0),
                        React.createElement('span', { className: 'stat-label' }, 'advanced Mesh Peers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.connections || 0),
                        React.createElement('span', { className: 'stat-label' }, 'Direct Links')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, prayers.length),
                        React.createElement('span', { className: 'stat-label' }, 'Active Prayers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, 
                            Math.floor((networkStats.uptime || 0) / 60000) + 'm'
                        ),
                        React.createElement('span', { className: 'stat-label' }, 'advanced Uptime')
                    )
                ),

                showDebug && React.createElement('div', { className: 'p2p-debug', style: { display: 'block' } },
                    React.createElement('div', { style: { color: '#fff', marginBottom: '15px', borderBottom: '1px solid #333', paddingBottom: '8px' } },
                        React.createElement('strong', null, 'üåå Real-Time advanced Debug Console'),
                        React.createElement('span', { style: { float: 'right', fontSize: '11px', opacity: 0.7 } }, 
                            `advanced P2P v${networkStats.version} ‚Ä¢ ${connectionQuality} Quality`
                        )
                    ),
                    React.createElement('div', { id: 'debug-output' })
                ),

                performanceMetrics,

                showCreateForm && React.createElement('div', { className: 'card' },
                    React.createElement('h3', { style: { marginBottom: '30px', color: '#2c3e50' } }, 
                        '‚ú® Share advanced Prayer Request'
                    ),
                    
                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Title'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.title,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, title: e.target.value })),
                                placeholder: 'Brief description of your humanitarian need'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Category'),
                            React.createElement('select', {
                                value: newPrayer.category,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, category: e.target.value }))
                            },
                                React.createElement('option', { value: 'emergency' }, 'üö® Emergency'),
                                React.createElement('option', { value: 'health' }, 'üè• Health/Medical'),
                                React.createElement('option', { value: 'education' }, 'üìö Education'),
                                React.createElement('option', { value: 'housing' }, 'üè† Housing'),
                                React.createElement('option', { value: 'food' }, 'üçΩÔ∏è Food/Nutrition'),
                                React.createElement('option', { value: 'general' }, 'ü§ù General Help'),
                                React.createElement('option', { value: 'mental-health' }, 'üß† Mental Health'),
                                React.createElement('option', { value: 'disaster-relief' }, 'üå™Ô∏è Disaster Relief')
                            )
                        )
                    ),

                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Prayer Details'),
                        React.createElement('textarea', {
                            value: newPrayer.content, rows: 5,
                            onChange: (e) => setNewPrayer(prev => ({ ...prev, content: e.target.value })),
                            placeholder: 'Describe your situation and how others can help. This will be shared across the advanced mesh network...'
                        })
                    ),

                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Location'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.location,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, location: e.target.value })),
                                placeholder: 'City, Country (optional)'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Urgency Level'),
                            React.createElement('select', {
                                value: newPrayer.urgency,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, urgency: e.target.value }))
                            },
                                React.createElement('option', { value: 'low' }, 'üü¢ Low - Can wait'),
                                React.createElement('option', { value: 'medium' }, 'üü° Medium - Within weeks'),
                                React.createElement('option', { value: 'high' }, 'üî¥ High - Urgent need'),
                                React.createElement('option', { value: 'critical' }, 'üö® Critical - Immediate')
                            )
                        )
                    ),

                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Estimated Need (USD, optional)'),
                            React.createElement('input', {
                                type: 'number', value: newPrayer.needsAmount, min: '0',
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, needsAmount: e.target.value })),
                                placeholder: '100'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Tags (comma-separated)'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.tags,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, tags: e.target.value })),
                                placeholder: 'medical, family, urgent'
                            })
                        )
                    ),

                    user.authMethod === 'ethereum' && React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Donation Wallet (auto-filled from your account)'),
                        React.createElement('input', {
                            type: 'text', value: user.address, readOnly: true,
                            style: { background: '#f0f0f0', color: '#666' }
                        })
                    ),

                    user.authMethod === 'anonymous' && React.createElement('div', { 
                        style: { 
                            background: '#fff3cd', padding: '15px', borderRadius: '8px', 
                            border: '1px solid #ffeaa7', margin: '20px 0' 
                        } 
                    },
                        React.createElement('div', { style: { color: '#d68910', fontWeight: '600' } },
                            '‚ö†Ô∏è Anonymous Mode Limitations'
                        ),
                        React.createElement('p', { style: { fontSize: '14px', marginTop: '5px', color: '#666' } },
                            'In anonymous mode, you cannot receive cryptocurrency donations. Consider connecting a wallet for full features.'
                        )
                    ),

                    React.createElement('div', { style: { display: 'flex', gap: '20px', marginTop: '30px' } },
                        React.createElement('button', {
                            onClick: submitPrayer, className: 'btn btn-secondary',
                            disabled: loading, style: { flex: 1 }
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üöÄ Broadcast to advanced Network'
                        ),
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(false), className: 'btn',
                            style: { flex: 1, background: '#666' }
                        }, '‚ùå Cancel')
                    )
                ),

                React.createElement('div', { style: { marginTop: '50px' } },
                    React.createElement('h2', { style: { color: 'white', marginBottom: '30px', textAlign: 'center' } },
                        'üåç Global advanced Prayer Network'
                    ),

                    prayers.length === 0 ? 
                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üå± advanced Network Initializing'),
                            React.createElement('p', null, 
                                'Be among the first to share a prayer request! Your browser is now connected to the ',
                                'advanced-enhanced global P2P humanitarian network. As more nodes join, our advanced P2P ',
                                'algorithms will automatically route requests to the most relevant helpers with O(‚àön log n) ',
                                'complexity, ensuring optimal humanitarian coordination at unprecedented scale.'
                            )
                        ) :
                        prayers.map(prayer => 
                            React.createElement('div', {
                                key: prayer.id,
                                className: `card prayer-card ${prayer.urgency === 'high' || prayer.urgency === 'critical' ? 'prayer-urgent' : ''}`
                            },
                                React.createElement('div', { className: 'prayer-header' },
                                    React.createElement('div', { className: 'prayer-title' }, prayer.title),
                                    React.createElement('div', { className: 'prayer-distance' },
                                        prayer.authorAddress === (user.address || user.anonymousId) ? 
                                            'üîó Your Request' : 
                                            `üåå Via advanced Mesh ‚Ä¢ ${prayer.advancedId ? prayer.advancedId.substr(0, 12) + '...' : 'Global'}`
                                    )
                                ),
                                
                                React.createElement('div', { className: 'prayer-content' }, prayer.content),

                                prayer.tags && prayer.tags.length > 0 && React.createElement('div', {
                                    style: { margin: '15px 0' }
                                },
                                    prayer.tags.map(tag => 
                                        React.createElement('span', {
                                            key: tag,
                                            style: {
                                                background: '#e3f2fd', color: '#1976d2',
                                                padding: '4px 12px', borderRadius: '15px',
                                                fontSize: '12px', marginRight: '8px',
                                                display: 'inline-block', marginBottom: '5px'
                                            }
                                        }, `#${tag}`)
                                    )
                                ),

                                prayer.needsAmount && React.createElement('div', {
                                    style: { 
                                        background: 'linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%)', 
                                        padding: '15px 20px', borderRadius: '12px',
                                        marginBottom: '20px', fontSize: '15px', color: '#ef6c00',
                                        border: '1px solid #ffcc02'
                                    }
                                },
                                    React.createElement('strong', null, 'üí∞ Estimated Need: $' + prayer.needsAmount + ' USD'),
                                    prayer.walletAddress && React.createElement('div', { style: { fontSize: '12px', marginTop: '5px', opacity: 0.8 } },
                                        `Wallet: ${prayer.walletAddress.substring(0, 6)}...${prayer.walletAddress.substring(38)}`
                                    )
                                ),

                                React.createElement('div', { className: 'prayer-footer' },
                                    React.createElement('div', { style: { fontSize: '13px', color: '#666' } },
                                        'üìç ' + (prayer.location || 'Location not specified'),
                                        ' ‚Ä¢ by ' + prayer.author,
                                        ' ‚Ä¢ ' + prayer.category,
                                        prayer.urgency && ` ‚Ä¢ ${prayer.urgency} priority`,
                                        ' ‚Ä¢ ' + new Date(prayer.timestamp).toLocaleDateString(),
                                        prayer.advancedEnhanced && ' ‚Ä¢ ‚öõÔ∏è advanced Enhanced'
                                    ),
                                    
                                    prayer.walletAddress && 
                                    prayer.authorAddress !== (user.address || user.anonymousId) && 
                                    user.authMethod === 'ethereum' && user.address &&
                                        React.createElement('button', {
                                            onClick: () => contributeToPrayer(prayer),
                                            className: 'btn',
                                            disabled: loading,
                                            style: { fontSize: '13px', padding: '10px 20px' }
                                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                                            'üíù advanced Contribute'
                                        )
                                )
                            )
                        )
                ),

                React.createElement('div', { className: 'network-info', style: { marginTop: '50px' } },
                    React.createElement('h4', null, 'üî¨ advanced-Enhanced Network Technology'),
                    React.createElement('p', null,
                        `Your browser is operating as a advanced advanced P2P node with ${networkStats.connections} direct WebRTC `,
                        `connections and ${networkStats.discoveredPeers} discovered peers in the global mesh. Using advanced `,
                        'O(‚àön log n) complexity algorithms, you\'re helping coordinate humanitarian aid with unprecedented ',
                        'efficiency across the global internet. The network operates with zero infrastructure costs while ',
                        'maintaining advanced-enhanced security and complete censorship resistance.'
                    ),
                    React.createElement('div', { style: { marginTop: '20px', fontSize: '14px', opacity: 0.9 } },
                        `Network Quality: ${connectionQuality} (${((networkStats.quality || 0) * 100).toFixed(1)}%) ‚Ä¢ `,
                        `Algorithm: ${networkStats.algorithm} v${networkStats.version} ‚Ä¢ `,
                        `Uptime: ${Math.floor((networkStats.uptime || 0) / 60000)}m`
                    )
                ),

                React.createElement('footer', { style: { textAlign: 'center', padding: '50px 0', color: 'rgba(255,255,255,0.8)' } },
                    React.createElement('p', { style: { fontSize: '16px' } }, 
                        'Built with ‚ù§Ô∏è using advanced-Enhanced Global P2P WebRTC ‚Ä¢ Powered by your browser'
                    ),
                    React.createElement('p', { style: { fontSize: '13px', marginTop: '15px', opacity: 0.7 } },
                        'Decentralized ‚Ä¢ Zero-Infrastructure ‚Ä¢ advanced WebRTC Mesh ‚Ä¢ advanced P2P O(‚àön log n) Efficient ‚Ä¢ Censorship-Resistant ‚Ä¢ Post-advanced Security'
                    ),
                    React.createElement('p', { style: { fontSize: '12px', marginTop: '10px', opacity: 0.6 } },
                        `Network: ${networkStats.algorithm} v${networkStats.version} ‚Ä¢ Node: ${networkStats.nodeId?.substr(0, 16)}... ‚Ä¢ Quality: ${((networkStats.quality || 0) * 100).toFixed(0)}%`
                    )
                )
            );
        }

        // Initialize the enhanced complete application after consent
        window.initializeCompleteApplication = function() {
            ReactDOM.render(React.createElement(EnhancedCompleteApplication), document.getElementById('root'));
        };
    </script>
</body>
</html>
