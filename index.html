<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prayers, Saints & Saviors - Global P2P Humanitarian Network</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <script src="https://unpkg.com/crypto-js@latest/crypto-js.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <!-- Performance & Security Optimizations -->
    <meta name="referrer" content="strict-origin-when-cross-origin">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: http: data: blob: wss: ws:; connect-src 'self' https: http: wss: ws: data: blob: stun: stuns: turn: turns: *.peerjs.com;">
    
    <script>
        // Suppress Babel development warnings
        if (window.Babel) {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && typeof args[0] === 'string' && 
                    args[0].includes('in-browser Babel transformer')) {
                    return;
                }
                originalWarn.apply(console, args);
            };
        }
    </script>
    
    <style>
        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #4CAF50;
            --warning: #ff9800;
            --danger: #f44336;
            --info: #2196F3;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --border-radius: 15px;
            --shadow: 0 8px 25px rgba(0,0,0,0.15);
            --shadow-hover: 0 15px 35px rgba(0,0,0,0.2);
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
        }

        /* Enhanced Animations */
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulseNetwork {
            0%, 100% { background-color: var(--success); }
            50% { background-color: var(--info); }
        }

        @keyframes slideInFromRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Modal Enhancements */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.95); z-index: 10000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
            backdrop-filter: blur(10px) saturate(120%);
            animation: fadeInUp 0.4s ease-out;
        }

        .modal-content {
            background: white; border-radius: 25px; max-width: 650px; width: 100%;
            max-height: 90vh; overflow-y: auto; 
            box-shadow: 0 30px 80px rgba(0,0,0,0.4);
            animation: fadeInUp 0.5s ease-out 0.1s both;
        }

        .modal-header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white; padding: 35px; border-radius: 25px 25px 0 0; text-align: center;
            position: relative; overflow: hidden;
        }

        .modal-header::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="2" fill="rgba(255,255,255,0.1)"/><circle cx="80" cy="30" r="1" fill="rgba(255,255,255,0.1)"/><circle cx="40" cy="70" r="1.5" fill="rgba(255,255,255,0.1)"/></svg>');
            animation: float 6s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .modal-header h2 { font-size: 32px; margin-bottom: 12px; position: relative; z-index: 1; }
        .modal-header p { opacity: 0.9; font-size: 17px; position: relative; z-index: 1; }

        .modal-body { padding: 35px; }

        .risk-section {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 1px solid #ffeaa7; border-radius: 12px;
            padding: 25px; margin: 25px 0; 
            border-left: 5px solid #f39c12;
            position: relative; overflow: hidden;
        }

        .risk-section::before {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 100px; height: 100px;
            background: radial-gradient(circle, rgba(243, 156, 18, 0.1) 0%, transparent 70%);
        }

        .risk-section h4 { 
            color: #d68910; margin-bottom: 15px; display: flex; align-items: center;
            font-size: 18px; position: relative; z-index: 1;
        }
        .risk-section h4::before { content: '‚ö†Ô∏è'; margin-right: 10px; font-size: 20px; }

        .consent-item {
            display: flex; align-items: flex-start; margin: 18px 0; padding: 18px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 12px; border-left: 4px solid var(--info);
            transition: var(--transition); position: relative; overflow: hidden;
        }

        .consent-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .consent-item::before {
            content: '';
            position: absolute;
            top: 0; right: 0;
            width: 50px; height: 50px;
            background: radial-gradient(circle, rgba(33, 150, 243, 0.05) 0%, transparent 70%);
        }

        .consent-item input[type="checkbox"] {
            margin-right: 15px; margin-top: 3px; width: 20px; height: 20px;
            accent-color: var(--info); cursor: pointer;
        }

        .consent-item label { 
            font-size: 15px; line-height: 1.6; cursor: pointer; 
            position: relative; z-index: 1;
        }
        .consent-item label strong { color: var(--dark); }

        .modal-actions {
            display: flex; gap: 18px; margin-top: 35px; padding: 25px;
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            border-radius: 0 0 25px 25px;
        }

        .modal-btn {
            flex: 1; padding: 18px 30px; border: none; border-radius: 12px;
            font-size: 16px; font-weight: 600; cursor: pointer; 
            transition: var(--transition);
            text-transform: uppercase; letter-spacing: 0.8px;
            position: relative; overflow: hidden;
        }

        .modal-btn::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transition: all 0.5s ease;
            transform: translate(-50%, -50%);
        }

        .modal-btn:hover::before {
            width: 300px; height: 300px;
        }

        .modal-btn-decline {
            background: linear-gradient(135deg, var(--danger) 0%, #c82333 100%);
            color: white;
        }

        .modal-btn-decline:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 8px 25px rgba(220, 53, 69, 0.4);
        }

        .modal-btn-accept {
            background: linear-gradient(135deg, var(--success) 0%, #218838 100%);
            color: white;
        }

        .modal-btn-accept:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 8px 25px rgba(40, 167, 69, 0.4);
        }

        .modal-btn-accept:disabled {
            background: #6c757d; cursor: not-allowed; transform: none;
            opacity: 0.6;
        }

        .modal-btn-accept:disabled::before { display: none; }

        /* Enhanced Network Status */
        .network-status {
            position: fixed; top: 15px; right: 15px; 
            background: linear-gradient(135deg, rgba(0,0,0,0.9) 0%, rgba(44,62,80,0.95) 100%);
            backdrop-filter: blur(15px) saturate(120%);
            color: white; padding: 20px; border-radius: 15px; 
            font-size: 12px; font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            z-index: 1000; border: 1px solid var(--success); min-width: 280px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            animation: slideInFromRight 0.5s ease-out;
        }

        .network-status .peer-list {
            margin-top: 15px; max-height: 180px; overflow-y: auto;
            scrollbar-width: thin; scrollbar-color: var(--success) transparent;
        }

        .network-status .peer-list::-webkit-scrollbar {
            width: 4px;
        }

        .network-status .peer-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .network-status .peer-list::-webkit-scrollbar-thumb {
            background: var(--success);
            border-radius: 2px;
        }

        .peer-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 5px 0; border-bottom: 1px solid rgba(255,255,255,0.1);
            transition: var(--transition);
        }

        .peer-item:hover {
            background: rgba(255,255,255,0.05);
            border-radius: 5px;
            padding-left: 5px; padding-right: 5px;
        }

        .peer-item.peer-empty {
            justify-content: flex-start;
            color: rgba(255,255,255,0.7);
            font-style: italic;
            border-bottom: none;
        }

        .connection-status {
            display: inline-block; width: 10px; height: 10px; 
            border-radius: 50%; margin-left: 10px;
            box-shadow: 0 0 0 2px rgba(255,255,255,0.1);
        }

        .connection-status.connected { 
            background: var(--success); 
            animation: pulseNetwork 3s infinite;
            box-shadow: 0 0 10px var(--success);
        }

        .connection-status.connecting { 
            background: var(--warning); 
            animation: pulse 1.5s infinite;
        }

        .connection-status.disconnected { 
            background: var(--danger);
            opacity: 0.6;
        }

        @keyframes pulse { 
            0%, 100% { opacity: 1; transform: scale(1); } 
            50% { opacity: 0.7; transform: scale(1.1); } 
        }

        /* Main Content Enhancements */
        .main-content { display: none; }
        .main-content.show { 
            display: block; 
            animation: fadeInUp 0.6s ease-out;
        }

        .container { 
            max-width: 1400px; margin: 0 auto; padding: 25px; 
        }

        .card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: var(--border-radius); padding: 30px; margin: 25px 0;
            box-shadow: var(--shadow); transition: var(--transition);
            position: relative; overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: linear-gradient(45deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-hover);
        }

        .card:hover::before {
            transform: translateX(100%);
        }

        .prayer-card {
            border-left: 5px solid var(--success); 
            position: relative; overflow: hidden;
        }

        .prayer-urgent { 
            border-left-color: var(--danger); 
            animation: pulseUrgent 4s infinite;
        }

        @keyframes pulseUrgent {
            0%, 100% { 
                box-shadow: var(--shadow);
            }
            50% { 
                box-shadow: 0 8px 25px rgba(244, 67, 54, 0.3);
            }
        }

        .prayer-header { 
            display: flex; justify-content: space-between; align-items: center; 
            margin-bottom: 20px; flex-wrap: wrap; gap: 10px;
        }

        .prayer-title { 
            font-weight: 700; font-size: 20px; color: var(--dark);
            background: linear-gradient(135deg, var(--dark) 0%, var(--primary) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .prayer-distance {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
            color: #1976d2; padding: 8px 16px; border-radius: 25px; 
            font-size: 12px; font-weight: 600;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.2);
        }

        .prayer-content { 
            color: #555; line-height: 1.7; margin-bottom: 25px; 
            font-size: 16px;
        }

        .prayer-footer {
            display: flex; justify-content: space-between; align-items: center;
            padding-top: 20px; border-top: 2px solid #eee;
            flex-wrap: wrap; gap: 15px;
        }

        /* Enhanced Button System */
        .btn {
            background: linear-gradient(135deg, var(--success) 0%, #45a049 100%); 
            color: white; border: none; padding: 14px 28px; 
            border-radius: 25px; cursor: pointer;
            font-weight: 600; font-size: 15px; 
            transition: var(--transition); text-decoration: none;
            display: inline-flex; align-items: center; justify-content: center;
            position: relative; overflow: hidden; gap: 8px;
            text-transform: uppercase; letter-spacing: 0.5px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(76, 175, 80, 0.4);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:disabled { 
            opacity: 0.6; cursor: not-allowed; 
            transform: none; box-shadow: none;
        }

        .btn:disabled::before { display: none; }

        .btn-secondary {
            background: linear-gradient(135deg, var(--info) 0%, #1976D2 100%);
        }

        .btn-secondary:hover {
            box-shadow: 0 8px 25px rgba(33, 150, 243, 0.4);
        }

        .btn-auth {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            font-size: 17px; padding: 18px 35px; margin: 12px;
            border-radius: 30px;
        }

        .btn-auth:hover {
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        /* Enhanced Forms */
        .auth-section {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            padding: 50px; border-radius: 25px; text-align: center;
            box-shadow: var(--shadow-hover); max-width: 600px; margin: 60px auto;
            position: relative; overflow: hidden;
        }

        .auth-section::before {
            content: '';
            position: absolute;
            top: -50%; left: -50%;
            width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(102, 126, 234, 0.05) 0%, transparent 70%);
            animation: float 8s ease-in-out infinite;
        }

        .form-group { 
            margin-bottom: 25px; text-align: left; 
            position: relative;
        }

        .form-group label { 
            display: block; margin-bottom: 10px; font-weight: 600; 
            color: var(--dark); font-size: 15px;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%; padding: 18px 20px; border: 2px solid #e0e0e0; 
            border-radius: 12px; font-size: 15px; 
            transition: var(--transition); background: #f9f9f9;
            font-family: inherit;
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none; border-color: var(--primary); 
            background: white; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        /* Enhanced Info Sections */
        .network-info {
            background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%); 
            backdrop-filter: blur(15px) saturate(120%);
            border: 1px solid rgba(255,255,255,0.3); border-radius: 20px;
            padding: 30px; margin: 35px 0; color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .feature-grid { 
            display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); 
            gap: 25px; margin: 35px 0; 
        }

        /* Enhanced Stats */
        .stats-bar {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px; background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%);
            border-radius: 20px; padding: 25px; margin: 35px 0; 
            backdrop-filter: blur(15px) saturate(120%);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .stat { 
            text-align: center; color: white; 
            padding: 20px; border-radius: 15px;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            transition: var(--transition);
        }

        .stat:hover {
            transform: translateY(-5px);
            background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0.1) 100%);
        }

        .stat-value { 
            font-size: 2.5em; font-weight: 700; display: block; 
            background: linear-gradient(135deg, #ffffff 0%, #ecf0f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .stat-label { font-size: 1em; opacity: 0.9; margin-top: 8px; }

        /* Enhanced Hero */
        .hero { 
            text-align: center; padding: 80px 0 60px; color: white; 
            position: relative; z-index: 1;
        }

        .hero h1 { 
            font-size: 4em; margin-bottom: 25px; font-weight: 800; 
            text-shadow: 0 4px 20px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #ffffff 0%, #ecf0f1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p { 
            font-size: 1.4em; opacity: 0.95; max-width: 900px; 
            margin: 0 auto 50px; line-height: 1.6;
        }

        /* Enhanced Debug Console */
        .p2p-debug {
            background: linear-gradient(135deg, rgba(0,0,0,0.9) 0%, rgba(44,62,80,0.95) 100%);
            backdrop-filter: blur(10px);
            color: #0f0; font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace; 
            font-size: 12px; padding: 20px; border-radius: 15px; 
            margin: 25px 0; max-height: 300px; overflow-y: auto;
            border: 1px solid #333; display: none;
            box-shadow: var(--shadow);
        }

        .debug-line { margin: 3px 0; padding: 2px 5px; border-radius: 3px; }
        .debug-error { color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }
        .debug-success { color: #51cf66; background: rgba(81, 207, 102, 0.1); }
        .debug-info { color: #74c0fc; background: rgba(116, 192, 252, 0.1); }

        /* Enhanced Toast System */
        .toast {
            position: fixed; bottom: 25px; right: 25px; 
            background: linear-gradient(135deg, var(--success) 0%, #45a049 100%);
            color: white; padding: 18px 30px; border-radius: 12px; 
            z-index: 1001; transform: translateX(400px);
            transition: var(--transition); 
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.4);
            backdrop-filter: blur(10px);
            font-weight: 600;
        }

        .toast.show { transform: translateX(0); }

        /* Enhanced Network Controls */
        .network-controls {
            display: flex; gap: 15px; margin: 25px 0; flex-wrap: wrap;
            justify-content: center;
        }

        .network-controls .btn {
            padding: 12px 20px; font-size: 13px; margin: 0;
            border-radius: 20px;
        }

        /* Loading Animation Enhancement */
        .loading { 
            display: inline-block; width: 20px; height: 20px; 
            border: 2px solid rgba(255,255,255,0.3); 
            border-top: 2px solid #ffffff; 
            border-radius: 50%; 
            animation: spin 1s linear infinite; 
            margin-right: 8px;
        }

        @keyframes spin { 
            0% { transform: rotate(0deg); } 
            100% { transform: rotate(360deg); } 
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container { padding: 15px; }
            .hero h1 { font-size: 2.5em; }
            .hero p { font-size: 1.1em; }
            .card { padding: 20px; margin: 15px 0; }
            .stats-bar { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            .prayer-header { flex-direction: column; align-items: flex-start; }
            .prayer-footer { flex-direction: column; align-items: flex-start; }
            .network-status { 
                position: relative; top: 0; right: 0; 
                margin: 20px 0; width: 100%; min-width: auto;
            }
            .modal-content { margin: 10px; max-width: calc(100vw - 20px); }
            .modal-actions { flex-direction: column; }
            .auth-section { padding: 30px 20px; margin: 30px auto; }
        }

        /* Dark Mode Support */
        @media (prefers-color-scheme: dark) {
            .card {
                background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
                color: #ecf0f1;
            }
            
            .prayer-content { color: #bdc3c7; }
            .form-group input, .form-group textarea, .form-group select {
                background: #34495e; color: #ecf0f1; border-color: #4a6741;
            }
        }
    </style>
</head>
<body>
    <!-- Enhanced Consent Modal -->
    <div id="consent-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üåç Welcome to the Future of Humanitarian Aid</h2>
                <p>Join the world's first truly decentralized humanitarian coordination network</p>
            </div>
            
            <div class="modal-body">
                <p style="margin-bottom: 25px; line-height: 1.7; font-size: 16px;">
                    You're about to become part of a advanced global infrastructure that uses cutting-edge 
                    P2P algorithms and WebRTC mesh networking to coordinate humanitarian aid with 
                    unprecedented efficiency. Please understand what you're agreeing to.
                </p>

                <div class="risk-section">
                    <h4>‚öóÔ∏è Technology Disclaimers</h4>
                    <ul style="margin-left: 25px; line-height: 1.7;">
                        <li><strong>Experimental Technology:</strong> Uses modern P2P routing with advanced mathematical frameworks</li>
                        <li><strong>Global P2P Mesh:</strong> Your browser becomes a routing node in a worldwide humanitarian coordination network</li>
                        <li><strong>Network Security:</strong> Implements modern cryptographic principles for secure communications</li>
                        <li><strong>Cross-Network Operation:</strong> Advanced NAT traversal and distributed consensus mechanisms</li>
                        <li><strong>Resource Commitment:</strong> Your device will contribute computing power to global humanitarian coordination</li>
                        <li><strong>Cryptocurrency Integration:</strong> Direct blockchain transactions with irreversible consequences</li>
                    </ul>
                </div>

                <div style="margin: 25px 0; padding: 25px; background: linear-gradient(135deg, #e8f5e8 0%, #f0f8f0 100%); border-radius: 15px; border: 1px solid var(--success);">
                    <h4 style="color: var(--success); margin-bottom: 15px; display: flex; align-items: center;">
                        üöÄ Advanced Technology Stack
                    </h4>
                    <p style="margin-bottom: 15px; line-height: 1.6;">
                        Your browser will execute: <strong>optimized mesh routing</strong>, WebRTC data channels,
                        Service Workers with IndexedDB persistence, STUN/TURN NAT traversal, distributed hash tables,
                        modern cryptographic signatures, and real-time humanitarian optimization algorithms.
                    </p>
                    <div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; font-size: 14px; color: #2e7d32;">
                        <strong>Impact:</strong> You'll be part of the first distributed system capable of coordinating 
                        global humanitarian aid in real-time without centralized infrastructure, using advanced 
                        mathematical frameworks that optimize coordination efficiency.
                    </div>
                </div>

                <div style="margin: 25px 0; padding: 25px; background: #f0f8ff; border-radius: 12px; border: 1px solid var(--info);">
                    <h4 style="color: var(--info); margin-bottom: 15px;">üìã Complete Terms & Privacy Policy</h4>
                    <p style="margin-bottom: 15px; line-height: 1.6;">
                        By proceeding, you agree to our comprehensive legal framework:
                    </p>
                    <a href="./terms-of-service.html" target="_blank" rel="noopener" style="color: var(--info); text-decoration: none; font-weight: 700; display: inline-flex; align-items: center; gap: 8px;">
                        üìã Complete Terms of Service & Privacy Policy
                        <span style="font-size: 12px;">‚Üó</span>
                    </a>
                    <p style="margin-top: 15px; font-size: 14px; color: #666; font-style: italic;">
                        <strong>Recommended:</strong> Review complete terms before participating in this experimental network.
                    </p>
                </div>

                <h4 style="margin: 30px 0 20px 0; color: var(--dark); font-size: 20px;">‚úÖ Required Consents</h4>
                
                <div class="consent-item">
                    <input type="checkbox" id="consent-tos" />
                    <label for="consent-tos">
                        <strong>Legal Agreement:</strong> I have read, understand, and agree to the complete 
                        Terms of Service and acknowledge this experimental technology carries inherent risks.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-p2p" />
                    <label for="consent-p2p">
                        <strong>Global P2P Infrastructure:</strong> I consent to my browser joining a worldwide 
                        mesh network and establishing direct WebRTC connections with users globally.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-algorithms" />
                    <label for="consent-algorithms">
                        <strong>Advanced Algorithms:</strong> I consent to my browser executing optimized routing 
                        algorithms and contributing to distributed humanitarian optimization calculations.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-resources" />
                    <label for="consent-resources">
                        <strong>Resource Contribution:</strong> I consent to my device using CPU, memory, and 
                        network resources for global humanitarian coordination infrastructure.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-crypto" />
                    <label for="consent-crypto">
                        <strong>Cryptocurrency Operations:</strong> I understand blockchain transactions are 
                        irreversible and I'm solely responsible for wallet security and transaction validation.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-data" />
                    <label for="consent-data">
                        <strong>Data & Privacy:</strong> I understand humanitarian requests are distributed 
                        globally and I won't include sensitive personal information in public communications.
                    </label>
                </div>

                <div style="margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #e8f5e8 0%, #f0f8f0 100%); border-radius: 12px; border: 1px solid var(--success);">
                    <p style="font-size: 15px; line-height: 1.6; color: #2e7d32;">
                        <strong>üåü By joining:</strong> You become a pioneer in the first truly decentralized 
                        humanitarian network. Your browser helps coordinate global aid using advanced P2P 
                        algorithms while maintaining complete privacy and censorship resistance. Together, we're 
                        building the future of compassionate technology.
                    </p>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn modal-btn-decline" onclick="declineTerms()">
                    ‚ùå Decline & Exit
                </button>
                <button class="modal-btn modal-btn-accept" id="accept-btn" onclick="acceptTerms()" disabled>
                    ‚úÖ Accept & Join Global Network
                </button>
            </div>
        </div>
    </div>

    <!-- Main Application Content -->
    <div id="root" class="main-content">
        <!-- Enhanced Network Status -->
        <div class="network-status">
            <div id="network-title">üåê Global P2P Network</div>
            <div id="network-stats">Initializing mesh with Service Worker...</div>
            <div id="peer-list" class="peer-list"></div>
        </div>
    </div>

    <!-- Enhanced Consent Logic -->
    <script>
        let userConsent = false;
        
        function checkExistingConsent() {
            try {
                const consent = localStorage.getItem('pss_user_consent');
                if (consent) {
                    const consentData = JSON.parse(consent);
                    const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
                    
                    if (Date.now() - consentData.timestamp < thirtyDaysMs && consentData.version === '2.1') {
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error checking existing consent:', error);
            }
            return false;
        }
        
        function updateAcceptButton() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-algorithms', 
                'consent-resources', 'consent-crypto', 'consent-data'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id)?.checked
            );
            
            const acceptBtn = document.getElementById('accept-btn');
            if (acceptBtn) {
                acceptBtn.disabled = !allChecked;
                
                if (allChecked) {
                    acceptBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #218838 100%)';
                    acceptBtn.style.cursor = 'pointer';
                } else {
                    acceptBtn.style.background = '#6c757d';
                    acceptBtn.style.cursor = 'not-allowed';
                }
            }
        }
        
        function acceptTerms() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-algorithms', 
                'consent-resources', 'consent-crypto', 'consent-data'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id)?.checked
            );
            
            if (!allChecked) {
                alert('Please check all required consent boxes before proceeding.');
                return;
            }
            
            const consentData = {
                timestamp: Date.now(),
                version: '2.1',
                userAgent: navigator.userAgent,
                consents: {
                    tos: true, p2p: true, algorithms: true,
                    resources: true, crypto: true, data: true
                },
                networkFeatures: {
                    ftdfrp: true,
                    webrtc: true,
                    serviceWorker: true,
                    broadcastChannel: true,
                    advanced: true,
                    mesh: true
                }
            };
            
            try {
                localStorage.setItem('pss_user_consent', JSON.stringify(consentData));
                userConsent = true;
                
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                
                // Wait for React and Babel to be ready before initializing
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max
                
                function waitForReact() {
                    attempts++;
                    
                    if (window.React && window.ReactDOM && 
                        typeof window.initializeCompleteApplication === 'function' &&
                        window.initializeCompleteApplication.toString().includes('EnhancedCompleteApplication')) {
                        console.log('üöÄ React ready - initializing enhanced network...');
                        window.initializeCompleteApplication();
                    } else if (attempts < maxAttempts) {
                        console.log(`‚è≥ Waiting for React components... (${attempts}/${maxAttempts})`);
                        setTimeout(waitForReact, 100);
                    } else {
                        console.error('‚ùå React failed to load within 5 seconds');
                        alert('Failed to load application components. Please refresh the page.');
                    }
                }
                
                waitForReact();
                
            } catch (error) {
                console.error('Failed to store consent:', error);
                alert('Failed to store consent. Please try again.');
            }
        }
        
        function declineTerms() {
            if (confirm('Are you sure you want to decline? You will be redirected to alternative humanitarian resources.')) {
                try {
                    // Clear all data
                    localStorage.clear();
                } catch (error) {
                    console.error('Error clearing data:', error);
                }
                
                window.location.href = 'https://reliefweb.int/';
            }
        }
        
        function requireConsent() {
            if (!userConsent) {
                throw new Error('User consent required before network operations');
            }
        }

        // Global initialization function - will be set by React app
        window.initializeCompleteApplication = function() {
            console.log('React app not yet loaded');
        };

        document.addEventListener('DOMContentLoaded', function() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-algorithms', 
                'consent-resources', 'consent-crypto', 'consent-data'
            ];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', updateAcceptButton);
                }
            });
            
            if (checkExistingConsent()) {
                userConsent = true;
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                initializeCompleteApplication();
            } else {
                updateAcceptButton();
            }
        });
    </script>

    <!-- Enhanced P2P Network with Service Worker Support -->
    <script type="text/babel">
        // Enhanced P2P Network with Service Worker and Local Discovery
        class AdvancedP2PNetwork {
            constructor() {
                requireConsent();
                
                this.nodeId = 'node_' + this.generateAdvancedId();
                this.peer = null;
                this.connections = new Map();
                this.discoveredPeers = new Map();
                this.prayers = new Map();
                this.routingTable = new Map();
                this.vector = this.generateRoutingVector();
                this.startTime = Date.now();
                this.isOnline = false;
                this.debugMode = false;
                this.eventListeners = new Map();
                this.heartbeatInterval = null;
                this.discoveryInterval = null;
                this.performanceMetrics = new Map();
                this.broadcastChannel = null;
                this.serviceWorkerReady = false;
                
                // Enhanced STUN/TURN servers for global reach and NAT traversal
                this.stunServers = [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun.ekiga.net' },
                    { urls: 'stun:stun.ideasip.com' },
                    { urls: 'stun:stun.schlund.de' },
                    { urls: 'stun:stun.rixtelecom.se' },
                    { urls: 'stun:stun.iptel.org' },
                    // Add a free TURN server for better NAT traversal
                    { 
                        urls: 'turn:openrelay.metered.ca:80',
                        username: 'openrelayproject',
                        credential: 'openrelayproject'
                    }
                ];
                
                this.networkConfig = {
                    maxConnections: 8,
                    heartbeatInterval: 25000,
                    discoveryInterval: 8000, // More frequent discovery
                    cleanupInterval: 60000,
                    connectionTimeout: 15000,
                    retryAttempts: 3
                };

                this.userConfig = this.loadUserConfig();

                console.log('üåå Enhanced P2P Network initialized with Service Worker support');
            }

            loadUserConfig() {
                try {
                    const stored = localStorage.getItem('pss_user_config');
                    if (stored) {
                        return this.sanitizeUserConfig(JSON.parse(stored));
                    }
                } catch (error) {
                    console.warn('Failed to load user bootstrap config:', error);
                }
                return { nodeIp: '', neighborIp: '' };
            }

            sanitizeUserConfig(config) {
                if (!config || typeof config !== 'object') {
                    return { nodeIp: '', neighborIp: '' };
                }

                const sanitizeValue = (value) =>
                    typeof value === 'string' ? value.trim() : '';

                return {
                    nodeIp: sanitizeValue(config.nodeIp),
                    neighborIp: sanitizeValue(config.neighborIp)
                };
            }

            persistUserConfig(config) {
                try {
                    const hasValues = config.nodeIp || config.neighborIp;
                    if (hasValues) {
                        localStorage.setItem('pss_user_config', JSON.stringify(config));
                    } else {
                        localStorage.removeItem('pss_user_config');
                    }
                } catch (error) {
                    console.warn('Failed to persist user bootstrap config:', error);
                }
            }

            generateUserEndpoints(address, defaultPaths = []) {
                if (!address) return [];

                const trimmed = address.trim();
                if (!trimmed) return [];

                const cleanBase = trimmed.replace(/\/+$/, '');
                const bases = cleanBase.includes('://')
                    ? [cleanBase]
                    : [`http://${cleanBase}`, `https://${cleanBase}`];

                const endpoints = [];
                let hasExplicitPath = false;

                try {
                    const urlForCheck = cleanBase.includes('://') ? cleanBase : `http://${cleanBase}`;
                    const parsed = new URL(urlForCheck);
                    hasExplicitPath = parsed.pathname && parsed.pathname !== '/';
                } catch (error) {
                    hasExplicitPath = cleanBase.includes('/') && !cleanBase.endsWith('/');
                }

                for (const base of bases) {
                    const sanitizedBase = base.replace(/\/+$/, '');

                    if (hasExplicitPath || !defaultPaths || defaultPaths.length === 0) {
                        endpoints.push(sanitizedBase);
                    } else {
                        defaultPaths.forEach(path => {
                            endpoints.push(`${sanitizedBase}${path}`);
                        });
                    }
                }

                return endpoints;
            }

            async updateUserConfig(config) {
                const previous = this.userConfig || { nodeIp: '', neighborIp: '' };
                const sanitized = this.sanitizeUserConfig(config);
                const changed = sanitized.nodeIp !== previous.nodeIp ||
                    sanitized.neighborIp !== previous.neighborIp;

                this.userConfig = sanitized;
                this.persistUserConfig(sanitized);

                if (!changed) {
                    return sanitized;
                }

                if (sanitized.nodeIp || sanitized.neighborIp) {
                    this.debug('üåê Custom bootstrap hints applied', 'info');
                    this.showToast('üåê Custom bootstrap hints applied');
                } else {
                    this.debug('üåê Cleared custom bootstrap hints', 'info');
                    this.showToast('üåê Cleared bootstrap hints');
                }

                try {
                    this.announceToNetwork().catch(error => {
                        console.warn('Bootstrap re-announcement failed:', error);
                    });
                    this.searchGlobalNode().catch(error => {
                        console.warn('Bootstrap discovery failed:', error);
                    });
                } catch (error) {
                    console.warn('Failed to trigger bootstrap refresh:', error);
                }

                return sanitized;
            }

            sanitizeEndpoints(endpoints) {
                const filtered = [];
                const seen = new Set();

                for (const endpoint of endpoints) {
                    if (!endpoint || typeof endpoint !== 'string') continue;
                    const trimmed = endpoint.trim();
                    if (!trimmed) continue;

                    if (window.location.protocol === 'https:' && trimmed.startsWith('http://')) {
                        continue;
                    }

                    if (!seen.has(trimmed)) {
                        filtered.push(trimmed);
                        seen.add(trimmed);
                    }
                }

                return filtered;
            }

            getGlobalAnnouncementEndpoints() {
                const defaultEndpoints = [
                    `http://185.187.243.129:3000/api/announce`,
                    `https://185.187.243.129:3001/api/announce`,
                    `http://185.187.243.129:8080/peers/announce`,
                    'https://httpbin.org/post',
                    'https://postman-echo.com/post'
                ];

                const userEndpoints = [
                    ...this.generateUserEndpoints(this.userConfig.nodeIp, ['/api/announce', '/peers/announce']),
                    ...this.generateUserEndpoints(this.userConfig.neighborIp, ['/api/announce', '/peers/announce'])
                ];

                return this.sanitizeEndpoints([...defaultEndpoints, ...userEndpoints]);
            }

            getGlobalPeerEndpoints() {
                const defaultEndpoints = [
                    `http://185.187.243.129:3000/api/peers`,
                    `https://185.187.243.129:3001/api/peers`,
                    `http://185.187.243.129:8080/peers/list`
                ];

                const userEndpoints = [
                    ...this.generateUserEndpoints(this.userConfig.nodeIp, ['/api/peers', '/peers/list']),
                    ...this.generateUserEndpoints(this.userConfig.neighborIp, ['/api/peers', '/peers/list'])
                ];

                return this.sanitizeEndpoints([...defaultEndpoints, ...userEndpoints]);
            }

            generateAdvancedId() {
                // Generate secure ID
                const timestamp = Date.now().toString(36);
                const random = Array.from(crypto.getRandomValues(new Uint32Array(4)))
                    .map(x => x.toString(36)).join('');
                const checksum = this.secureHash(timestamp + random).slice(0, 8);
                return `${timestamp}_${random}_${checksum}`;
            }

            generateRoutingVector() {
                // Enhanced vector with optimized properties
                const dimension = 16;
                const vector = new Array(dimension);
                const entropy = crypto.getRandomValues(new Uint32Array(dimension));
                
                for (let i = 0; i < dimension; i++) {
                    vector[i] = (entropy[i] / 0xFFFFFFFF) * 2 - 1;
                }
                
                return this.normalizeVector(vector);
            }

            normalizeVector(vector) {
                const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
                return magnitude > 0 ? vector.map(val => val / magnitude) : vector;
            }

            secureHash(input) {
                // Simplified secure hash
                let hash = 0;
                const prime = 31;
                
                for (let i = 0; i < input.length; i++) {
                    hash = (hash * prime + input.charCodeAt(i)) & 0xFFFFFFFF;
                }
                
                return Math.abs(hash).toString(36);
            }

            async initialize() {
                try {
                    this.debug('üöÄ Initializing Enhanced P2P Network with Service Worker...', 'info');
                    
                    // Initialize Service Worker first
                    await this.registerServiceWorker();
                    
                    this.peer = new Peer(this.nodeId, {
                        config: {
                            iceServers: this.stunServers
                        },
                        debug: this.debugMode ? 2 : 0
                    });
                    
                    this.setupPeerEvents();
                    this.startPeerDiscovery();
                    this.startHeartbeat();
                    this.startPerformanceMonitoring();
                    
                    this.isOnline = true;
                    this.emit('networkReady', { 
                        nodeId: this.nodeId, 
                        algorithm: 'Enhanced-P2P',
                        features: ['service-worker', 'broadcast-channel', 'mesh-topology', 'global-routing']
                    });
                    
                } catch (error) {
                    this.debug('‚ùå Network initialization failed: ' + error.message, 'error');
                    console.error('Network initialization failed:', error);
                    setTimeout(() => this.initialize(), 5000); // Retry
                }
            }

            async registerServiceWorker() {
                console.log('üî• SERVICE WORKER REGISTRATION: Starting...');
                try {
                    if ('serviceWorker' in navigator) {
                        console.log('üî• SERVICE WORKER: ServiceWorker API available');
                        
                        // Register the actual sw.js file
                        console.log('üî• SERVICE WORKER: Registering ./sw.js...');
                        const registration = await navigator.serviceWorker.register('./sw.js', {
                            scope: './'
                        });
                        
                        console.log('üî• SERVICE WORKER: Registration successful, waiting for ready...');
                        await navigator.serviceWorker.ready;
                        console.log('üî• SERVICE WORKER: Ready signal received');
                        
                        this.debug('üîß Enhanced Service Worker registered from ./sw.js', 'success');
                        
                        // Enhanced message handling from service worker
                        navigator.serviceWorker.addEventListener('message', (event) => {
                            console.log('üî• SERVICE WORKER MESSAGE:', event.data);
                            this.debug(`üîß SW message received: ${event.data.type}`, 'info');
                            if (event.data.type === 'peer_discovered') {
                                this.handleServiceWorkerPeerDiscovery(event.data.data);
                            } else if (event.data.type === 'prayer_received') {
                                this.handlePrayerReceived(event.data.data);
                            }
                        });
                        
                        // Wait for Service Worker to be ready and controlled
                        let swReadyAttempts = 0;
                        const waitForSWController = async () => {
                            while (swReadyAttempts < 20 && !navigator.serviceWorker.controller) {
                                await new Promise(resolve => setTimeout(resolve, 250));
                                swReadyAttempts++;
                                console.log(`üî• SERVICE WORKER: Waiting for controller... (${swReadyAttempts}/20)`);
                                this.debug(`‚è≥ Waiting for SW controller... (${swReadyAttempts}/20)`, 'info');
                            }
                            
                            if (navigator.serviceWorker.controller) {
                                console.log('üî• SERVICE WORKER: Controller ready - registering node');
                                this.debug('üîß SW controller ready - registering node', 'success');
                                
                                // Register this node with service worker
                                navigator.serviceWorker.controller.postMessage({
                                    type: 'register_peer',
                                    data: {
                                        nodeId: this.nodeId,
                                        timestamp: Date.now(),
                                        features: ['enhanced-p2p', 'webrtc', 'indexeddb'],
                                        version: '2.1',
                                        bootstrapHints: this.userConfig
                                    }
                                });
                                
                                this.serviceWorkerReady = true;
                                console.log('üî• SERVICE WORKER: Registration complete and ready');
                            } else {
                                console.log('‚ùå SERVICE WORKER: Controller not available after 5 seconds');
                                this.debug('‚ùå SW controller not available after 5 seconds', 'error');
                                this.serviceWorkerReady = false;
                            }
                        };
                        
                        // Start waiting for controller in background
                        waitForSWController();
                        
                        return true;
                    } else {
                        console.log('‚ùå SERVICE WORKER: Not supported in this browser');
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå SERVICE WORKER REGISTRATION FAILED:', error);
                    this.debug('‚ùå Enhanced ServiceWorker registration failed: ' + error.message, 'error');
                    
                    // If external sw.js fails, we could fall back to inline, but let's see the error first
                    console.log('üî• SERVICE WORKER: External sw.js failed, check if file exists in same directory');
                }
                return false;
            }

            handleServiceWorkerPeerDiscovery(peerAnnouncement) {
                if (peerAnnouncement.nodeId !== this.nodeId && 
                    !this.connections.has(peerAnnouncement.nodeId) &&
                    this.connections.size < this.networkConfig.maxConnections) {
                    
                    this.debug(`üëÄ SW discovered peer: ${peerAnnouncement.nodeId.substr(0, 12)}...`, 'info');
                    setTimeout(() => {
                        this.connectToPeer(peerAnnouncement.nodeId);
                    }, Math.random() * 2000); // Random delay to prevent thundering herd
                }
            }
            
            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    this.debug(`üÜî Enhanced Node Online: ${id}`, 'success');
                    this.nodeId = id;
                    this.announceToNetwork();
                    this.updateRoutingTable();
                });
                
                this.peer.on('connection', (conn) => {
                    this.debug(`üìû Incoming connection: ${conn.peer}`, 'info');
                    this.handleNewConnection(conn);
                });
                
                this.peer.on('error', (error) => {
                    this.debug(`‚ùå Peer error: ${error.type} - ${error.message}`, 'error');
                    this.handlePeerError(error);
                });

                this.peer.on('disconnected', () => {
                    this.debug('üîÑ Peer disconnected, attempting reconnection...', 'info');
                    setTimeout(() => {
                        if (!this.peer.destroyed) {
                            this.peer.reconnect();
                        }
                    }, 3000);
                });
            }


            handlePeerError(error) {
                if (error.type === 'network') {
                    this.debug('üåê Network error - checking connectivity...', 'info');
                } else if (error.type === 'peer-unavailable') {
                    this.debug('üëª Peer unavailable - cleaning up...', 'info');
                    // Remove from discovered peers
                    this.discoveredPeers.delete(error.peer);
                }
            }
            
            handleNewConnection(conn) {
                if (this.connections.size >= this.networkConfig.maxConnections) {
                    this.debug('üö´ Max connections reached, rejecting...', 'info');
                    conn.close();
                    return;
                }

                const connectionTimeout = setTimeout(() => {
                    this.debug(`‚è∞ Connection timeout: ${conn.peer}`, 'error');
                    conn.close();
                }, this.networkConfig.connectionTimeout);

                conn.on('open', () => {
                    clearTimeout(connectionTimeout);
                    this.debug(`‚úÖ Enhanced connection established: ${conn.peer}`, 'success');
                    this.connections.set(conn.peer, {
                        connection: conn,
                        lastSeen: Date.now(),
                        messagesReceived: 0,
                        messagesSent: 0,
                        quality: 1.0
                    });
                    this.sendAdvancedHandshake(conn);
                    this.updateRoutingTable();
                    this.emit('peerConnected', { peerId: conn.peer });
                });
                
                conn.on('data', (data) => {
                    const peerInfo = this.connections.get(conn.peer);
                    if (peerInfo) {
                        peerInfo.lastSeen = Date.now();
                        peerInfo.messagesReceived++;
                    }
                    this.handlePeerMessage(conn.peer, data);
                });
                
                conn.on('close', () => {
                    this.debug(`üîå Enhanced connection closed: ${conn.peer}`, 'info');
                    this.connections.delete(conn.peer);
                    this.updateRoutingTable();
                    this.emit('peerDisconnected', { peerId: conn.peer });
                });

                conn.on('error', (error) => {
                    this.debug(`‚ùå Connection error: ${conn.peer} - ${error}`, 'error');
                    this.connections.delete(conn.peer);
                });
            }
            
            sendAdvancedHandshake(conn) {
                const handshake = {
                    type: 'ENHANCED_HANDSHAKE',
                    nodeId: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now(),
                    features: ['enhanced-routing', 'mesh-topology', 'service-worker', 'humanitarian-optimization'],
                    version: '2.1',
                    capabilities: {
                        maxConnections: this.networkConfig.maxConnections,
                        algorithms: ['enhanced-routing', 'secure-hash'],
                        protocols: ['WebRTC', 'humanitarian-mesh', 'broadcast-channel'],
                        serviceWorker: this.serviceWorkerReady
                    }
                };
                
                try {
                    conn.send(handshake);
                    const peerInfo = this.connections.get(conn.peer);
                    if (peerInfo) {
                        peerInfo.messagesSent++;
                    }
                } catch (error) {
                    this.debug(`‚ùå Failed to send handshake: ${error.message}`, 'error');
                }
            }
            
            handlePeerMessage(peerId, data) {
                this.debug(`üì® Enhanced message from ${peerId}: ${data.type}`, 'info');

                try {
                    switch (data.type) {
                        case 'ENHANCED_HANDSHAKE':
                            this.handleAdvancedHandshake(peerId, data);
                            break;

                        case 'PRAYER_ANNOUNCEMENT':
                            this.handlePrayerReceived(data.prayer);
                            break;

                        case 'ROUTING_UPDATE':
                            this.handleRoutingUpdate(peerId, data);
                            break;

                        case 'NETWORK_HEARTBEAT':
                            this.handleHeartbeat(peerId, data);
                            break;

                        case 'PERFORMANCE_METRICS':
                            this.handlePerformanceMetrics(peerId, data);
                            break;

                        default:
                            this.debug(`‚ùì Unknown message type: ${data.type}`, 'info');
                    }
                } catch (error) {
                    this.debug(`‚ùå Error handling message: ${error.message}`, 'error');
                }

                this.emit('peerMessage', { peerId, data });
            }

            handleAdvancedHandshake(peerId, data) {
                this.discoveredPeers.set(peerId, {
                    id: peerId,
                    vector: data.vector,
                    lastSeen: Date.now(),
                    connected: true,
                    features: data.features || [],
                    version: data.version || '1.0',
                    capabilities: data.capabilities || {},
                    distance: this.calculateAdvancedDistance(this.vector, data.vector)
                });

                // Send routing update
                this.sendRoutingUpdate(peerId);
            }

            calculateAdvancedDistance(vec1, vec2) {
                if (!vec1 || !vec2 || vec1.length !== vec2.length) {
                    return Infinity;
                }
                
                let distance = 0;
                for (let i = 0; i < vec1.length; i++) {
                    distance += Math.pow(vec1[i] - vec2[i], 2);
                }
                return Math.sqrt(distance);
            }

            sendRoutingUpdate(targetPeer) {
                const conn = this.connections.get(targetPeer);
                if (!conn) return;

                const routingInfo = Array.from(this.discoveredPeers.entries())
                    .filter(([id, _]) => id !== targetPeer)
                    .map(([id, peer]) => ({
                        nodeId: id,
                        distance: peer.distance,
                        lastSeen: peer.lastSeen,
                        features: peer.features
                    }));

                try {
                    conn.connection.send({
                        type: 'ROUTING_UPDATE',
                        nodeId: this.nodeId,
                        routes: routingInfo,
                        timestamp: Date.now()
                    });
                } catch (error) {
                    this.debug(`‚ùå Failed to send routing update: ${error.message}`, 'error');
                }
            }

            handleRoutingUpdate(peerId, data) {
                if (!data.routes) return;

                for (const route of data.routes) {
                    if (route.nodeId !== this.nodeId && !this.discoveredPeers.has(route.nodeId)) {
                        this.discoveredPeers.set(route.nodeId, {
                            id: route.nodeId,
                            distance: route.distance + 1, // Hop distance
                            lastSeen: route.lastSeen,
                            connected: false,
                            features: route.features || [],
                            via: peerId
                        });
                    }
                }

                this.updateRoutingTable();
            }

            updateRoutingTable() {
                this.routingTable.clear();
                
                // Direct connections
                for (const [peerId, _] of this.connections.entries()) {
                    this.routingTable.set(peerId, { nextHop: peerId, distance: 1 });
                }

                // Multi-hop routes via enhanced P2P algorithm
                for (const [peerId, peer] of this.discoveredPeers.entries()) {
                    if (!this.routingTable.has(peerId)) {
                        this.routingTable.set(peerId, {
                            nextHop: peer.via || peerId,
                            distance: peer.distance
                        });
                    }
                }
            }

            handleHeartbeat(peerId, data) {
                const peerInfo = this.connections.get(peerId);
                if (peerInfo) {
                    peerInfo.lastSeen = Date.now();
                    peerInfo.quality = this.calculateConnectionQuality(peerInfo);
                }
            }

            calculateConnectionQuality(peerInfo) {
                const age = Date.now() - peerInfo.lastSeen;
                const maxAge = this.networkConfig.heartbeatInterval * 2;
                return Math.max(0, 1 - (age / maxAge));
            }
            
            handlePrayerReceived(prayer) {
                if (!prayer || !prayer.id) return;

                this.prayers.set(prayer.id, {
                    ...prayer,
                    receivedAt: Date.now(),
                    via: 'network'
                });

                this.debug(`üìø Prayer received: ${prayer.title}`, 'success');
                
                try {
                    const prayers = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    prayers[prayer.id] = prayer;
                    localStorage.setItem('network_prayers', JSON.stringify(prayers));
                } catch (error) {
                    console.warn('Failed to persist prayer:', error);
                }
                
                this.emit('prayerReceived', prayer);
                this.showToast(`üôè New prayer received: ${prayer.title.substring(0, 30)}...`);
            }
            
            async announceToNetwork() {
                console.log('üî• === STARTING NETWORK ANNOUNCEMENT ===');
                console.log('üî• Node ID:', this.nodeId);
                console.log('üî• Connections:', this.connections.size);
                console.log('üî• Service Worker Ready:', this.serviceWorkerReady);
                console.log('üî• Timestamp:', new Date().toISOString());
                
                const announcement = {
                    nodeId: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now(),
                    version: '2.1',
                    features: ['enhanced P2P', 'service-worker', 'humanitarian-mesh'],
                    capabilities: this.networkConfig,
                    origin: window.location.origin,
                    userAgent: navigator.userAgent.split(')')[0] + ')', // Partial UA for identification
                    bootstrapHints: this.userConfig
                };
                
                console.log('üî• Announcement payload:', JSON.stringify(announcement, null, 2));
                
                // Multi-channel discovery approach with global fallback
                const discoveryPromises = [
                    this.announceViaBroadcastChannel(announcement),
                    this.announceViaServiceWorker(announcement), 
                    this.announceViaLocalStorage(announcement),
                    this.announceViaGlobalRendezvous(announcement)
                ];
                
                console.log('üî• Starting 4 discovery channels...');
                
                try {
                    const results = await Promise.allSettled(discoveryPromises);
                    console.log('üî• Discovery results:', results.map((r, i) => ({
                        channel: ['BroadcastChannel', 'ServiceWorker', 'localStorage', 'GlobalRendezvous'][i],
                        status: r.status,
                        value: r.value,
                        reason: r.reason?.message
                    })));
                    
                    const successful = results.filter(r => r.status === 'fulfilled').length;
                    console.log(`üî• ANNOUNCEMENT COMPLETE: ${successful}/4 channels successful`);
                    this.debug(`üì° Enhanced announcement: ${successful}/4 channels successful`, 'success');
                } catch (error) {
                    console.error('üî• ANNOUNCEMENT FAILED:', error);
                    this.debug('‚ùå Failed to announce: ' + error.message, 'error');
                }
                
                console.log('üî• === ANNOUNCEMENT CYCLE COMPLETE ===\n');
            }

            async announceViaGlobalRendezvous(announcement) {
                // Global rendezvous with Mikey's persistent node
                const globalEndpoints = this.getGlobalAnnouncementEndpoints();

                if (globalEndpoints.length === 0) {
                    this.debug('‚ö†Ô∏è No compatible rendezvous endpoints for current protocol', 'error');
                    return false;
                }

                let successCount = 0;

                for (const endpoint of globalEndpoints) {
                    try {
                        const isGlobalNode = endpoint.includes('185.187.243.129');
                        const payload = {
                            type: isGlobalNode ? 'peer_announcement' : 'pss_peer_announce',
                            room: 'prayers_saints_saviors_v2',
                            data: announcement,
                            timestamp: Date.now(),
                            protocol_version: '2.1'
                        };

                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'X-Network-Protocol': 'PSS-Enhanced-P2P',
                                'X-Node-Version': '2.1'
                            },
                            body: JSON.stringify(payload),
                            signal: AbortSignal.timeout(isGlobalNode ? 8000 : 3000) // Longer timeout for global node
                        });
                        
                        if (response.ok) {
                            successCount++;
                            if (isGlobalNode) {
                                this.debug(`üåç Global node announce ‚úì ${endpoint.split('/')[2]}`, 'success');
                                
                                // Try to get peer list from global node
                                try {
                                    const peersResponse = await fetch(endpoint.replace('/announce', '/peers'), {
                                        method: 'GET',
                                        headers: { 'X-Network-Protocol': 'PSS-Enhanced-P2P' },
                                        signal: AbortSignal.timeout(5000)
                                    });
                                    
                                    if (peersResponse.ok) {
                                        const peersData = await peersResponse.json();
                                        if (peersData.peers && Array.isArray(peersData.peers)) {
                                            this.handleGlobalPeerList(peersData.peers);
                                        }
                                    }
                                } catch (e) {
                                    console.log('Could not fetch peer list from global node:', e.message);
                                }
                            } else {
                                this.debug(`üåê Backup rendezvous ${endpoint.split('//')[1].split('/')[0]} ‚úì`, 'success');
                            }
                        }
                    } catch (error) {
                        const domain = endpoint.split('//')[1]?.split('/')[0] || endpoint;
                        const isGlobalNode = domain.includes('185.187.243.129');
                        if (isGlobalNode) {
                            this.debug(`‚ùå Global node ${domain} failed: ${error.message}`, 'error');
                        } else {
                            this.debug(`‚ùå Backup rendezvous ${domain} failed`, 'error');
                        }
                    }
                }
                
                return successCount > 0;
            }

            handleGlobalPeerList(peers) {
                const now = Date.now();
                let discoveredCount = 0;
                
                for (const peer of peers) {
                    // Skip if it's our own node or too old
                    if (peer.nodeId === this.nodeId || !peer.nodeId || !peer.timestamp) {
                        continue;
                    }
                    
                    const peerAge = now - peer.timestamp;
                    if (peerAge > 15 * 60 * 1000) { // Skip peers older than 15 minutes
                        continue;
                    }
                    
                    // Add to discovered peers if not already connected
                    if (!this.connections.has(peer.nodeId) && 
                        !this.discoveredPeers.has(peer.nodeId) &&
                        this.connections.size < this.networkConfig.maxConnections) {
                        
                        this.discoveredPeers.set(peer.nodeId, {
                            id: peer.nodeId,
                            vector: peer.vector || [],
                            lastSeen: peer.timestamp,
                            connected: false,
                            features: peer.features || [],
                            version: peer.version || '1.0',
                            via: 'global-node',
                            distance: this.calculateAdvancedDistance(this.vector, peer.vector || [])
                        });
                        
                        discoveredCount++;
                        
                        // Try to connect with random delay
                        setTimeout(() => {
                            this.connectToPeer(peer.nodeId);
                        }, Math.random() * 3000 + 1000); // 1-4 second delay
                    }
                }
                
                if (discoveredCount > 0) {
                    this.debug(`üåç Global node provided ${discoveredCount} peers`, 'success');
                }
            }

            async announceViaBroadcastChannel(announcement) {
                try {
                    if (typeof BroadcastChannel !== 'undefined') {
                        const channel = new BroadcastChannel('pss_p2p_discovery_v2');
                        channel.postMessage({
                            type: 'peer_announcement',
                            data: announcement,
                            timestamp: Date.now()
                        });
                        channel.close();
                        this.debug('üìª BroadcastChannel announce sent', 'success');
                        return true;
                    }
                } catch (error) {
                    this.debug('‚ùå BroadcastChannel failed: ' + error.message, 'error');
                }
                return false;
            }

            async announceViaServiceWorker(announcement) {
                console.log('üî• SERVICE WORKER: Starting announcement...');
                console.log('üî• SERVICE WORKER: serviceWorker in navigator?', 'serviceWorker' in navigator);
                console.log('üî• SERVICE WORKER: controller available?', !!navigator.serviceWorker?.controller);
                console.log('üî• SERVICE WORKER: serviceWorkerReady?', this.serviceWorkerReady);
                
                try {
                    if ('serviceWorker' in navigator) {
                        // Check if Service Worker is actually ready and controlled
                        if (!navigator.serviceWorker.controller) {
                            console.log('üî• SERVICE WORKER: No controller - waiting for SW...');
                            this.debug('‚ö†Ô∏è No SW controller - waiting for SW...', 'info');
                            await navigator.serviceWorker.ready;
                            console.log('üî• SERVICE WORKER: SW ready signal received');
                            
                            // Wait a bit more for controller to be available
                            let attempts = 0;
                            while (!navigator.serviceWorker.controller && attempts < 10) {
                                console.log(`üî• SERVICE WORKER: Waiting for controller (${attempts}/10)...`);
                                await new Promise(resolve => setTimeout(resolve, 200));
                                attempts++;
                            }
                        }
                        
                        if (navigator.serviceWorker.controller) {
                            console.log('üî• SERVICE WORKER: Sending REGISTER_PEER message to controller...');
                            console.log('üî• SERVICE WORKER: Announcement payload:', announcement);
                            
                            // Use Mikey's SW message format - REGISTER_PEER
                            navigator.serviceWorker.controller.postMessage({
                                type: 'REGISTER_PEER',
                                data: {
                                    id: announcement.nodeId,
                                    nodeId: announcement.nodeId,
                                    timestamp: announcement.timestamp,
                                    vector: announcement.vector,
                                    features: announcement.features,
                                    origin: announcement.origin,
                                    userAgent: announcement.userAgent,
                                    version: announcement.version,
                                    capabilities: announcement.capabilities
                                }
                            });
                            
                            console.log('üî• SERVICE WORKER: REGISTER_PEER message sent successfully');
                            this.debug('üîß ServiceWorker peer registered', 'success');
                            return true;
                        } else {
                            console.log('‚ùå SERVICE WORKER: Controller not available');
                            console.log('‚ùå SERVICE WORKER: controller?', !!navigator.serviceWorker.controller);
                            console.log('‚ùå SERVICE WORKER: serviceWorkerReady?', this.serviceWorkerReady);
                            this.debug('‚ùå SW controller not available yet', 'error');
                            return false;
                        }
                    } else {
                        console.log('‚ùå SERVICE WORKER: Not supported in this browser');
                        return false;
                    }
                } catch (error) {
                    console.error('‚ùå SERVICE WORKER ERROR:', error);
                    this.debug('‚ùå ServiceWorker failed: ' + error.message, 'error');
                }
                return false;
            }

            async announceViaLocalStorage(announcement) {
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements_v2') || '[]');
                    announcements.push(announcement);
                    
                    // Keep only recent announcements
                    const maxAge = 10 * 60 * 1000; // 10 minutes
                    const fresh = announcements.filter(a => Date.now() - a.timestamp < maxAge);
                    
                    localStorage.setItem('p2p_announcements_v2', JSON.stringify(fresh));
                    
                    // Trigger storage event for other tabs
                    window.dispatchEvent(new StorageEvent('storage', {
                        key: 'p2p_announcements_v2',
                        newValue: JSON.stringify(fresh),
                        url: window.location.href
                    }));
                    
                    this.debug('üíæ localStorage announce stored', 'success');
                    return true;
                } catch (error) {
                    this.debug('‚ùå localStorage failed: ' + error.message, 'error');
                }
                return false;
            }
            
            async startPeerDiscovery() {
                await this.discoverPeers();
                
                this.discoveryInterval = setInterval(() => {
                    this.discoverPeers();
                    this.cleanupStaleData();
                }, this.networkConfig.discoveryInterval);
                
                // Setup BroadcastChannel listener
                this.setupBroadcastChannelListener();
                
                // Setup localStorage listener
                window.addEventListener('storage', (event) => {
                    if (event.key === 'p2p_announcements_v2') {
                        this.handleStorageEvent(event);
                    }
                });
            }

            setupBroadcastChannelListener() {
                try {
                    if (typeof BroadcastChannel !== 'undefined') {
                        this.broadcastChannel = new BroadcastChannel('pss_p2p_discovery_v2');
                        
                        this.broadcastChannel.addEventListener('message', (event) => {
                            if (event.data.type === 'peer_announcement') {
                                const announcement = event.data.data;
                                if (announcement.nodeId !== this.nodeId &&
                                    !this.connections.has(announcement.nodeId) &&
                                    this.connections.size < this.networkConfig.maxConnections) {
                                    
                                    this.debug(`üìª BroadcastChannel peer: ${announcement.nodeId.substr(0, 12)}...`, 'info');
                                    setTimeout(() => {
                                        this.connectToPeer(announcement.nodeId);
                                    }, Math.random() * 1000); // Random delay
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.warn('BroadcastChannel setup failed:', error);
                }
            }

            handleStorageEvent(event) {
                try {
                    if (event.newValue) {
                        const announcements = JSON.parse(event.newValue);
                        const now = Date.now();
                        const maxAge = 10 * 60 * 1000; // 10 minutes
                        
                        for (const stored of announcements) {
                            if (now - stored.timestamp < maxAge && 
                                stored.nodeId !== this.nodeId &&
                                !this.connections.has(stored.nodeId) &&
                                this.connections.size < this.networkConfig.maxConnections) {
                                
                                this.debug(`üíæ Storage peer: ${stored.nodeId.substr(0, 12)}...`, 'info');
                                setTimeout(() => {
                                    this.connectToPeer(stored.nodeId);
                                }, Math.random() * 1500); // Random delay
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Storage event handling failed:', error);
                }
            }
            
            async discoverPeers() {
                await this.announceToNetwork();
                await this.searchForPeers();
                await this.searchGlobalNode();
            }

            async searchGlobalNode() {
                // Periodic discovery from global rendezvous node
                if (Math.random() < 0.3) { // 30% chance each discovery cycle
                    try {
                        const globalEndpoints = this.getGlobalPeerEndpoints();

                        for (const endpoint of globalEndpoints) {
                            try {
                                const response = await fetch(endpoint, {
                                    method: 'GET',
                                    headers: { 
                                        'X-Network-Protocol': 'PSS-Enhanced-P2P',
                                        'X-Node-ID': this.nodeId 
                                    },
                                    signal: AbortSignal.timeout(6000)
                                });
                                
                                if (response.ok) {
                                    const data = await response.json();
                                    if (data.peers && Array.isArray(data.peers)) {
                                        this.handleGlobalPeerList(data.peers);
                                        this.debug(`üåç Global discovery from ${endpoint.split('/')[2]}`, 'success');
                                        break; // Success, no need to try other endpoints
                                    }
                                }
                            } catch (e) {
                                // Silent fail, try next endpoint
                                continue;
                            }
                        }
                    } catch (error) {
                        // Silent fail for global discovery
                    }
                }
            }

            async searchForPeers() {
                const now = Date.now();
                const maxAge = 10 * 60 * 1000; // 10 minutes
                
                // Search localStorage
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements_v2') || '[]');
                    for (const stored of announcements) {
                        if (now - stored.timestamp < maxAge && 
                            stored.nodeId !== this.nodeId &&
                            !this.connections.has(stored.nodeId) &&
                            this.connections.size < this.networkConfig.maxConnections) {
                            
                            await this.connectToPeer(stored.nodeId);
                        }
                    }
                } catch (error) {
                    console.warn('localStorage search failed:', error);
                }

                // Search via ServiceWorker
                if (this.serviceWorkerReady) {
                    try {
                        if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                            const channel = new MessageChannel();
                            
                            navigator.serviceWorker.controller.postMessage({
                                type: 'get_announcements'
                            }, [channel.port2]);
                            
                            channel.port1.onmessage = (event) => {
                                const { announcements } = event.data;
                                if (announcements && Array.isArray(announcements)) {
                                    for (const stored of announcements) {
                                        if (now - stored.timestamp < maxAge && 
                                            stored.nodeId !== this.nodeId &&
                                            !this.connections.has(stored.nodeId) &&
                                            this.connections.size < this.networkConfig.maxConnections) {
                                            
                                            setTimeout(() => {
                                                this.connectToPeer(stored.nodeId);
                                            }, Math.random() * 2000); // Random delay
                                        }
                                    }
                                }
                            };
                        }
                    } catch (error) {
                        console.warn('ServiceWorker search failed:', error);
                    }
                }
            }
            
            async connectToPeer(peerId) {
                if (peerId === this.nodeId || this.connections.has(peerId)) {
                    return;
                }
                
                try {
                    this.debug(`üìû Enhanced connecting to: ${peerId}`, 'info');
                    const conn = this.peer.connect(peerId, {
                        reliable: true,
                        serialization: 'json'
                    });
                    this.handleNewConnection(conn);
                } catch (error) {
                    this.debug(`‚ùå Failed to connect: ${error.message}`, 'error');
                }
            }
            
            cleanupStaleData() {
                const now = Date.now();
                const staleTimeout = 5 * 60 * 1000; // 5 minutes
                
                // Clean discovered peers
                for (const [peerId, peer] of this.discoveredPeers.entries()) {
                    if (now - peer.lastSeen > staleTimeout) {
                        this.discoveredPeers.delete(peerId);
                        this.debug(`üßπ Cleaned stale peer: ${peerId}`, 'info');
                    }
                }

                // Clean connections with poor quality
                for (const [peerId, peerInfo] of this.connections.entries()) {
                    if (peerInfo.quality < 0.3) {
                        this.debug(`üîå Closing poor quality connection: ${peerId}`, 'info');
                        peerInfo.connection.close();
                        this.connections.delete(peerId);
                    }
                }
                
                // Clean local storage
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements_v2') || '[]');
                    const fresh = announcements.filter(a => now - a.timestamp < 10 * 60 * 1000);
                    localStorage.setItem('p2p_announcements_v2', JSON.stringify(fresh));
                } catch (error) {
                    console.warn('Cleanup failed:', error);
                }

                this.updateRoutingTable();
            }

            broadcastPrayer(prayer) {
                if (this.connections.size === 0) {
                    this.debug('‚ùå No connections for broadcast', 'error');
                    return false;
                }
                
                const message = {
                    type: 'PRAYER_ANNOUNCEMENT',
                    prayer: {
                        ...prayer,
                        hopCount: (prayer.hopCount || 0) + 1,
                        path: [...(prayer.path || []), this.nodeId]
                    },
                    timestamp: Date.now(),
                    sender: this.nodeId,
                    algorithm: 'enhanced P2P'
                };
                
                let broadcastCount = 0;
                const maxHops = 6; // Prevent infinite loops
                
                if (message.prayer.hopCount <= maxHops) {
                    for (const [peerId, peerInfo] of this.connections.entries()) {
                        try {
                            peerInfo.connection.send(message);
                            peerInfo.messagesSent++;
                            broadcastCount++;
                            this.debug(`üì° Enhanced broadcast to: ${peerId}`, 'success');
                        } catch (error) {
                            this.debug(`‚ùå Failed to send: ${error.message}`, 'error');
                        }
                    }
                }
                
                this.debug(`üì¢ Enhanced broadcast to ${broadcastCount} peers`, 'success');
                return broadcastCount > 0;
            }
            
            async storePrayer(prayer) {
                const enhancedPrayer = {
                    ...prayer,
                    enhancedId: this.generateAdvancedId(),
                    networkVector: this.vector.slice(0, 8), // First 8 dimensions for routing
                    timestamp: Date.now(),
                    version: '2.1'
                };

                this.prayers.set(enhancedPrayer.id, enhancedPrayer);
                
                // Store locally with enhanced enhancement
                try {
                    const prayers = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    prayers[enhancedPrayer.id] = enhancedPrayer;
                    localStorage.setItem('network_prayers', JSON.stringify(prayers));
                } catch (error) {
                    console.warn('Failed to store prayer:', error);
                }
                
                // Enhanced-enhanced broadcast
                const success = this.broadcastPrayer(enhancedPrayer);
                this.emit('prayerStored', enhancedPrayer);
                
                return success;
            }
            
            getStoredPrayers() {
                const prayers = [];
                
                // Get from memory
                prayers.push(...Array.from(this.prayers.values()));
                
                // Get from localStorage
                try {
                    const stored = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    Object.values(stored).forEach(prayer => {
                        if (!this.prayers.has(prayer.id)) {
                            prayers.push(prayer);
                        }
                    });
                } catch (error) {
                    console.warn('Failed to load stored prayers:', error);
                }
                
                // Sort by enhanced distance and timestamp
                return prayers.sort((a, b) => {
                    if (a.enhancedId && b.enhancedId) {
                        return b.timestamp - a.timestamp; // Most recent first
                    }
                    return b.timestamp - a.timestamp;
                });
            }
            
            startHeartbeat() {
                this.heartbeatInterval = setInterval(() => {
                    const heartbeat = {
                        type: 'NETWORK_HEARTBEAT',
                        nodeId: this.nodeId,
                        timestamp: Date.now(),
                        metrics: {
                            connections: this.connections.size,
                            prayers: this.prayers.size,
                            uptime: Date.now() - this.startTime,
                            quality: this.calculateNetworkQuality(),
                            serviceWorker: this.serviceWorkerReady
                        }
                    };

                    for (const [peerId, peerInfo] of this.connections.entries()) {
                        try {
                            peerInfo.connection.send(heartbeat);
                            peerInfo.messagesSent++;
                        } catch (error) {
                            this.debug(`‚ùå Heartbeat failed: ${peerId}`, 'error');
                        }
                    }
                    
                    this.emit('heartbeat', this.getNetworkStats());
                }, this.networkConfig.heartbeatInterval);
            }

            calculateNetworkQuality() {
                if (this.connections.size === 0) return 0;
                
                const qualities = Array.from(this.connections.values())
                    .map(peerInfo => peerInfo.quality || 0);
                
                return qualities.reduce((sum, q) => sum + q, 0) / qualities.length;
            }

            startPerformanceMonitoring() {
                setInterval(() => {
                    const stats = this.getNetworkStats();
                    this.performanceMetrics.set(Date.now(), stats);
                    
                    // Keep only last 100 measurements
                    if (this.performanceMetrics.size > 100) {
                        const oldestKey = Math.min(...this.performanceMetrics.keys());
                        this.performanceMetrics.delete(oldestKey);
                    }
                }, 10000); // Every 10 seconds
            }
            
            getNetworkStats() {
                const globalPeers = Array.from(this.discoveredPeers.values())
                    .filter(peer => peer.via === 'global-node').length;
                
                return {
                    nodeId: this.nodeId,
                    isOnline: this.isOnline,
                    connections: this.connections.size,
                    discoveredPeers: this.discoveredPeers.size,
                    globalPeers: globalPeers,
                    prayers: this.prayers.size,
                    uptime: Date.now() - this.startTime,
                    algorithm: 'Enhanced P2P',
                    version: '2.1',
                    quality: this.calculateNetworkQuality(),
                    routes: this.routingTable.size,
                    features: ['enhanced-enhanced', 'service-worker', 'broadcast-channel', 'global-rendezvous', 'mesh-topology', 'humanitarian-coordination'],
                    serviceWorker: this.serviceWorkerReady,
                    globalRendezvous: globalPeers > 0 || this.hasGlobalConnectivity()
                };
            }

            hasGlobalConnectivity() {
                // Check if we've successfully connected to the global rendezvous recently
                const recentGlobalActivity = Array.from(this.discoveredPeers.values())
                    .some(peer => peer.via === 'global-node' && 
                          Date.now() - peer.lastSeen < 5 * 60 * 1000); // 5 minutes
                return recentGlobalActivity;
            }

            getPerformanceHistory() {
                return Array.from(this.performanceMetrics.entries())
                    .sort(([a], [b]) => a - b)
                    .map(([timestamp, stats]) => ({ timestamp, ...stats }));
            }
            
            debug(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                console.log(`[${timestamp}] ${message}`);
                
                if (this.debugMode) {
                    const debugOutput = document.getElementById('debug-output');
                    if (debugOutput) {
                        const logLine = document.createElement('div');
                        logLine.className = `debug-line debug-${type}`;
                        logLine.textContent = `[${timestamp}] ${message}`;
                        
                        debugOutput.appendChild(logLine);
                        debugOutput.scrollTop = debugOutput.scrollHeight;
                        
                        while (debugOutput.children.length > 150) {
                            debugOutput.removeChild(debugOutput.firstChild);
                        }
                    }
                }
            }
            
            showToast(message, duration = 4000) {
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 100);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(toast)) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, duration);
            }
            
            // Event system
            on(event, callback) {
                if (!this.eventListeners.has(event)) {
                    this.eventListeners.set(event, []);
                }
                this.eventListeners.get(event).push(callback);
            }
            
            emit(event, data) {
                const listeners = this.eventListeners.get(event);
                if (listeners) {
                    listeners.forEach(callback => {
                        try {
                            callback(data);
                        } catch (error) {
                            console.error('Event listener error:', error);
                        }
                    });
                }
            }

            destroy() {
                if (this.heartbeatInterval) {
                    clearInterval(this.heartbeatInterval);
                }
                if (this.discoveryInterval) {
                    clearInterval(this.discoveryInterval);
                }
                
                if (this.broadcastChannel) {
                    this.broadcastChannel.close();
                }
                
                for (const [peerId, peerInfo] of this.connections.entries()) {
                    peerInfo.connection.close();
                }
                
                if (this.peer && !this.peer.destroyed) {
                    this.peer.destroy();
                }
                
                this.isOnline = false;
                this.debug('üõë Network shutdown complete', 'info');
            }
        }

        // Enhanced Decentralized Authentication with Better UX
        class ModernDecentralizedAuth {
            constructor() {
                requireConsent();
                this.web3 = null;
                this.initializeWeb3();
            }

            async initializeWeb3() {
                if (typeof window.ethereum !== 'undefined') {
                    this.web3 = new Web3(window.ethereum);
                }
            }

            async signInWithEthereum(address) {
                requireConsent();
                
                if (!this.web3) await this.initializeWeb3();
                
                const domain = window.location.hostname;
                const chainId = await this.web3.eth.getChainId();
                const nonce = Math.random().toString(36).substring(2, 15);
                const issuedAt = new Date().toISOString();
                
                const message = `${domain} wants you to sign in with your Ethereum account:
${address}

Welcome to the Enhanced P2P Humanitarian Network

This signature verifies your identity for the decentralized P2P network without revealing personal information.

URI: ${window.location.origin}
Version: 2.1
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt}`;

                try {
                    const signature = await window.ethereum.request({
                        method: 'personal_sign',
                        params: [message, address]
                    });
                    
                    let ensName = null;
                    let avatar = `https://api.dicebear.com/7.x/identicon/svg?seed=${address}`;
                    
                    // Try to get ENS name and avatar - wrap in hard try-catch
                    try {
                        ensName = await this.web3.eth.ens.reverse(address);
                    } catch (e) {
                        console.log('ENS lookup failed:', e);
                        ensName = null;
                    }

                    if (ensName) {
                        try {
                            // Try to get ENS avatar
                            const resolver = await this.web3.eth.ens.resolver(ensName);
                            if (resolver) {
                                const ensAvatar = await resolver.methods.text(this.web3.utils.namehash(ensName), 'avatar').call();
                                if (ensAvatar) avatar = ensAvatar;
                            }
                        } catch (e) {
                            console.log('ENS avatar lookup failed:', e);
                            // Keep default avatar
                        }
                    }

                    const displayName = ensName || `${address.substring(0, 6)}...${address.substring(38)}`;

                    return {
                        address,
                        ensName,
                        displayName,
                        avatar,
                        signature,
                        message,
                        verified: true,
                        authMethod: 'ethereum',
                        timestamp: Date.now(),
                        version: '2.1',
                        enhanced: true
                    };
                } catch (error) {
                    if (error.code === 4001) {
                        throw new Error('User rejected the signature request');
                    }
                    throw error;
                }
            }

            async signInWithPasskey() {
                requireConsent();
                
                if (!window.PublicKeyCredential) {
                    throw new Error('WebAuthn not supported on this device');
                }

                const credentialId = localStorage.getItem('prayers_credential_id');
                let credential;

                try {
                    if (credentialId) {
                        // Existing passkey authentication
                        credential = await navigator.credentials.get({
                            publicKey: {
                                challenge: crypto.getRandomValues(new Uint8Array(32)),
                                allowCredentials: [{
                                    id: Uint8Array.from(atob(credentialId), c => c.charCodeAt(0)),
                                    type: 'public-key'
                                }],
                                timeout: 60000,
                                userVerification: 'required'
                            }
                        });
                    } else {
                        // New passkey creation
                        const userId = crypto.getRandomValues(new Uint8Array(16));
                        credential = await navigator.credentials.create({
                            publicKey: {
                                challenge: crypto.getRandomValues(new Uint8Array(32)),
                                rp: { 
                                    name: 'Prayers Saints Saviors',
                                    id: window.location.hostname
                                },
                                user: {
                                    id: userId,
                                    name: `user-${Date.now()}`,
                                    displayName: 'Humanitarian Network User'
                                },
                                pubKeyCredParams: [
                                    { alg: -7, type: 'public-key' }, // ES256
                                    { alg: -257, type: 'public-key' } // RS256
                                ],
                                authenticatorSelection: {
                                    authenticatorAttachment: 'platform',
                                    userVerification: 'required',
                                    residentKey: 'preferred'
                                },
                                timeout: 60000
                            }
                        });
                        
                        const newCredentialId = btoa(String.fromCharCode(...new Uint8Array(credential.rawId)));
                        localStorage.setItem('prayers_credential_id', newCredentialId);
                    }

                    const credId = btoa(String.fromCharCode(...new Uint8Array(credential.rawId)));
                    const displayName = `User-${credId.substring(0, 8)}`;
                    
                    return {
                        credentialId: credId,
                        displayName,
                        avatar: `https://api.dicebear.com/7.x/avataaars/svg?seed=${credId}`,
                        verified: true,
                        authMethod: 'passkey',
                        timestamp: Date.now(),
                        version: '2.1',
                        enhanced: true,
                        authenticatorData: credential.response.authenticatorData
                    };
                } catch (error) {
                    if (error.name === 'NotAllowedError') {
                        throw new Error('Biometric authentication was cancelled or failed');
                    } else if (error.name === 'InvalidStateError') {
                        throw new Error('This device is already registered');
                    } else if (error.name === 'NotSupportedError') {
                        throw new Error('Biometric authentication not supported');
                    }
                    throw new Error(`Authentication failed: ${error.message}`);
                }
            }

            async generateAnonymousId() {
                // Fallback anonymous authentication
                const entropy = crypto.getRandomValues(new Uint32Array(4));
                const id = Array.from(entropy, x => x.toString(36)).join('');
                const timestamp = Date.now();
                
                return {
                    anonymousId: id,
                    displayName: `Anonymous-${id.substring(0, 8)}`,
                    avatar: `https://api.dicebear.com/7.x/bottts/svg?seed=${id}`,
                    verified: false,
                    authMethod: 'anonymous',
                    timestamp,
                    version: '2.1',
                    enhanced: true,
                    note: 'Limited features available in anonymous mode'
                };
            }
        }

        // Complete React Application with Enhanced Features
        function EnhancedCompleteApplication() {
            const { useState, useEffect, useCallback, useMemo, useRef } = React;

            function getStoredBootstrapConfig() {
                try {
                    const stored = localStorage.getItem('pss_user_config');
                    if (stored) {
                        return sanitizeBootstrapConfig(JSON.parse(stored));
                    }
                } catch (error) {
                    console.warn('Failed to load stored bootstrap config:', error);
                }
                return { nodeIp: '', neighborIp: '' };
            }

            function sanitizeBootstrapConfig(config) {
                if (!config || typeof config !== 'object') {
                    return { nodeIp: '', neighborIp: '' };
                }

                const sanitizeValue = (value) =>
                    typeof value === 'string' ? value.trim() : '';

                return {
                    nodeIp: sanitizeValue(config.nodeIp),
                    neighborIp: sanitizeValue(config.neighborIp)
                };
            }

            function persistBootstrapConfig(config) {
                const sanitized = sanitizeBootstrapConfig(config);

                try {
                    if (sanitized.nodeIp || sanitized.neighborIp) {
                        localStorage.setItem('pss_user_config', JSON.stringify(sanitized));
                    } else {
                        localStorage.removeItem('pss_user_config');
                    }
                } catch (error) {
                    console.warn('Failed to persist bootstrap config:', error);
                }

                return sanitized;
            }

            // Enhanced State Management
            const [user, setUser] = useState(null);
            const [network, setNetwork] = useState(null);
            const [auth, setAuth] = useState(null);
            const [prayers, setPrayers] = useState([]);
            const [networkStats, setNetworkStats] = useState({ 
                connections: 0, discoveredPeers: 0, prayers: 0, isOnline: false, 
                uptime: 0, quality: 0, algorithm: 'Enhanced P2P', version: '2.1' 
            });
            const [initStatus, setInitStatus] = useState('Initializing enhanced network with Service Worker...');
            const [showCreateForm, setShowCreateForm] = useState(false);
            const [showDebug, setShowDebug] = useState(false);
            const [showPerformance, setShowPerformance] = useState(false);
            const [loading, setLoading] = useState(false);
            const [isNetworkReady, setIsNetworkReady] = useState(false);
            const [connectionQuality, setConnectionQuality] = useState('Initializing...');
            const networkRef = useRef(null);
            const [peerDisplay, setPeerDisplay] = useState([]);
            const storedBootstrapConfig = useMemo(() => getStoredBootstrapConfig(), []);
            const [userConfig, setUserConfig] = useState(storedBootstrapConfig);
            const [configDraft, setConfigDraft] = useState(storedBootstrapConfig);
            const [configSaving, setConfigSaving] = useState(false);

            const [newPrayer, setNewPrayer] = useState({
                title: '', content: '', location: '', urgency: 'medium',
                category: 'general', needsAmount: '', walletAddress: '', tags: ''
            });

            // Enhanced UI updates with better performance
            const [, forceUpdate] = useState({});
            useEffect(() => {
                const interval = setInterval(() => {
                    forceUpdate({});
                    
                    if (networkRef.current && isNetworkReady) {
                        const stats = networkRef.current.getNetworkStats();
                        setNetworkStats(stats);
                        updateNetworkDisplay(stats);
                        
                        // Update connection quality
                        const quality = stats.quality || 0;
                        if (quality > 0.8) {
                            setConnectionQuality('Excellent');
                        } else if (quality > 0.6) {
                            setConnectionQuality('Good');
                        } else if (quality > 0.3) {
                            setConnectionQuality('Fair');
                        } else {
                            setConnectionQuality('Poor');
                        }
                    }
                }, 1500); // Slightly less frequent for better performance
                
                return () => clearInterval(interval);
            }, [isNetworkReady]);

            // Enhanced initialization with better error handling
            useEffect(() => {
                if (!userConsent) return;
                
                const initializeEverything = async () => {
                    try {
                        setInitStatus('üîê Initializing modern authentication...');
                        
                        const authSystem = new ModernDecentralizedAuth();
                        setAuth(authSystem);
                        
                        setInitStatus('üåå Starting Enhanced P2P network with Service Worker...');
                        
                        const networkSystem = new AdvancedP2PNetwork();
                        networkRef.current = networkSystem;
                        setNetwork(networkSystem);

                        const bootstrapConfig = sanitizeBootstrapConfig(networkSystem.userConfig || {});
                        setUserConfig(bootstrapConfig);
                        setConfigDraft(bootstrapConfig);

                        setInitStatus('üì° Configuring enhanced routing protocols...');
                        
                        // Enhanced event listeners
                        networkSystem.on('networkReady', (data) => {
                            console.log('‚úÖ Enhanced network ready:', data);
                            setIsNetworkReady(true);
                            setInitStatus('üåê Connected to enhanced mesh network with Service Worker');
                            networkSystem.showToast('üåå Enhanced humanitarian network online with SW support!');
                            loadPrayers(networkSystem);
                            
                            const stats = networkSystem.getNetworkStats();
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        networkSystem.on('peerConnected', (data) => {
                            console.log('üë• Enhanced peer connected:', data.peerId);
                            networkSystem.showToast(`üë• P2P connection: ${data.peerId.substr(0, 12)}...`);
                            
                            const stats = networkSystem.getNetworkStats();
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        networkSystem.on('peerDisconnected', (data) => {
                            console.log('üîå Enhanced peer disconnected:', data.peerId);
                            
                            const stats = networkSystem.getNetworkStats();
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        networkSystem.on('prayerReceived', (prayer) => {
                            console.log('üìø Prayer received via enhanced network:', prayer.id);
                            loadPrayers(networkSystem);
                        });
                        
                        networkSystem.on('heartbeat', (stats) => {
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        setInitStatus('üöÄ Initializing enhanced mesh connections...');
                        
                        await networkSystem.initialize();
                        
                        setInitStatus('‚öôÔ∏è Checking existing user session...');
                        
                        // Enhanced session check
                        const savedUser = localStorage.getItem('prayers_user');
                        if (savedUser) {
                            try {
                                const userData = JSON.parse(savedUser);
                                const sessionAge = Date.now() - userData.timestamp;
                                const maxSessionAge = 7 * 24 * 60 * 60 * 1000; // 7 days
                                
                                if (sessionAge < maxSessionAge && userData.version === '2.1') {
                                    setUser(userData);
                                    networkSystem.showToast(`üîê Welcome back, ${userData.displayName}!`);
                                } else {
                                    localStorage.removeItem('prayers_user');
                                }
                            } catch (e) {
                                localStorage.removeItem('prayers_user');
                            }
                        }
                        
                        loadPrayers(networkSystem);
                        
                        setTimeout(() => {
                            setIsNetworkReady(true);
                            setInitStatus('üåü Enhanced humanitarian network operational with Service Worker');
                        }, 2000);
                        
                    } catch (error) {
                        console.error('Failed to initialize enhanced application:', error);
                        setInitStatus('‚ùå Enhanced initialization failed - attempting recovery...');
                        
                        setTimeout(() => {
                            window.location.reload();
                        }, 5000);
                    }
                };
                
                initializeEverything();
                
                // Cleanup on unmount
                return () => {
                    if (networkRef.current) {
                        networkRef.current.destroy();
                    }
                };
            }, []);

            const loadPrayers = (networkSystem) => {
                try {
                    const prayerList = networkSystem.getStoredPrayers();
                    setPrayers(prayerList);
                    console.log('üìø Loaded enhanced prayers:', prayerList.length);
                } catch (error) {
                    console.error('Failed to load prayers:', error);
                }
            };
            
            const updateNetworkDisplay = (stats) => {
                try {
                    if (!networkRef.current) {
                        setPeerDisplay([]);
                        return;
                    }

                    const peers = [];
                    for (const [peerId, peer] of networkRef.current.discoveredPeers.entries()) {
                        const isConnected = networkRef.current.connections.has(peerId);
                        const statusClass = isConnected ? 'connected' : peer.via ? 'connecting' : 'disconnected';
                        const shortId = peerId.length > 12 ? `${peerId.substr(0, 12)}...` : peerId;
                        const distance = typeof peer.distance === 'number' ? ` (${peer.distance.toFixed(2)})` : '';

                        peers.push({
                            peerId,
                            shortId,
                            distance,
                            statusClass,
                            statusLabel: statusClass,
                            via: peer.via || 'direct'
                        });
                    }

                    setPeerDisplay(peers);
                } catch (error) {
                    console.error('Error updating peer display:', error);
                    setPeerDisplay([]);
                }
            };

            const quality = networkStats.quality || 0;
            const qualityIcon = quality > 0.8 ? 'üü¢' : quality > 0.5 ? 'üü°' : 'üî¥';
            const swIcon = networkStats.serviceWorker ? 'üîß' : '‚ö†Ô∏è';
            const peerListElements = (peerDisplay.length === 0)
                ? [
                    React.createElement('div', {
                        key: 'empty',
                        className: 'peer-item peer-empty'
                    }, 'No peers discovered yet. Discovery running...')
                ]
                : peerDisplay.map((peer) => React.createElement('div', {
                        key: peer.peerId,
                        className: 'peer-item'
                    },
                    React.createElement('span', {
                        title: `${peer.peerId} ‚Ä¢ via ${peer.via}`
                    }, `${peer.shortId}${peer.distance}`),
                    React.createElement('span', {
                        className: `connection-status ${peer.statusClass}`,
                        title: peer.statusLabel
                    })
                ));

            const networkStatusPanel = React.createElement('div', { className: 'network-status' },
                React.createElement('div', {
                    id: 'network-title',
                    className: 'network-status-title'
                }, `üåå Enhanced P2P Network (${networkStats.algorithm} v${networkStats.version}) ${networkStats.serviceWorker ? 'üîßSW' : ''}`),
                React.createElement('div', {
                    id: 'network-stats',
                    className: 'network-status-summary'
                }, `${qualityIcon} ${networkStats.connections || 0} enhanced links ‚Ä¢ ${networkStats.discoveredPeers || 0} mesh peers ‚Ä¢ Q${(quality * 100).toFixed(0)}% ${swIcon}SW`),
                React.createElement('div', {
                    id: 'peer-list',
                    className: 'peer-list'
                }, peerListElements)
            );

            // Enhanced authentication methods
            const signInWithEthereum = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    if (typeof window.ethereum === 'undefined') {
                        throw new Error('Please install MetaMask or another Web3 wallet to continue');
                    }

                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    
                    if (!accounts || accounts.length === 0) {
                        throw new Error('No Ethereum accounts found');
                    }

                    const userData = await auth.signInWithEthereum(accounts[0]);
                    
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (networkRef.current) {
                        networkRef.current.showToast(`üîê Enhanced authenticated: ${userData.displayName}!`);
                    }
                    
                } catch (error) {
                    console.error('Ethereum authentication failed:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast(`‚ùå Authentication failed: ${error.message}`);
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signInWithPasskey = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    const userData = await auth.signInWithPasskey();
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (networkRef.current) {
                        networkRef.current.showToast('üîê Biometric enhanced authentication successful!');
                    }
                    
                } catch (error) {
                    console.error('Passkey authentication failed:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast(`‚ùå Biometric auth failed: ${error.message}`);
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signInAnonymously = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    const userData = await auth.generateAnonymousId();
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (networkRef.current) {
                        networkRef.current.showToast('üë§ Anonymous enhanced session started!');
                    }
                    
                } catch (error) {
                    console.error('Anonymous authentication failed:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Failed to create anonymous session');
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, loading]);

            const signOut = useCallback(() => {
                setUser(null);
                localStorage.removeItem('prayers_user');
                if (networkRef.current) {
                    networkRef.current.showToast('üëã Enhanced session ended');
                }
            }, []);

            const handleConfigSave = useCallback(async () => {
                if (configSaving) return;

                const sanitized = sanitizeBootstrapConfig(configDraft);
                setConfigSaving(true);

                try {
                    let applied = sanitized;

                    if (networkRef.current && typeof networkRef.current.updateUserConfig === 'function') {
                        applied = await networkRef.current.updateUserConfig(sanitized);
                    } else {
                        applied = persistBootstrapConfig(sanitized);
                    }

                    setUserConfig(applied);
                    setConfigDraft(applied);

                    if (networkRef.current) {
                        networkRef.current.showToast('üíæ Bootstrap hints saved');
                    }
                } catch (error) {
                    console.error('Failed to save bootstrap config:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Failed to save bootstrap hints');
                    }
                } finally {
                    setConfigSaving(false);
                }
            }, [configDraft, configSaving]);

            const handleConfigReset = useCallback(async () => {
                if (configSaving) return;

                const cleared = { nodeIp: '', neighborIp: '' };
                setConfigSaving(true);

                try {
                    let applied = cleared;

                    if (networkRef.current && typeof networkRef.current.updateUserConfig === 'function') {
                        applied = await networkRef.current.updateUserConfig(cleared);
                    } else {
                        applied = persistBootstrapConfig(cleared);
                    }

                    setUserConfig(applied);
                    setConfigDraft(applied);

                    if (networkRef.current) {
                        networkRef.current.showToast('üßπ Cleared bootstrap hints');
                    }
                } catch (error) {
                    console.error('Failed to clear bootstrap config:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Failed to clear bootstrap hints');
                    }
                } finally {
                    setConfigSaving(false);
                }
            }, [configSaving]);

            // Enhanced prayer submission with advanced features
            const submitPrayer = useCallback(async () => {
                if (!user || !newPrayer.title.trim() || !newPrayer.content.trim()) {
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Please fill in title and content');
                    }
                    return;
                }

                if (!networkRef.current) {
                    alert('‚ùå Enhanced network not ready. Please wait.');
                    return;
                }

                setLoading(true);

                try {
                    const enhancedPrayer = {
                        id: 'prayer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 8),
                        ...newPrayer,
                        author: user.displayName,
                        authorAddress: user.address || user.anonymousId,
                        authMethod: user.authMethod,
                        timestamp: Date.now(),
                        walletAddress: user.address || newPrayer.walletAddress,
                        tags: newPrayer.tags.split(',').map(tag => tag.trim()).filter(tag => tag),
                        version: '2.1',
                        enhanced: true
                    };

                    const success = await networkRef.current.storePrayer(enhancedPrayer);
                    
                    const message = success ? 
                        '‚úÖ Prayer broadcast to enhanced mesh network!' : 
                        'üì± Prayer saved locally - will sync when enhanced peers connect';
                        
                    networkRef.current.showToast(message);
                    
                    setNewPrayer({
                        title: '', content: '', location: '', urgency: 'medium',
                        category: 'general', needsAmount: '', walletAddress: user.address || '', tags: ''
                    });
                    setShowCreateForm(false);
                    
                    loadPrayers(networkRef.current);
                    
                } catch (error) {
                    console.error('Failed to submit prayer:', error);
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Failed to share prayer. Please try again.');
                    }
                } finally {
                    setLoading(false);
                }
            }, [user, newPrayer, loading]);

            // Enhanced contribution system
            const contributeToPrayer = useCallback(async (prayer) => {
                if (user.authMethod !== 'ethereum' || !user.address) {
                    if (networkRef.current) {
                        networkRef.current.showToast('‚ùå Ethereum wallet required for contributions');
                    }
                    return;
                }

                const amount = prompt('Enter contribution amount in ETH (e.g., 0.01):');
                if (!amount || isNaN(amount) || parseFloat(amount) <= 0) return;

                setLoading(true);
                try {
                    if (typeof window.ethereum !== 'undefined' && typeof Web3 !== 'undefined') {
                        const web3 = new Web3(window.ethereum);
                        
                        // Estimate gas first
                        const gasEstimate = await web3.eth.estimateGas({
                            from: user.address,
                            to: prayer.walletAddress,
                            value: web3.utils.toWei(amount, 'ether')
                        });

                        const tx = await web3.eth.sendTransaction({
                            from: user.address,
                            to: prayer.walletAddress,
                            value: web3.utils.toWei(amount, 'ether'),
                            gas: gasEstimate
                        });
                        
                        if (networkRef.current) {
                            networkRef.current.showToast(`‚úÖ Contribution sent! ${amount} ETH - Tx: ${tx.transactionHash.substring(0, 10)}...`);
                        }
                    }
                } catch (error) {
                    console.error('Transaction failed:', error);
                    if (networkRef.current) {
                        const message = error.code === 4001 ? 'Transaction cancelled by user' : 'Transaction failed. Please try again.';
                        networkRef.current.showToast(`‚ùå ${message}`);
                    }
                } finally {
                    setLoading(false);
                }
            }, [user, loading]);

            // Enhanced debug and performance monitoring
            const toggleDebug = useCallback(() => {
                setShowDebug(prev => !prev);
                if (networkRef.current) {
                    networkRef.current.debugMode = !networkRef.current.debugMode;
                    if (networkRef.current.debugMode) {
                        networkRef.current.debug('üîç Enhanced debug mode enabled', 'info');
                    }
                }
            }, []);

            const togglePerformance = useCallback(() => {
                setShowPerformance(prev => !prev);
            }, []);

            const forceNetworkUpdate = useCallback(() => {
                if (networkRef.current) {
                    const stats = networkRef.current.getNetworkStats();
                    setNetworkStats(stats);
                    updateNetworkDisplay(stats);
                    networkRef.current.showToast('üîÑ Enhanced network state refreshed');
                }
            }, []);

            const emergencyNetworkReset = useCallback(() => {
                if (confirm('‚ö†Ô∏è This will reset the enhanced network connection. Continue?')) {
                    if (networkRef.current) {
                        networkRef.current.destroy();
                        setIsNetworkReady(false);
                        setInitStatus('üîÑ Restarting enhanced network...');
                        
                        setTimeout(() => {
                            window.location.reload();
                        }, 2000);
                    }
                }
            }, []);

            // Performance metrics component
            const performanceMetrics = useMemo(() => {
                if (!networkRef.current || !showPerformance) return null;

                const history = networkRef.current.getPerformanceHistory();
                const recent = history.slice(-10); // Last 10 measurements
                
                return (
                    React.createElement('div', { className: 'card', style: { marginTop: '20px' } },
                        React.createElement('h3', { style: { marginBottom: '20px', color: '#2c3e50' } }, 'üìä Enhanced Network Performance'),
                        React.createElement('div', { className: 'feature-grid' },
                            React.createElement('div', null,
                                React.createElement('h4', null, 'Connection Quality'),
                                React.createElement('div', { style: { fontSize: '24px', color: '#4CAF50' } },
                                    ((networkStats.quality || 0) * 100).toFixed(1) + '%'
                                ),
                                React.createElement('small', null, 'Average across all enhanced links')
                            ),
                            React.createElement('div', null,
                                React.createElement('h4', null, 'Network Uptime'),
                                React.createElement('div', { style: { fontSize: '24px', color: '#2196F3' } },
                                    Math.floor((networkStats.uptime || 0) / 60000) + 'm'
                                ),
                                React.createElement('small', null, 'Continuous enhanced operation')
                            ),
                            React.createElement('div', null,
                                React.createElement('h4', null, 'Service Worker'),
                                React.createElement('div', { style: { fontSize: '24px', color: networkStats.serviceWorker ? '#4CAF50' : '#ff9800' } },
                                    networkStats.serviceWorker ? 'üîß Active' : '‚ö†Ô∏è Inactive'
                                ),
                                React.createElement('small', null, 'Enhanced local discovery')
                            ),
                            React.createElement('div', null,
                                React.createElement('h4', null, 'Data Throughput'),
                                React.createElement('div', { style: { fontSize: '24px', color: '#9c27b0' } },
                                    prayers.length * 8 + 'KB'
                                ),
                                React.createElement('small', null, 'Humanitarian data processed')
                            )
                        ),
                        recent.length > 0 && React.createElement('div', { style: { marginTop: '20px' } },
                            React.createElement('h4', null, 'Recent Performance Samples'),
                            React.createElement('div', { style: { fontSize: '12px', fontFamily: 'monospace', background: '#f5f5f5', padding: '10px', borderRadius: '5px', maxHeight: '150px', overflow: 'auto' } },
                                recent.map((sample, i) =>
                                    React.createElement('div', { key: i },
                                        new Date(sample.timestamp).toLocaleTimeString() + ': ' +
                                        sample.connections + 'c ' + sample.discoveredPeers + 'p Q' + ((sample.quality || 0) * 100).toFixed(0) + '% ' +
                                        (sample.serviceWorker ? 'üîßSW' : '‚ö†Ô∏èSW')
                                    )
                                )
                            )
                        )
                    )
                );
            }, [networkStats, showPerformance, prayers.length]);

            const userConfigCard = React.createElement('div', { className: 'card', style: { marginTop: '20px' } },
                React.createElement('h3', { style: { marginBottom: '15px', color: '#2c3e50' } }, 'üß≠ Bootstrap Configuration'),
                React.createElement('p', { style: { fontSize: '14px', color: '#555', marginBottom: '20px' } },
                    'Share optional IP or endpoint hints to help nearby volunteers connect faster. Provide your reachable address and a trusted neighbor to strengthen discovery.'
                ),
                React.createElement('div', { className: 'feature-grid' },
                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Your Node IP or Endpoint'),
                        React.createElement('input', {
                            type: 'text',
                            value: configDraft.nodeIp,
                            onChange: (e) => setConfigDraft(prev => ({ ...prev, nodeIp: e.target.value })),
                            placeholder: 'e.g. 203.0.113.10:3000 or https://node.example.com'
                        }),
                        React.createElement('small', { style: { display: 'block', marginTop: '8px', color: '#777' } },
                            'We will share this in announcements so others can reach you directly.'
                        )
                    ),
                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Neighbor Node IP or Endpoint'),
                        React.createElement('input', {
                            type: 'text',
                            value: configDraft.neighborIp,
                            onChange: (e) => setConfigDraft(prev => ({ ...prev, neighborIp: e.target.value })),
                            placeholder: 'e.g. 198.51.100.25:8080 or http://ally.example.net/peers'
                        }),
                        React.createElement('small', { style: { display: 'block', marginTop: '8px', color: '#777' } },
                            'Used as an additional rendezvous target during discovery cycles.'
                        )
                    )
                ),
                React.createElement('div', { className: 'network-controls', style: { marginTop: '20px' } },
                    React.createElement('button', {
                        onClick: handleConfigSave,
                        className: 'btn btn-secondary',
                        disabled: configSaving
                    },
                        configSaving ? React.createElement('span', { className: 'loading' }) : null,
                        configSaving ? ' Saving...' : 'üíæ Save Bootstrap Hints'
                    ),
                    React.createElement('button', {
                        onClick: handleConfigReset,
                        className: 'btn',
                        disabled: configSaving,
                        style: { background: '#666' }
                    }, 'üßπ Clear Hints')
                ),
                React.createElement('div', { style: { marginTop: '15px', fontSize: '12px', color: '#666' } },
                    userConfig.nodeIp || userConfig.neighborIp
                        ? `Active hints ‚Üí You: ${userConfig.nodeIp || '‚Äî'}${userConfig.neighborIp ? ' ‚Ä¢ Neighbor: ' + userConfig.neighborIp : ''}`
                        : 'No custom hints saved yet. The network will rely on default rendezvous nodes.'
                ),
                React.createElement('div', { style: { marginTop: '10px', fontSize: '11px', color: '#888' } },
                    'HTTPS pages will ignore insecure (http://) hints for safety.'
                )
            );

            // Show enhanced initialization screen
            if (!isNetworkReady) {
                return React.createElement('div', { className: 'container' },
                    networkStatusPanel,
                    React.createElement('div', { className: 'hero' },
                        React.createElement('h1', null, 'üåå Prayers, Saints & Saviors'),
                        React.createElement('p', null, 'Enhanced P2P Global Humanitarian Coordination Network with Service Worker Support'),
                        React.createElement('div', { 
                            style: { 
                                margin: '40px 0', 
                                fontSize: '1.2em', 
                                background: 'rgba(255,255,255,0.15)', 
                                padding: '30px', 
                                borderRadius: '20px',
                                backdropFilter: 'blur(10px)'
                            } 
                        },
                            React.createElement('div', { className: 'loading', style: { margin: '0 auto 25px' } }),
                            React.createElement('div', { style: { marginBottom: '15px' } }, initStatus),
                            React.createElement('div', { style: { fontSize: '0.9em', opacity: 0.8 } }, 
                                `Connection Quality: ${connectionQuality}`
                            )
                        ),
                        React.createElement('div', { className: 'network-controls' },
                            React.createElement('button', {
                                onClick: forceNetworkUpdate,
                                className: 'btn btn-secondary'
                            }, 'üîÑ Force Enhanced Sync'),
                            
                            React.createElement('button', {
                                onClick: emergencyNetworkReset,
                                className: 'btn',
                                style: { background: '#ff9800' }
                            }, '‚ö° Emergency Reset'),
                            
                            React.createElement('button', {
                                onClick: () => {
                                    console.log('üîç Enhanced Debug Info:');
                                    console.log('Network instance:', networkRef.current);
                                    console.log('Network stats:', networkRef.current ? networkRef.current.getNetworkStats() : 'No network');
                                    console.log('Ready state:', isNetworkReady);
                                    console.log('Init status:', initStatus);
                                    console.log('User consent:', userConsent);
                                    console.log('Service Worker ready:', networkRef.current ? networkRef.current.serviceWorkerReady : 'N/A');
                                },
                            className: 'btn',
                            style: { background: '#9c27b0' }
                        }, 'üî¨ Debug Console')
                    )
                ),
                userConfigCard,
                React.createElement('div', { className: 'card' },
                    React.createElement('h3', { style: { color: '#2c3e50' } }, 'üåê Enhanced Network Status'),
                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', null,
                                React.createElement('strong', null, 'Algorithm: '), 'Enhanced P2P v2.1'
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'Enhanced Links: '), networkStats.connections
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'Mesh Peers: '), networkStats.discoveredPeers
                            ),
                            React.createElement('div', null,
                                React.createElement('strong', null, 'Service Worker: '), networkStats.serviceWorker ? 'üîß Active' : '‚ö†Ô∏è Inactive'
                            )
                        ),
                        React.createElement('p', { style: { marginTop: '20px', fontSize: '14px', color: '#666' } },
                            'Your browser is becoming part of an enhanced mesh network that coordinates humanitarian aid globally using Service Workers, BroadcastChannel API, and enhanced P2P algorithms for superior local discovery between browser instances on the same network.'
                        )
                    )
                );
            }

            // Enhanced authentication screen
            if (!user) {
                return React.createElement('div', { className: 'container' },
                    networkStatusPanel,
                    React.createElement('div', { className: 'hero' },
                        React.createElement('h1', null, 'üåå Prayers, Saints & Saviors'),
                        React.createElement('p', null, 
                            'The world\'s first enhanced P2P humanitarian coordination network with Service Worker support for local discovery.'
                        ),
                        React.createElement('p', { style: { fontSize: '1em', opacity: 0.9 } },
                            'Your browser connects directly to a global enhanced mesh via WebRTC with Service Worker coordination.'
                        )
                    ),

                    userConfigCard,

                    React.createElement('div', { className: 'stats-bar' },
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.discoveredPeers || 0),
                            React.createElement('span', { className: 'stat-label' }, 'Enhanced Mesh Peers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.connections || 0),
                            React.createElement('span', { className: 'stat-label' }, 'Direct Enhanced Links')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, prayers.length),
                            React.createElement('span', { className: 'stat-label' }, 'Network Prayers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, 
                                networkStats.serviceWorker ? 'üîß' : '‚ö†Ô∏è'
                            ),
                            React.createElement('span', { className: 'stat-label' }, 'Service Worker')
                        )
                    ),

                    React.createElement('div', { className: 'auth-section' },
                        React.createElement('h2', { style: { marginBottom: '35px', color: '#2c3e50' } },
                            'üîê Join the Enhanced Mesh Network'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithEthereum,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null, 
                            'üîó Connect Ethereum Wallet'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithPasskey,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üîê Enhanced Biometric Auth'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInAnonymously,
                            className: 'btn btn-auth',
                            disabled: loading,
                            style: { background: 'linear-gradient(135deg, #6c757d 0%, #495057 100%)' }
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üë§ Anonymous Enhanced Session'
                        ),

                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üåå Enhanced Features'),
                            React.createElement('ul', { style: { marginLeft: '25px', lineHeight: '1.9' } },
                                React.createElement('li', null, React.createElement('strong', null, 'Service Worker Coordination'), ' - Background peer discovery and cross-tab sync'),
                                React.createElement('li', null, React.createElement('strong', null, 'BroadcastChannel API'), ' - Real-time cross-tab communication'),
                                React.createElement('li', null, React.createElement('strong', null, 'Enhanced WebRTC'), ' - Direct browser-to-browser enhanced channels'),
                                React.createElement('li', null, React.createElement('strong', null, 'Local Network Discovery'), ' - Find peers on same WiFi network'),
                                React.createElement('li', null, React.createElement('strong', null, 'Global Mesh Topology'), ' - Self-healing network with enhanced resilience'),
                                React.createElement('li', null, React.createElement('strong', null, 'Zero Infrastructure'), ' - Completely decentralized enhanced mesh')
                            )
                        )
                    )
                );
            }

            // Enhanced main application interface
            return React.createElement('div', { className: 'container' },
                networkStatusPanel,
                React.createElement('div', { className: 'hero' },
                    React.createElement('h1', null, 'üåå Prayers, Saints & Saviors'),
                    React.createElement('div', { style: { color: 'rgba(255,255,255,0.95)', display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '20px', flexWrap: 'wrap' } },
                        React.createElement('span', null, 'Welcome, ', React.createElement('strong', null, user.displayName)),
                        React.createElement('div', { style: { display: 'flex', gap: '10px' } },
                            React.createElement('button', {
                                onClick: signOut,
                                style: {
                                    background: 'rgba(255,255,255,0.15)', 
                                    border: '1px solid rgba(255,255,255,0.3)', color: 'white',
                                    padding: '8px 16px', borderRadius: '8px', cursor: 'pointer',
                                    fontSize: '14px', transition: 'all 0.3s'
                                }
                            }, '‚Üó Sign Out'),
                            
                            user.authMethod === 'anonymous' && React.createElement('span', {
                                style: {
                                    background: 'rgba(255, 193, 7, 0.2)', 
                                    border: '1px solid rgba(255, 193, 7, 0.5)', color: 'white',
                                    padding: '8px 16px', borderRadius: '8px',
                                    fontSize: '12px'
                                }
                            }, 'üë§ Anonymous Mode')
                        )
                    ),

                    React.createElement('div', { className: 'network-controls' },
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(true),
                            className: 'btn btn-secondary'
                        }, '‚ú® Share Enhanced Prayer'),
                        
                        React.createElement('button', {
                            onClick: toggleDebug,
                            className: 'btn',
                            style: { background: showDebug ? '#4CAF50' : '#666' }
                        }, 'üîç Enhanced Debug'),
                        
                        React.createElement('button', {
                            onClick: togglePerformance,
                            className: 'btn',
                            style: { background: showPerformance ? '#9c27b0' : '#666' }
                        }, 'üìä Performance'),
                        
                        React.createElement('button', {
                            onClick: forceNetworkUpdate,
                            className: 'btn',
                            style: { background: '#ff9800' }
                        }, 'üîÑ Sync Network'),
                        
                        React.createElement('button', {
                            onClick: () => {
                                if (networkRef.current) {
                                    const stats = networkRef.current.getNetworkStats();
                                    const routes = networkRef.current.routingTable.size;
                                    const peersInfo = Array.from(networkRef.current.discoveredPeers.entries())
                                        .map(([id, peer]) => `${id.substr(0, 8)}: dist=${peer.distance?.toFixed(2) || '‚àû'}`);
                                    
                                    alert(`üåå Enhanced Network Statistics:

Node ID: ${stats.nodeId}
Algorithm: ${stats.algorithm} v${stats.version}
Enhanced Links: ${stats.connections}
Mesh Peers: ${stats.discoveredPeers}
Routing Table: ${routes} entries
Quality: ${(stats.quality * 100).toFixed(1)}%
Service Worker: ${stats.serviceWorker ? 'Active üîß' : 'Inactive ‚ö†Ô∏è'}
Uptime: ${Math.floor(stats.uptime/60000)}m${Math.floor((stats.uptime%60000)/1000)}s
Features: ${stats.features?.join(', ') || 'N/A'}

Peer Routes:
${peersInfo.slice(0, 5).join('\n')}
${peersInfo.length > 5 ? '...' : ''}`);
                                }
                            },
                            className: 'btn',
                            style: { background: '#2196F3' }
                        }, 'üìä Enhanced Stats'),
                        
                        React.createElement('button', {
                            onClick: async () => {
                                if (networkRef.current) {
                                    const net = networkRef.current;
                                    console.log('üîß === ENHANCED NETWORK DIAGNOSTICS ===');
                                    console.log('Service Worker Ready:', net.serviceWorkerReady);
                                    console.log('SW Controller:', navigator.serviceWorker.controller ? 'Available' : 'Missing');
                                    console.log('SW Registration:', await navigator.serviceWorker.getRegistration());
                                    
                                    // Test Service Worker communication
                                    if (navigator.serviceWorker.controller) {
                                        const channel = new MessageChannel();
                                        navigator.serviceWorker.controller.postMessage({
                                            type: 'get_network_status'
                                        }, [channel.port2]);
                                        
                                        channel.port1.onmessage = (event) => {
                                            console.log('üîß SW Status Response:', event.data);
                                        };
                                    }
                                    
                                    // Test localStorage announcements
                                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements_v2') || '[]');
                                    console.log('üíæ Local Storage Announcements:', announcements.length);
                                    
                                    // Test BroadcastChannel
                                    try {
                                        const testChannel = new BroadcastChannel('pss_p2p_discovery_v2');
                                        testChannel.postMessage({ type: 'test', nodeId: net.nodeId });
                                        testChannel.close();
                                        console.log('üìª BroadcastChannel test sent');
                                    } catch (e) {
                                        console.log('‚ùå BroadcastChannel error:', e);
                                    }
                                    
                                    // Test Global Rendezvous
                                    const rendezvousTargets = net.getGlobalPeerEndpoints();
                                    const testEndpoint = rendezvousTargets.find(url => url.includes('185.187.243.129')) || rendezvousTargets[0];

                                    if (testEndpoint) {
                                        console.log(`üåç Testing Global Rendezvous (${testEndpoint})...`);
                                        try {
                                            const globalResponse = await fetch(testEndpoint, {
                                                method: 'GET',
                                                headers: { 'X-Network-Protocol': 'PSS-Enhanced-P2P' },
                                                signal: AbortSignal.timeout(5000)
                                            });

                                            if (globalResponse.ok) {
                                                const data = await globalResponse.json();
                                                console.log('üåç Global node response:', data);
                                            } else {
                                                console.log('‚ùå Global node responded with:', globalResponse.status);
                                            }
                                        } catch (e) {
                                            console.log('‚ùå Global node connection failed:', e.message);

                                            // Try backup endpoint
                                            try {
                                                const backupResponse = await fetch('https://httpbin.org/post', {
                                                    method: 'POST',
                                                    headers: { 'Content-Type': 'application/json' },
                                                    body: JSON.stringify({ type: 'connectivity_test', timestamp: Date.now() }),
                                                    signal: AbortSignal.timeout(3000)
                                                });
                                                console.log('üåê Backup endpoint reachable:', backupResponse.ok);
                                            } catch (e2) {
                                                console.log('‚ùå All external endpoints failed - network isolation detected');
                                            }
                                        }
                                    } else {
                                        console.log('‚ö†Ô∏è No rendezvous endpoints available for current protocol');
                                    }
                                    
                                    // Force announcement
                                    await net.announceToNetwork();
                                    console.log('üì° Forced network announcement with global fallback');
                                    
                                    // Global peer search
                                    await net.searchGlobalNode();
                                    console.log('üîç Executed global peer search');
                                    
                                    const stats = net.getNetworkStats();
                                    console.log('üìä Current Network Stats:', stats);
                                    
                                    alert('Enhanced diagnostics complete - check console for details');
                                }
                            },
                            className: 'btn',
                            style: { background: '#9c27b0' }
                        }, 'üîß SW Diagnostics')
                    )
                ),

                React.createElement('div', { className: 'stats-bar' },
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.discoveredPeers || 0),
                        React.createElement('span', { className: 'stat-label' }, 'Enhanced Mesh Peers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.connections || 0),
                        React.createElement('span', { className: 'stat-label' }, 'Direct Links')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, prayers.length),
                        React.createElement('span', { className: 'stat-label' }, 'Active Prayers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, 
                            networkStats.globalRendezvous ? 'üåç' : 'üîç'
                        ),
                        React.createElement('span', { className: 'stat-label' }, 'Global Network')
                    )
                ),

                userConfigCard,

                showDebug && React.createElement('div', { className: 'p2p-debug', style: { display: 'block' } },
                    React.createElement('div', { style: { color: '#fff', marginBottom: '15px', borderBottom: '1px solid #333', paddingBottom: '8px' } },
                        React.createElement('strong', null, 'üåå Real-Time Enhanced Debug Console'),
                        React.createElement('span', { style: { float: 'right', fontSize: '11px', opacity: 0.7 } }, 
                            `Enhanced P2P v${networkStats.version} ‚Ä¢ ${connectionQuality} Quality ‚Ä¢ ${networkStats.serviceWorker ? 'üîßSW Active' : '‚ö†Ô∏èSW Inactive'}`
                        )
                    ),
                    React.createElement('div', { id: 'debug-output' })
                ),

                performanceMetrics,

                showCreateForm && React.createElement('div', { className: 'card' },
                    React.createElement('h3', { style: { marginBottom: '30px', color: '#2c3e50' } }, 
                        '‚ú® Share Enhanced Prayer Request'
                    ),
                    
                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Title'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.title,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, title: e.target.value })),
                                placeholder: 'Brief description of your humanitarian need'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Category'),
                            React.createElement('select', {
                                value: newPrayer.category,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, category: e.target.value }))
                            },
                                React.createElement('option', { value: 'emergency' }, 'üö® Emergency'),
                                React.createElement('option', { value: 'health' }, 'üè• Health/Medical'),
                                React.createElement('option', { value: 'education' }, 'üìö Education'),
                                React.createElement('option', { value: 'housing' }, 'üè† Housing'),
                                React.createElement('option', { value: 'food' }, 'üçΩÔ∏è Food/Nutrition'),
                                React.createElement('option', { value: 'general' }, 'ü§ù General Help'),
                                React.createElement('option', { value: 'mental-health' }, 'üß† Mental Health'),
                                React.createElement('option', { value: 'disaster-relief' }, 'üå™Ô∏è Disaster Relief')
                            )
                        )
                    ),

                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Prayer Details'),
                        React.createElement('textarea', {
                            value: newPrayer.content, rows: 5,
                            onChange: (e) => setNewPrayer(prev => ({ ...prev, content: e.target.value })),
                            placeholder: 'Describe your situation and how others can help. This will be shared across the enhanced mesh network...'
                        })
                    ),

                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Location'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.location,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, location: e.target.value })),
                                placeholder: 'City, Country (optional)'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Urgency Level'),
                            React.createElement('select', {
                                value: newPrayer.urgency,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, urgency: e.target.value }))
                            },
                                React.createElement('option', { value: 'low' }, 'üü¢ Low - Can wait'),
                                React.createElement('option', { value: 'medium' }, 'üü° Medium - Within weeks'),
                                React.createElement('option', { value: 'high' }, 'üî¥ High - Urgent need'),
                                React.createElement('option', { value: 'critical' }, 'üö® Critical - Immediate')
                            )
                        )
                    ),

                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Estimated Need (USD, optional)'),
                            React.createElement('input', {
                                type: 'number', value: newPrayer.needsAmount, min: '0',
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, needsAmount: e.target.value })),
                                placeholder: '100'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Tags (comma-separated)'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.tags,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, tags: e.target.value })),
                                placeholder: 'medical, family, urgent'
                            })
                        )
                    ),

                    user.authMethod === 'ethereum' && React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Donation Wallet (auto-filled from your account)'),
                        React.createElement('input', {
                            type: 'text', value: user.address, readOnly: true,
                            style: { background: '#f0f0f0', color: '#666' }
                        })
                    ),

                    user.authMethod === 'anonymous' && React.createElement('div', { 
                        style: { 
                            background: '#fff3cd', padding: '15px', borderRadius: '8px', 
                            border: '1px solid #ffeaa7', margin: '20px 0' 
                        } 
                    },
                        React.createElement('div', { style: { color: '#d68910', fontWeight: '600' } },
                            '‚ö†Ô∏è Anonymous Mode Limitations'
                        ),
                        React.createElement('p', { style: { fontSize: '14px', marginTop: '5px', color: '#666' } },
                            'In anonymous mode, you cannot receive cryptocurrency donations. Consider connecting a wallet for full features.'
                        )
                    ),

                    React.createElement('div', { style: { display: 'flex', gap: '20px', marginTop: '30px' } },
                        React.createElement('button', {
                            onClick: submitPrayer, className: 'btn btn-secondary',
                            disabled: loading, style: { flex: 1 }
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üöÄ Broadcast to Enhanced Network'
                        ),
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(false), className: 'btn',
                            style: { flex: 1, background: '#666' }
                        }, '‚ùå Cancel')
                    )
                ),

                React.createElement('div', { style: { marginTop: '50px' } },
                    React.createElement('h2', { style: { color: 'white', marginBottom: '30px', textAlign: 'center' } },
                        'üåç Global Enhanced Prayer Network'
                    ),

                    prayers.length === 0 ? 
                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üå± Enhanced Network Initializing'),
                            React.createElement('p', null, 
                                'Be among the first to share a prayer request! Your browser is now connected to the ',
                                'enhanced global P2P humanitarian network with Service Worker support. As more nodes join, our enhanced ',
                                'algorithms will automatically route requests with superior local discovery and cross-browser coordination.'
                            )
                        ) :
                        prayers.map(prayer => 
                            React.createElement('div', {
                                key: prayer.id,
                                className: `card prayer-card ${prayer.urgency === 'high' || prayer.urgency === 'critical' ? 'prayer-urgent' : ''}`
                            },
                                React.createElement('div', { className: 'prayer-header' },
                                    React.createElement('div', { className: 'prayer-title' }, prayer.title),
                                    React.createElement('div', { className: 'prayer-distance' },
                                        prayer.authorAddress === (user.address || user.anonymousId) ? 
                                            'üîó Your Request' : 
                                            `üåå Via Enhanced Mesh ‚Ä¢ ${prayer.enhancedId ? prayer.enhancedId.substr(0, 12) + '...' : 'Global'}`
                                    )
                                ),
                                
                                React.createElement('div', { className: 'prayer-content' }, prayer.content),

                                prayer.tags && prayer.tags.length > 0 && React.createElement('div', {
                                    style: { margin: '15px 0' }
                                },
                                    prayer.tags.map(tag => 
                                        React.createElement('span', {
                                            key: tag,
                                            style: {
                                                background: '#e3f2fd', color: '#1976d2',
                                                padding: '4px 12px', borderRadius: '15px',
                                                fontSize: '12px', marginRight: '8px',
                                                display: 'inline-block', marginBottom: '5px'
                                            }
                                        }, `#${tag}`)
                                    )
                                ),

                                prayer.needsAmount && React.createElement('div', {
                                    style: { 
                                        background: 'linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%)', 
                                        padding: '15px 20px', borderRadius: '12px',
                                        marginBottom: '20px', fontSize: '15px', color: '#ef6c00',
                                        border: '1px solid #ffcc02'
                                    }
                                },
                                    React.createElement('strong', null, 'üí∞ Estimated Need: $' + prayer.needsAmount + ' USD'),
                                    prayer.walletAddress && React.createElement('div', { style: { fontSize: '12px', marginTop: '5px', opacity: 0.8 } },
                                        `Wallet: ${prayer.walletAddress.substring(0, 6)}...${prayer.walletAddress.substring(38)}`
                                    )
                                ),

                                React.createElement('div', { className: 'prayer-footer' },
                                    React.createElement('div', { style: { fontSize: '13px', color: '#666' } },
                                        'üìç ' + (prayer.location || 'Location not specified'),
                                        ' ‚Ä¢ by ' + prayer.author,
                                        ' ‚Ä¢ ' + prayer.category,
                                        prayer.urgency && ` ‚Ä¢ ${prayer.urgency} priority`,
                                        ' ‚Ä¢ ' + new Date(prayer.timestamp).toLocaleDateString(),
                                        prayer.enhanced && ' ‚Ä¢ ‚öõÔ∏è Enhanced'
                                    ),
                                    
                                    prayer.walletAddress && 
                                    prayer.authorAddress !== (user.address || user.anonymousId) && 
                                    user.authMethod === 'ethereum' && user.address &&
                                        React.createElement('button', {
                                            onClick: () => contributeToPrayer(prayer),
                                            className: 'btn',
                                            disabled: loading,
                                            style: { fontSize: '13px', padding: '10px 20px' }
                                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                                            'üíù Enhanced Contribute'
                                        )
                                )
                            )
                        )
                ),

                React.createElement('div', { className: 'network-info', style: { marginTop: '50px' } },
                    React.createElement('h4', null, 'üî¨ Enhanced Network Technology'),
                    React.createElement('p', null,
                        `Your browser is operating as an enhanced P2P node with ${networkStats.connections} direct WebRTC `,
                        `connections and ${networkStats.discoveredPeers} discovered peers in the global mesh. Using Service Workers `,
                        'and BroadcastChannel API, you\'re helping coordinate humanitarian aid with enhanced efficiency across ',
                        'the global internet, with superior local discovery for browsers on the same network.'
                    ),
                    React.createElement('div', { style: { marginTop: '20px', fontSize: '14px', opacity: 0.9 } },
                        `Network Quality: ${connectionQuality} (${((networkStats.quality || 0) * 100).toFixed(1)}%) ‚Ä¢ `,
                        `Algorithm: ${networkStats.algorithm} v${networkStats.version} ‚Ä¢ `,
                        `Service Worker: ${networkStats.serviceWorker ? 'üîß Active' : '‚ö†Ô∏è Inactive'} ‚Ä¢ `,
                        `Uptime: ${Math.floor((networkStats.uptime || 0) / 60000)}m`
                    )
                ),

                React.createElement('footer', { style: { textAlign: 'center', padding: '50px 0', color: 'rgba(255,255,255,0.8)' } },
                    React.createElement('p', { style: { fontSize: '16px' } }, 
                        'Built with ‚ù§Ô∏è using Enhanced Global P2P WebRTC with Service Worker Support ‚Ä¢ Powered by your browser'
                    ),
                    React.createElement('p', { style: { fontSize: '13px', marginTop: '15px', opacity: 0.7 } },
                        'Decentralized ‚Ä¢ Zero-Infrastructure ‚Ä¢ Enhanced WebRTC Mesh ‚Ä¢ Service Worker Coordination ‚Ä¢ Local Discovery ‚Ä¢ Censorship-Resistant'
                    ),
                    React.createElement('p', { style: { fontSize: '12px', marginTop: '10px', opacity: 0.6 } },
                        `Network: ${networkStats.algorithm} v${networkStats.version} ‚Ä¢ Node: ${networkStats.nodeId?.substr(0, 16)}... ‚Ä¢ SW: ${networkStats.serviceWorker ? 'Active' : 'Inactive'} ‚Ä¢ Q: ${((networkStats.quality || 0) * 100).toFixed(0)}%`
                    )
                )
            );
        }

        // Initialize the enhanced complete application after consent
        window.initializeCompleteApplication = function() {
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(React.createElement(EnhancedCompleteApplication));
        };
    </script>
</body>
</html>
