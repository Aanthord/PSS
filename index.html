<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prayers, Saints & Saviors - Complete Production Network</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
    <script src="https://unpkg.com/crypto-js@latest/crypto-js.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Suppress Babel development warnings -->
    <script>
        // Suppress Babel transformer warning for production
        if (window.Babel) {
            const originalWarn = console.warn;
            console.warn = function(...args) {
                if (args[0] && typeof args[0] === 'string' && 
                    args[0].includes('in-browser Babel transformer')) {
                    return; // Suppress Babel warning
                }
                originalWarn.apply(console, args);
            };
        }
    </script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        /* Opt-in Modal Styles */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.95); z-index: 10000; display: flex;
            align-items: center; justify-content: center; padding: 20px;
            backdrop-filter: blur(5px);
        }
        .modal-content {
            background: white; border-radius: 20px; max-width: 600px; width: 100%;
            max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { opacity: 0; transform: translateY(30px) scale(0.95); }
            to { opacity: 1; transform: translateY(0) scale(1); }
        }
        .modal-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; padding: 30px; border-radius: 20px 20px 0 0; text-align: center;
        }
        .modal-header h2 { font-size: 28px; margin-bottom: 10px; }
        .modal-header p { opacity: 0.9; font-size: 16px; }
        .modal-body { padding: 30px; }
        .risk-section {
            background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 10px;
            padding: 20px; margin: 20px 0; border-left: 4px solid #f39c12;
        }
        .risk-section h4 { color: #d68910; margin-bottom: 10px; display: flex; align-items: center; }
        .risk-section h4::before { content: '‚ö†Ô∏è'; margin-right: 8px; }
        .consent-item {
            display: flex; align-items: flex-start; margin: 15px 0; padding: 15px;
            background: #f8f9fa; border-radius: 8px; border-left: 3px solid #007bff;
        }
        .consent-item input[type="checkbox"] {
            margin-right: 12px; margin-top: 2px; width: 18px; height: 18px;
            accent-color: #007bff;
        }
        .consent-item label { font-size: 14px; line-height: 1.5; cursor: pointer; }
        .consent-item label strong { color: #2c3e50; }
        .modal-actions {
            display: flex; gap: 15px; margin-top: 30px; padding: 20px;
            background: #f8f9fa; border-radius: 0 0 20px 20px;
        }
        .modal-btn {
            flex: 1; padding: 15px 25px; border: none; border-radius: 10px;
            font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s;
            text-transform: uppercase; letter-spacing: 0.5px;
        }
        .modal-btn-decline {
            background: #dc3545; color: white;
        }
        .modal-btn-decline:hover { background: #c82333; transform: translateY(-2px); }
        .modal-btn-accept {
            background: #28a745; color: white;
        }
        .modal-btn-accept:hover { background: #218838; transform: translateY(-2px); }
        .modal-btn-accept:disabled {
            background: #6c757d; cursor: not-allowed; transform: none;
        }
        .tos-link {
            color: #007bff; text-decoration: none; font-weight: 600;
        }
        .tos-link:hover { text-decoration: underline; }
        .tech-details {
            background: #e8f4fd; border: 1px solid #b8daff; border-radius: 8px;
            padding: 15px; margin: 15px 0; font-size: 13px; line-height: 1.4;
        }
        .tech-details h5 { color: #0056b3; margin-bottom: 8px; }
        
        /* Hide main content until consent given */
        .main-content { display: none; }
        .main-content.show { display: block; }
        
        /* Enhanced Network Status */
        .network-status {
            position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.9); color: white;
            padding: 15px; border-radius: 8px; font-size: 11px; font-family: monospace;
            z-index: 1000; border: 1px solid #4CAF50; min-width: 220px;
        }
        .network-status .peer-list {
            margin-top: 10px; max-height: 150px; overflow-y: auto;
        }
        .peer-item {
            display: flex; justify-content: space-between; padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }
        .connection-status {
            display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-left: 8px;
        }
        .connection-status.connected { background: #4CAF50; animation: pulse 2s infinite; }
        .connection-status.connecting { background: #ff9800; animation: blink 1s infinite; }
        .connection-status.disconnected { background: #f44336; }
        
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0.3; } }
        
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .card {
            background: white; border-radius: 15px; padding: 25px; margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15); transition: transform 0.3s;
        }
        .card:hover { transform: translateY(-5px); }
        .prayer-card {
            border-left: 4px solid #4CAF50; position: relative; overflow: hidden;
        }
        .prayer-urgent { border-left-color: #f44336; animation: pulse 3s infinite; }
        .prayer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
        .prayer-title { font-weight: 600; font-size: 18px; color: #2c3e50; }
        .prayer-distance {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); color: #1976d2;
            padding: 6px 12px; border-radius: 20px; font-size: 11px; font-weight: 500;
        }
        .prayer-content { color: #555; line-height: 1.6; margin-bottom: 20px; }
        .prayer-footer {
            display: flex; justify-content: space-between; align-items: center;
            padding-top: 15px; border-top: 1px solid #eee;
        }
        .btn {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%); color: white;
            border: none; padding: 12px 24px; border-radius: 25px; cursor: pointer;
            font-weight: 600; font-size: 14px; transition: all 0.3s; text-decoration: none;
            display: inline-block; text-align: center;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        .btn-secondary {
            background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
        }
        .btn-auth {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-size: 16px; padding: 15px 30px; margin: 10px;
        }
        .auth-section {
            background: white; padding: 40px; border-radius: 20px; text-align: center;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1); max-width: 500px; margin: 50px auto;
        }
        .form-group { margin-bottom: 20px; text-align: left; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 600; color: #333; }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%; padding: 15px; border: 2px solid #e0e0e0; border-radius: 10px;
            font-size: 14px; transition: border-color 0.3s; background: #f9f9f9;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none; border-color: #4CAF50; background: white;
        }
        .network-info {
            background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2); border-radius: 15px;
            padding: 25px; margin: 30px 0; color: white;
        }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 30px 0; }
        .loading { display: inline-block; width: 20px; height: 20px; border: 2px solid #f3f3f3; border-top: 2px solid #4CAF50; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .peer-indicator { 
            display: inline-block; width: 8px; height: 8px; background: #4CAF50; 
            border-radius: 50%; margin-left: 8px; animation: pulse 2s infinite; 
        }
        .hero { text-align: center; padding: 60px 0 40px; color: white; }
        .hero h1 { font-size: 3.5em; margin-bottom: 20px; font-weight: 700; text-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        .hero p { font-size: 1.3em; opacity: 0.9; max-width: 800px; margin: 0 auto 40px; }
        .stats-bar {
            display: flex; justify-content: space-around; background: rgba(255,255,255,0.1);
            border-radius: 15px; padding: 20px; margin: 30px 0; backdrop-filter: blur(10px);
        }
        .stat { text-align: center; color: white; }
        .stat-value { font-size: 2em; font-weight: 700; display: block; }
        .stat-label { font-size: 0.9em; opacity: 0.8; }
        .toast {
            position: fixed; bottom: 20px; right: 20px; background: #4CAF50; color: white;
            padding: 15px 25px; border-radius: 10px; z-index: 1001; transform: translateX(400px);
            transition: transform 0.3s; box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .toast.show { transform: translateX(0); }
        
        .p2p-debug {
            background: rgba(0,0,0,0.8); color: #0f0; font-family: monospace; font-size: 11px;
            padding: 15px; border-radius: 8px; margin: 20px 0; max-height: 200px; overflow-y: auto;
            border: 1px solid #333; display: none;
        }
        .debug-line { margin: 2px 0; }
        .debug-error { color: #f44; }
        .debug-success { color: #4f4; }
        .debug-info { color: #44f; }
        
        .network-controls {
            display: flex; gap: 10px; margin: 20px 0; flex-wrap: wrap;
        }
        .network-controls .btn {
            padding: 8px 16px; font-size: 12px; margin: 0;
        }
    </style>
</head>
<body>
    <!-- Opt-in Consent Modal -->
    <div id="consent-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üôè Welcome to Prayers, Saints & Saviors</h2>
                <p>Join the world's first truly decentralized humanitarian network</p>
            </div>
            
            <div class="modal-body">
                <p style="margin-bottom: 20px; line-height: 1.6;">
                    Before joining our global P2P network, please read and understand what you're agreeing to. 
                    Your browser will become part of a distributed humanitarian infrastructure.
                </p>

                <div class="risk-section">
                    <h4>Important Risk Disclosures</h4>
                    <ul style="margin-left: 20px; line-height: 1.6;">
                        <li><strong>Experimental Technology:</strong> This uses WebRTC P2P networking and experimental algorithms with unknown risks.</li>
                        <li><strong>Global Connections:</strong> Your browser will connect directly to other users worldwide via WebRTC data channels.</li>
                        <li><strong>Cryptocurrency Risk:</strong> You may handle irreversible cryptocurrency transactions at your own risk.</li>
                        <li><strong>No Guarantees:</strong> No warranties regarding security, reliability, or data persistence.</li>
                        <li><strong>Resource Usage:</strong> Your browser will use CPU, memory, and network resources for the P2P network.</li>
                    </ul>
                </div>

                <div class="tech-details">
                    <h5>üî¨ Technical Implementation</h5>
                    <p>
                        Your browser will run: <strong>FT-DFRP routing protocols</strong>, WebRTC peer connections,
                        Service Workers for persistence, IndexedDB storage, STUN/TURN NAT traversal, and cross-subnet
                        mesh networking with O(‚àön log n) complexity humanitarian coordination algorithms.
                    </p>
                </div>

                <div style="margin: 20px 0; padding: 20px; background: #f0f8ff; border-radius: 8px; border: 1px solid #007bff;">
                    <h4 style="color: #007bff; margin-bottom: 10px;">üìÑ Terms of Service</h4>
                    <p style="margin-bottom: 10px;">
                        By proceeding, you agree to our complete Terms of Service and Privacy Policy:
                    </p>
                    <a href="https://aunthood.github.io/PSS/terms-of-service.html" target="_blank" class="tos-link">
                        üìã Read Complete Terms of Service
                    </a>
                    <p style="margin-top: 10px; font-size: 13px; color: #666;">
                        <em>Strongly recommended: Read full terms before proceeding.</em>
                    </p>
                </div>

                <h4 style="margin: 25px 0 15px 0; color: #2c3e50;">‚úÖ Required Consents</h4>
                
                <div class="consent-item">
                    <input type="checkbox" id="consent-tos" />
                    <label for="consent-tos">
                        <strong>Terms of Service:</strong> I have read and agree to the Terms of Service 
                        and understand this is experimental P2P technology with inherent risks.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-p2p" />
                    <label for="consent-p2p">
                        <strong>Global P2P Network:</strong> I consent to my browser connecting directly 
                        to other users worldwide via WebRTC and participating in mesh networking.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-browser" />
                    <label for="consent-browser">
                        <strong>Browser Infrastructure:</strong> I consent to my browser using system 
                        resources and storing distributed humanitarian data locally.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-crypto" />
                    <label for="consent-crypto">
                        <strong>Cryptocurrency Risks:</strong> I understand cryptocurrency transactions 
                        are irreversible and I'm responsible for my wallet security.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-data" />
                    <label for="consent-data">
                        <strong>Data & Privacy:</strong> I understand prayer requests are distributed 
                        globally and I won't include sensitive personal information.
                    </label>
                </div>

                <div class="consent-item">
                    <input type="checkbox" id="consent-volunteer" />
                    <label for="consent-volunteer">
                        <strong>Voluntary Participation:</strong> I'm participating voluntarily and 
                        understand I can exit by closing my browser at any time.
                    </label>
                </div>

                <div style="margin-top: 25px; padding: 15px; background: #e8f5e8; border-radius: 8px; border: 1px solid #4CAF50;">
                    <p style="font-size: 14px; line-height: 1.5; color: #2e7d32;">
                        <strong>üåü By joining:</strong> You become part of a global P2P humanitarian network. 
                        Your browser helps route aid efficiently using revolutionary FT-DFRP algorithms while 
                        maintaining privacy and decentralization. Together, we build a more compassionate world.
                    </p>
                </div>
            </div>

            <div class="modal-actions">
                <button class="modal-btn modal-btn-decline" onclick="declineTerms()">
                    ‚ùå Decline & Exit
                </button>
                <button class="modal-btn modal-btn-accept" id="accept-btn" onclick="acceptTerms()" disabled>
                    ‚úÖ Accept & Join Network
                </button>
            </div>
        </div>
    </div>

    <!-- Main Application Content -->
    <div id="root" class="main-content">
        <!-- Enhanced Network Status -->
        <div class="network-status">
            <div id="network-title">üåê Global P2P Network</div>
            <div id="network-stats">Initializing...</div>
            <div id="peer-list" class="peer-list"></div>
        </div>
    </div>

    <!-- Consent Modal Logic -->
    <script>
        // Global consent state
        let userConsent = false;
        
        // Check if user has previously given consent (within 30 days)
        function checkExistingConsent() {
            try {
                const consent = localStorage.getItem('pss_user_consent');
                if (consent) {
                    const consentData = JSON.parse(consent);
                    const thirtyDaysMs = 30 * 24 * 60 * 60 * 1000;
                    
                    if (Date.now() - consentData.timestamp < thirtyDaysMs && consentData.version === '1.0') {
                        return true;
                    }
                }
            } catch (error) {
                console.error('Error checking existing consent:', error);
            }
            return false;
        }
        
        // Monitor checkbox changes to enable/disable accept button
        function updateAcceptButton() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-browser', 
                'consent-crypto', 'consent-data', 'consent-volunteer'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id).checked
            );
            
            const acceptBtn = document.getElementById('accept-btn');
            acceptBtn.disabled = !allChecked;
            
            if (allChecked) {
                acceptBtn.style.background = '#28a745';
                acceptBtn.style.cursor = 'pointer';
            } else {
                acceptBtn.style.background = '#6c757d';
                acceptBtn.style.cursor = 'not-allowed';
            }
        }
        
        // Accept terms and initialize network
        function acceptTerms() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-browser', 
                'consent-crypto', 'consent-data', 'consent-volunteer'
            ];
            
            const allChecked = checkboxes.every(id => 
                document.getElementById(id).checked
            );
            
            if (!allChecked) {
                alert('Please check all required consent boxes before proceeding.');
                return;
            }
            
            // Store consent with timestamp and version
            const consentData = {
                timestamp: Date.now(),
                version: '1.0',
                userAgent: navigator.userAgent,
                consents: {
                    tos: true, p2p: true, browser: true,
                    crypto: true, data: true, volunteer: true
                }
            };
            
            try {
                localStorage.setItem('pss_user_consent', JSON.stringify(consentData));
                userConsent = true;
                
                // Hide modal and show main content
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                
                // Initialize the complete application
                initializeCompleteApplication();
                
                console.log('User consent granted, initializing complete network...');
                
            } catch (error) {
                console.error('Failed to store consent:', error);
                alert('Failed to store consent. Please try again.');
            }
        }
        
        // Decline terms and redirect away
        function declineTerms() {
            if (confirm('Are you sure you want to decline? You will be redirected away from this site.')) {
                try {
                    localStorage.removeItem('pss_user_consent');
                    localStorage.removeItem('prayers_user');
                    // Clear any network data
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('prayers_') || key.startsWith('network_') || key.startsWith('p2p_'))) {
                            localStorage.removeItem(key);
                        }
                    }
                } catch (error) {
                    console.error('Error clearing data:', error);
                }
                
                window.location.href = 'https://www.un.org/en/humanitarian-action';
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            const checkboxes = [
                'consent-tos', 'consent-p2p', 'consent-browser', 
                'consent-crypto', 'consent-data', 'consent-volunteer'
            ];
            
            checkboxes.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', updateAcceptButton);
                }
            });
            
            // Check for existing consent
            if (checkExistingConsent()) {
                userConsent = true;
                document.getElementById('consent-modal').style.display = 'none';
                document.getElementById('root').classList.add('show');
                initializeCompleteApplication();
            } else {
                updateAcceptButton();
            }
        });
        
        // Prevent any operations without consent
        function requireConsent() {
            if (!userConsent) {
                throw new Error('User consent required before network operations');
            }
        }
    </script>

    <!-- Service Worker Registration with Fallback -->
    <script>
        function registerServiceWorkerWithFallback() {
            requireConsent();
            
            const isSecureContext = window.location.protocol === 'https:' || 
                                  window.location.protocol === 'http:' || 
                                  window.location.hostname === 'localhost' ||
                                  window.location.hostname === '127.0.0.1';
            
            if (!isSecureContext || window.location.protocol === 'file:') {
                console.log('Service Workers require HTTP/HTTPS. Running in fallback mode.');
                return;
            }
            
            if ('serviceWorker' in navigator) {
                // Try separate service worker file first
                navigator.serviceWorker.register('./sw.js')
                    .then(registration => {
                        console.log('‚úÖ Service Worker registered successfully');
                        if ('sync' in registration) {
                            registration.sync.register('peer-discovery');
                        }
                    })
                    .catch(error => {
                        console.log('Separate SW file not found, using fallback');
                        // Inline service worker fallback would go here
                    });
            }
        }
    </script>

    <!-- Complete Application with All Features -->
    <script type="text/babel">
        // Global P2P Network with Complete Integration
        class CompleteP2PNetwork {
            constructor() {
                requireConsent();
                
                this.nodeId = 'node_' + Math.random().toString(36).substr(2, 12);
                this.peer = null;
                this.connections = new Map();
                this.discoveredPeers = new Map();
                this.prayers = new Map();
                this.vector = new Array(8).fill(0).map(() => Math.random() * 2 - 1);
                this.startTime = Date.now();
                this.isOnline = false;
                this.debugMode = false;
                this.eventListeners = new Map();
                
                this.stunServers = [
                    'stun:stun.l.google.com:19302',
                    'stun:stun1.l.google.com:19302',
                    'stun:stun2.l.google.com:19302',
                    'stun:stun.ekiga.net',
                    'stun:stun.ideasip.com'
                ];
                
                console.log('üåê Complete P2P Network initialized');
            }

            async initialize() {
                try {
                    this.debug('üöÄ Initializing Complete Global P2P Network...', 'info');
                    
                    this.peer = new Peer(this.nodeId, {
                        config: {
                            iceServers: this.stunServers.map(url => ({ urls: url }))
                        },
                        debug: this.debugMode ? 2 : 0
                    });
                    
                    this.setupPeerEvents();
                    this.startPeerDiscovery();
                    this.startHeartbeat();
                    
                    this.isOnline = true;
                    this.emit('networkReady', { nodeId: this.nodeId });
                    
                } catch (error) {
                    this.debug('‚ùå Failed to initialize network: ' + error.message, 'error');
                    console.error('Network initialization failed:', error);
                }
            }
            
            setupPeerEvents() {
                this.peer.on('open', (id) => {
                    this.debug(\`üÜî Peer ID: \${id}\`, 'success');
                    this.nodeId = id;
                    this.announceToNetwork();
                });
                
                this.peer.on('connection', (conn) => {
                    this.debug(\`üìû Incoming connection: \${conn.peer}\`, 'info');
                    this.handleNewConnection(conn);
                });
                
                this.peer.on('error', (error) => {
                    this.debug(\`‚ùå Peer error: \${error.message}\`, 'error');
                });
            }
            
            handleNewConnection(conn) {
                conn.on('open', () => {
                    this.debug(\`‚úÖ Connected to: \${conn.peer}\`, 'success');
                    this.connections.set(conn.peer, conn);
                    this.sendHandshake(conn);
                    this.emit('peerConnected', { peerId: conn.peer });
                });
                
                conn.on('data', (data) => {
                    this.handlePeerMessage(conn.peer, data);
                });
                
                conn.on('close', () => {
                    this.debug(\`üîå Connection closed: \${conn.peer}\`, 'info');
                    this.connections.delete(conn.peer);
                    this.emit('peerDisconnected', { peerId: conn.peer });
                });
            }
            
            sendHandshake(conn) {
                conn.send({
                    type: 'HANDSHAKE',
                    nodeId: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now()
                });
            }
            
            handlePeerMessage(peerId, data) {
                this.debug(\`üì® Message from \${peerId}: \${data.type}\`, 'info');
                
                switch (data.type) {
                    case 'HANDSHAKE':
                        this.discoveredPeers.set(peerId, {
                            id: peerId,
                            vector: data.vector,
                            lastSeen: Date.now(),
                            connected: true
                        });
                        break;
                        
                    case 'PRAYER_ANNOUNCEMENT':
                        this.handlePrayerReceived(data.prayer);
                        break;
                }
                
                this.emit('peerMessage', { peerId, data });
            }
            
            handlePrayerReceived(prayer) {
                this.prayers.set(prayer.id, prayer);
                this.debug(\`üìø Prayer received: \${prayer.title}\`, 'success');
                
                try {
                    const prayers = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    prayers[prayer.id] = prayer;
                    localStorage.setItem('network_prayers', JSON.stringify(prayers));
                } catch (error) {
                    console.warn('Failed to persist prayer:', error);
                }
                
                this.emit('prayerReceived', prayer);
                this.showToast('üôè New prayer received from global network');
            }
            
            async announceToNetwork() {
                const announcement = {
                    nodeId: this.nodeId,
                    vector: this.vector,
                    timestamp: Date.now()
                };
                
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                    announcements.push(announcement);
                    
                    if (announcements.length > 50) {
                        announcements.splice(0, announcements.length - 50);
                    }
                    
                    localStorage.setItem('p2p_announcements', JSON.stringify(announcements));
                    this.debug('üì¢ Announced to network', 'success');
                    
                } catch (error) {
                    this.debug('‚ùå Failed to announce: ' + error.message, 'error');
                }
            }
            
            async startPeerDiscovery() {
                await this.discoverPeers();
                
                setInterval(() => {
                    this.discoverPeers();
                    this.cleanupStaleData();
                }, 15000);
            }
            
            async discoverPeers() {
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                    const now = Date.now();
                    const maxAge = 5 * 60 * 1000;
                    
                    for (const announcement of announcements) {
                        if (now - announcement.timestamp < maxAge && 
                            announcement.nodeId !== this.nodeId &&
                            !this.connections.has(announcement.nodeId)) {
                            
                            await this.connectToPeer(announcement.nodeId);
                        }
                    }
                } catch (error) {
                    this.debug('‚ùå Peer discovery error: ' + error.message, 'error');
                }
            }
            
            async connectToPeer(peerId) {
                if (peerId === this.nodeId || this.connections.has(peerId)) {
                    return;
                }
                
                try {
                    this.debug(\`üìû Connecting to: \${peerId}\`, 'info');
                    const conn = this.peer.connect(peerId);
                    this.handleNewConnection(conn);
                } catch (error) {
                    this.debug(\`‚ùå Failed to connect: \${error.message}\`, 'error');
                }
            }
            
            cleanupStaleData() {
                const now = Date.now();
                const maxAge = 5 * 60 * 1000;
                
                for (const [peerId, peer] of this.discoveredPeers.entries()) {
                    if (now - peer.lastSeen > maxAge) {
                        this.discoveredPeers.delete(peerId);
                    }
                }
                
                try {
                    const announcements = JSON.parse(localStorage.getItem('p2p_announcements') || '[]');
                    const fresh = announcements.filter(a => now - a.timestamp < maxAge);
                    localStorage.setItem('p2p_announcements', JSON.stringify(fresh));
                } catch (error) {
                    console.warn('Cleanup failed:', error);
                }
            }
            
            broadcastPrayer(prayer) {
                if (this.connections.size === 0) {
                    this.debug('‚ùå No connections for broadcast', 'error');
                    return false;
                }
                
                const message = {
                    type: 'PRAYER_ANNOUNCEMENT',
                    prayer: prayer,
                    timestamp: Date.now(),
                    sender: this.nodeId
                };
                
                let broadcastCount = 0;
                for (const [peerId, conn] of this.connections.entries()) {
                    try {
                        conn.send(message);
                        broadcastCount++;
                        this.debug(\`üì° Sent to: \${peerId}\`, 'success');
                    } catch (error) {
                        this.debug(\`‚ùå Failed to send: \${error.message}\`, 'error');
                    }
                }
                
                this.debug(\`üì¢ Broadcast to \${broadcastCount} peers\`, 'success');
                return broadcastCount > 0;
            }
            
            async storePrayer(prayer) {
                this.prayers.set(prayer.id, prayer);
                
                // Store locally
                try {
                    const prayers = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    prayers[prayer.id] = prayer;
                    localStorage.setItem('network_prayers', JSON.stringify(prayers));
                } catch (error) {
                    console.warn('Failed to store prayer:', error);
                }
                
                // Broadcast to network
                const success = this.broadcastPrayer(prayer);
                this.emit('prayerStored', prayer);
                
                return success;
            }
            
            getStoredPrayers() {
                const prayers = [];
                
                // Get from memory
                prayers.push(...Array.from(this.prayers.values()));
                
                // Get from localStorage
                try {
                    const stored = JSON.parse(localStorage.getItem('network_prayers') || '{}');
                    Object.values(stored).forEach(prayer => {
                        if (!this.prayers.has(prayer.id)) {
                            prayers.push(prayer);
                        }
                    });
                } catch (error) {
                    console.warn('Failed to load stored prayers:', error);
                }
                
                return prayers.sort((a, b) => b.timestamp - a.timestamp);
            }
            
            startHeartbeat() {
                setInterval(() => {
                    for (const [peerId, conn] of this.connections.entries()) {
                        try {
                            conn.send({
                                type: 'NETWORK_HEARTBEAT',
                                nodeId: this.nodeId,
                                timestamp: Date.now()
                            });
                        } catch (error) {
                            this.debug(\`‚ùå Heartbeat failed: \${peerId}\`, 'error');
                        }
                    }
                    
                    this.emit('heartbeat', this.getNetworkStats());
                }, 30000);
            }
            
            getNetworkStats() {
                return {
                    nodeId: this.nodeId,
                    isOnline: this.isOnline,
                    connections: this.connections.size,
                    discoveredPeers: this.discoveredPeers.size,
                    prayers: this.prayers.size,
                    uptime: Date.now() - this.startTime
                };
            }
            
            debug(message, type = 'info') {
                if (!this.debugMode) return;
                
                const debugOutput = document.getElementById('debug-output');
                if (debugOutput) {
                    const timestamp = new Date().toLocaleTimeString();
                    const logLine = document.createElement('div');
                    logLine.className = \`debug-line debug-\${type}\`;
                    logLine.textContent = \`[\${timestamp}] \${message}\`;
                    
                    debugOutput.appendChild(logLine);
                    debugOutput.scrollTop = debugOutput.scrollHeight;
                    
                    while (debugOutput.children.length > 100) {
                        debugOutput.removeChild(debugOutput.firstChild);
                    }
                }
            }
            
            showToast(message, duration = 3000) {
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = message;
                document.body.appendChild(toast);
                
                setTimeout(() => toast.classList.add('show'), 100);
                setTimeout(() => {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (document.body.contains(toast)) {
                            document.body.removeChild(toast);
                        }
                    }, 300);
                }, duration);
            }
            
            // Event system
            on(event, callback) {
                if (!this.eventListeners.has(event)) {
                    this.eventListeners.set(event, []);
                }
                this.eventListeners.get(event).push(callback);
            }
            
            emit(event, data) {
                const listeners = this.eventListeners.get(event);
                if (listeners) {
                    listeners.forEach(callback => callback(data));
                }
            }
        }

        // Decentralized Authentication
        class DecentralizedAuth {
            constructor() {
                requireConsent();
                this.web3 = null;
                this.initializeWeb3();
            }

            async initializeWeb3() {
                if (typeof window.ethereum !== 'undefined') {
                    this.web3 = new Web3(window.ethereum);
                }
            }

            async signInWithEthereum(address) {
                requireConsent();
                
                if (!this.web3) await this.initializeWeb3();
                
                const domain = window.location.hostname;
                const message = \`\${domain} wants you to sign in with your Ethereum account:
\${address}

Join the decentralized humanitarian network - Prayers, Saints & Saviors

URI: \${window.location.origin}
Version: 1
Chain ID: \${await this.web3.eth.getChainId()}
Nonce: \${Math.random().toString(36).substring(2, 15)}
Issued At: \${new Date().toISOString()}\`;

                const signature = await this.web3.eth.personal.sign(message, address);
                
                let ensName = null;
                try {
                    ensName = await this.web3.eth.ens.reverse(address);
                } catch (e) {}

                return {
                    address,
                    ensName,
                    displayName: ensName || \`\${address.substring(0, 6)}...\${address.substring(38)}\`,
                    avatar: \`https://api.dicebear.com/7.x/identicon/svg?seed=\${address}\`,
                    signature,
                    message,
                    verified: true,
                    authMethod: 'ethereum',
                    timestamp: Date.now()
                };
            }

            async signInWithPasskey() {
                requireConsent();
                
                if (!window.PublicKeyCredential) throw new Error('WebAuthn not supported');

                const credentialId = localStorage.getItem('prayers_credential_id');
                let credential;

                if (credentialId) {
                    credential = await navigator.credentials.get({
                        publicKey: {
                            challenge: crypto.getRandomValues(new Uint8Array(32)),
                            allowCredentials: [{
                                id: Uint8Array.from(atob(credentialId), c => c.charCodeAt(0)),
                                type: 'public-key'
                            }]
                        }
                    });
                } else {
                    credential = await navigator.credentials.create({
                        publicKey: {
                            challenge: crypto.getRandomValues(new Uint8Array(32)),
                            rp: { name: 'Prayers Saints Saviors' },
                            user: {
                                id: crypto.getRandomValues(new Uint8Array(16)),
                                name: 'Anonymous User',
                                displayName: 'Anonymous User'
                            },
                            pubKeyCredParams: [{ alg: -7, type: 'public-key' }]
                        }
                    });
                    localStorage.setItem('prayers_credential_id', btoa(String.fromCharCode(...new Uint8Array(credential.rawId))));
                }

                return {
                    credentialId: btoa(String.fromCharCode(...new Uint8Array(credential.rawId))),
                    displayName: 'Anonymous User',
                    avatar: \`https://api.dicebear.com/7.x/avataaars/svg?seed=\${credential.id}\`,
                    verified: true,
                    authMethod: 'passkey',
                    timestamp: Date.now()
                };
            }
        }

        // Complete React Application
        function CompleteApplication() {
            const { useState, useEffect, useCallback, useMemo } = React;

            const [user, setUser] = useState(null);
            const [network, setNetwork] = useState(null);
            const [auth, setAuth] = useState(null);
            const [prayers, setPrayers] = useState([]);
            const [networkStats, setNetworkStats] = useState({ 
                connections: 0, discoveredPeers: 0, prayers: 0, isOnline: false, uptime: 0 
            });
            const [showCreateForm, setShowCreateForm] = useState(false);
            const [showDebug, setShowDebug] = useState(false);
            const [loading, setLoading] = useState(false);
            const [newPrayer, setNewPrayer] = useState({
                title: '', content: '', location: '', urgency: 'medium',
                category: 'general', needsAmount: '', walletAddress: ''
            });

            // Initialize everything
            useEffect(() => {
                if (!userConsent) return;
                
                const initializeEverything = async () => {
                    try {
                        // Initialize auth
                        const authSystem = new DecentralizedAuth();
                        setAuth(authSystem);
                        
                        // Initialize network
                        const networkSystem = new CompleteP2PNetwork();
                        setNetwork(networkSystem);
                        
                        // Setup event listeners
                        networkSystem.on('networkReady', () => {
                            console.log('‚úÖ Complete network ready');
                            networkSystem.showToast('üåê Connected to global humanitarian network');
                            loadPrayers(networkSystem);
                        });
                        
                        networkSystem.on('peerConnected', (data) => {
                            networkSystem.showToast(\`üë• Connected to peer: \${data.peerId.substr(0, 8)}...\`);
                        });
                        
                        networkSystem.on('prayerReceived', (prayer) => {
                            loadPrayers(networkSystem);
                        });
                        
                        networkSystem.on('heartbeat', (stats) => {
                            setNetworkStats(stats);
                            updateNetworkDisplay(stats);
                        });
                        
                        // Initialize network
                        await networkSystem.initialize();
                        
                        // Register service worker
                        registerServiceWorkerWithFallback();
                        
                        // Check for existing user session
                        const savedUser = localStorage.getItem('prayers_user');
                        if (savedUser) {
                            try {
                                const userData = JSON.parse(savedUser);
                                if (Date.now() - userData.timestamp < 7 * 24 * 60 * 60 * 1000) {
                                    setUser(userData);
                                }
                            } catch (e) {
                                localStorage.removeItem('prayers_user');
                            }
                        }
                        
                    } catch (error) {
                        console.error('Failed to initialize application:', error);
                    }
                };
                
                initializeEverything();
            }, []);

            const loadPrayers = (networkSystem) => {
                try {
                    const prayerList = networkSystem.getStoredPrayers();
                    setPrayers(prayerList);
                } catch (error) {
                    console.error('Failed to load prayers:', error);
                }
            };
            
            const updateNetworkDisplay = (stats) => {
                // Update real-time network display
                const networkTitle = document.getElementById('network-title');
                const networkStatsEl = document.getElementById('network-stats');
                const peerList = document.getElementById('peer-list');
                
                if (networkTitle && networkStatsEl) {
                    networkStatsEl.textContent = \`üì° \${stats.connections} direct ‚Ä¢ \${stats.discoveredPeers} discovered\`;
                }
                
                if (peerList && network) {
                    peerList.innerHTML = '';
                    for (const [peerId, peer] of network.discoveredPeers.entries()) {
                        const peerDiv = document.createElement('div');
                        peerDiv.className = 'peer-item';
                        
                        const isConnected = network.connections.has(peerId);
                        const statusClass = isConnected ? 'connected' : 'disconnected';
                        const shortId = peerId.substr(0, 8) + '...';
                        
                        peerDiv.innerHTML = \`
                            <span>\${shortId}</span>
                            <span class="connection-status \${statusClass}"></span>
                        \`;
                        peerList.appendChild(peerDiv);
                    }
                }
            };

            const signInWithEthereum = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    if (typeof window.ethereum === 'undefined') {
                        alert('Please install MetaMask or another Web3 wallet');
                        return;
                    }

                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    const userData = await auth.signInWithEthereum(accounts[0]);
                    
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (network) {
                        network.showToast(\`üîê Welcome, \${userData.displayName}!\`);
                    }
                    
                } catch (error) {
                    console.error('Ethereum sign-in failed:', error);
                    if (network) {
                        network.showToast('‚ùå Authentication failed. Please try again.');
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, network, loading]);

            const signInWithPasskey = useCallback(async () => {
                if (!auth || loading) return;
                setLoading(true);

                try {
                    const userData = await auth.signInWithPasskey();
                    setUser(userData);
                    localStorage.setItem('prayers_user', JSON.stringify(userData));
                    
                    if (network) {
                        network.showToast('üîê Authenticated with biometrics!');
                    }
                    
                } catch (error) {
                    console.error('Passkey sign-in failed:', error);
                    if (network) {
                        network.showToast('‚ùå Biometric authentication failed.');
                    }
                } finally {
                    setLoading(false);
                }
            }, [auth, network, loading]);

            const signOut = useCallback(() => {
                setUser(null);
                localStorage.removeItem('prayers_user');
                if (network) {
                    network.showToast('üëã Signed out');
                }
            }, [network]);

            const submitPrayer = useCallback(async () => {
                if (!user || !newPrayer.title.trim() || !newPrayer.content.trim()) {
                    if (network) {
                        network.showToast('‚ùå Please fill in title and content');
                    }
                    return;
                }

                if (!network) {
                    if (network) {
                        network.showToast('‚ùå Network not ready. Please wait.');
                    }
                    return;
                }

                setLoading(true);

                try {
                    const prayer = {
                        id: 'prayer_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
                        ...newPrayer,
                        author: user.displayName,
                        authorAddress: user.address,
                        timestamp: Date.now(),
                        walletAddress: user.address || newPrayer.walletAddress
                    };

                    const success = await network.storePrayer(prayer);
                    
                    if (success) {
                        network.showToast('‚úÖ Prayer shared with global network!');
                    } else {
                        network.showToast('üì± Prayer saved locally - will sync when peers connect');
                    }
                    
                    setNewPrayer({
                        title: '', content: '', location: '', urgency: 'medium',
                        category: 'general', needsAmount: '', walletAddress: user.address || ''
                    });
                    setShowCreateForm(false);
                    
                    loadPrayers(network);
                    
                } catch (error) {
                    console.error('Failed to submit prayer:', error);
                    if (network) {
                        network.showToast('‚ùå Failed to share prayer. Please try again.');
                    }
                } finally {
                    setLoading(false);
                }
            }, [user, newPrayer, network, loading]);

            const contributeToPrayer = useCallback(async (prayer) => {
                if (!user.address && user.authMethod === 'ethereum') {
                    if (network) {
                        network.showToast('‚ùå Please connect your wallet first');
                    }
                    return;
                }

                const amount = prompt('Enter contribution amount in ETH:');
                if (!amount || isNaN(amount) || parseFloat(amount) <= 0) return;

                setLoading(true);
                try {
                    if (typeof window.ethereum !== 'undefined' && typeof Web3 !== 'undefined') {
                        const web3 = new Web3(window.ethereum);
                        const tx = await web3.eth.sendTransaction({
                            from: user.address,
                            to: prayer.walletAddress,
                            value: web3.utils.toWei(amount, 'ether')
                        });
                        if (network) {
                            network.showToast(\`‚úÖ Contribution sent! Tx: \${tx.transactionHash.substring(0, 10)}...\`);
                        }
                    }
                } catch (error) {
                    console.error('Transaction failed:', error);
                    if (network) {
                        network.showToast('‚ùå Transaction failed. Please try again.');
                    }
                } finally {
                    setLoading(false);
                }
            }, [user, network, loading]);

            const toggleDebug = useCallback(() => {
                setShowDebug(prev => !prev);
                if (network) {
                    network.debugMode = !network.debugMode;
                    if (!network.debugMode) {
                        network.debug('üîç Debug mode enabled', 'info');
                    }
                }
            }, [network]);

            if (!user) {
                return React.createElement('div', { className: 'container' },
                    React.createElement('div', { className: 'hero' },
                        React.createElement('h1', null, 'üôè Prayers, Saints & Saviors'),
                        React.createElement('p', null, 
                            'The world\'s first truly decentralized humanitarian network with global P2P coordination.'
                        ),
                        React.createElement('p', { style: { fontSize: '1em', opacity: 0.8 } },
                            'Your browser connects directly to other users worldwide via WebRTC data channels.'
                        )
                    ),

                    React.createElement('div', { className: 'stats-bar' },
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.discoveredPeers || 0),
                            React.createElement('span', { className: 'stat-label' }, 'Global Peers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, networkStats.connections || 0),
                            React.createElement('span', { className: 'stat-label' }, 'Direct Connections')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, prayers.length),
                            React.createElement('span', { className: 'stat-label' }, 'Network Prayers')
                        ),
                        React.createElement('div', { className: 'stat' },
                            React.createElement('span', { className: 'stat-value' }, 
                                Math.floor((networkStats.uptime || 0) / 1000) + 's'
                            ),
                            React.createElement('span', { className: 'stat-label' }, 'Node Uptime')
                        )
                    ),

                    React.createElement('div', { className: 'auth-section' },
                        React.createElement('h2', { style: { marginBottom: '30px', color: '#2c3e50' } },
                            'Join the Global Network'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithEthereum,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null, 
                            'üîó Connect with Ethereum Wallet'
                        ),
                        
                        React.createElement('button', {
                            onClick: signInWithPasskey,
                            className: 'btn btn-auth',
                            disabled: loading
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üîê Use Device Biometrics'
                        ),

                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üåê Global P2P Network Features'),
                            React.createElement('ul', { style: { marginLeft: '20px', lineHeight: '1.8' } },
                                React.createElement('li', null, React.createElement('strong', null, 'WebRTC Data Channels'), ' - Direct browser-to-browser communication'),
                                React.createElement('li', null, React.createElement('strong', null, 'STUN/TURN Traversal'), ' - Works across NATs and firewalls'),
                                React.createElement('li', null, React.createElement('strong', null, 'Mesh Topology'), ' - Self-healing network with redundant paths'),
                                React.createElement('li', null, React.createElement('strong', null, 'FT-DFRP Routing'), ' - O(‚àön log n) complexity humanitarian coordination'),
                                React.createElement('li', null, React.createElement('strong', null, 'Cross-Subnet Support'), ' - Global internet-scale operation'),
                                React.createElement('li', null, React.createElement('strong', null, 'Zero Infrastructure'), ' - No servers, completely peer-to-peer')
                            )
                        )
                    )
                );
            }

            return React.createElement('div', { className: 'container' },
                React.createElement('div', { className: 'hero' },
                    React.createElement('h1', null, 'üôè Prayers, Saints & Saviors'),
                    React.createElement('div', { style: { color: 'rgba(255,255,255,0.9)' } },
                        'Welcome, ', React.createElement('strong', null, user.displayName),
                        React.createElement('button', {
                            onClick: signOut,
                            style: {
                                marginLeft: '15px', background: 'rgba(255,255,255,0.1)', 
                                border: '1px solid rgba(255,255,255,0.3)', color: 'white',
                                padding: '5px 10px', borderRadius: '5px', cursor: 'pointer'
                            }
                        }, '‚Üó Sign Out')
                    ),

                    React.createElement('div', { className: 'network-controls' },
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(true),
                            className: 'btn btn-secondary'
                        }, '‚ú® Share Prayer Request'),
                        
                        React.createElement('button', {
                            onClick: toggleDebug,
                            className: 'btn',
                            style: { background: showDebug ? '#4CAF50' : '#666' }
                        }, 'üîç Debug Console'),
                        
                        React.createElement('button', {
                            onClick: () => {
                                if (network) {
                                    const stats = network.getNetworkStats();
                                    alert(\`Network Stats:
Node ID: \${stats.nodeId}
Online: \${stats.isOnline}
Connections: \${stats.connections}
Peers: \${stats.discoveredPeers}
Prayers: \${stats.prayers}
Uptime: \${Math.floor(stats.uptime/1000)}s\`);
                                }
                            },
                            className: 'btn',
                            style: { background: '#2196F3' }
                        }, 'üìä Network Stats')
                    )
                ),

                React.createElement('div', { className: 'stats-bar' },
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.discoveredPeers || 0),
                        React.createElement('span', { className: 'stat-label' }, 'Network Peers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, networkStats.connections || 0),
                        React.createElement('span', { className: 'stat-label' }, 'Direct Connections')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, prayers.length),
                        React.createElement('span', { className: 'stat-label' }, 'Active Prayers')
                    ),
                    React.createElement('div', { className: 'stat' },
                        React.createElement('span', { className: 'stat-value' }, 
                            Math.floor((networkStats.uptime || 0) / 60000) + 'm'
                        ),
                        React.createElement('span', { className: 'stat-label' }, 'Node Uptime')
                    )
                ),

                showDebug && React.createElement('div', { className: 'p2p-debug', style: { display: 'block' } },
                    React.createElement('div', { style: { color: '#fff', marginBottom: '10px', borderBottom: '1px solid #333', paddingBottom: '5px' } },
                        React.createElement('strong', null, 'Real-Time P2P Debug Console')
                    ),
                    React.createElement('div', { id: 'debug-output' })
                ),

                showCreateForm && React.createElement('div', { className: 'card' },
                    React.createElement('h3', { style: { marginBottom: '25px', color: '#2c3e50' } }, 
                        '‚ú® Share Prayer Request'
                    ),
                    
                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Title'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.title,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, title: e.target.value })),
                                placeholder: 'Brief description of your need'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Category'),
                            React.createElement('select', {
                                value: newPrayer.category,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, category: e.target.value }))
                            },
                                React.createElement('option', { value: 'emergency' }, 'Emergency'),
                                React.createElement('option', { value: 'health' }, 'Health/Medical'),
                                React.createElement('option', { value: 'education' }, 'Education'),
                                React.createElement('option', { value: 'housing' }, 'Housing'),
                                React.createElement('option', { value: 'food' }, 'Food/Nutrition'),
                                React.createElement('option', { value: 'general' }, 'General Help')
                            )
                        )
                    ),

                    React.createElement('div', { className: 'form-group' },
                        React.createElement('label', null, 'Prayer Details'),
                        React.createElement('textarea', {
                            value: newPrayer.content, rows: 4,
                            onChange: (e) => setNewPrayer(prev => ({ ...prev, content: e.target.value })),
                            placeholder: 'Describe your situation and how others can help...'
                        })
                    ),

                    React.createElement('div', { className: 'feature-grid' },
                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Location'),
                            React.createElement('input', {
                                type: 'text', value: newPrayer.location,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, location: e.target.value })),
                                placeholder: 'City, Country'
                            })
                        ),

                        React.createElement('div', { className: 'form-group' },
                            React.createElement('label', null, 'Urgency'),
                            React.createElement('select', {
                                value: newPrayer.urgency,
                                onChange: (e) => setNewPrayer(prev => ({ ...prev, urgency: e.target.value }))
                            },
                                React.createElement('option', { value: 'low' }, 'Low - Can wait'),
                                React.createElement('option', { value: 'medium' }, 'Medium - Within weeks'),
                                React.createElement('option', { value: 'high' }, 'High - Urgent need')
                            )
                        )
                    ),

                    React.createElement('div', { style: { display: 'flex', gap: '15px', marginTop: '25px' } },
                        React.createElement('button', {
                            onClick: submitPrayer, className: 'btn btn-secondary',
                            disabled: loading, style: { flex: 1 }
                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                            'üöÄ Share with Global Network'
                        ),
                        React.createElement('button', {
                            onClick: () => setShowCreateForm(false), className: 'btn',
                            style: { flex: 1, background: '#666' }
                        }, 'Cancel')
                    )
                ),

                React.createElement('div', { style: { marginTop: '40px' } },
                    React.createElement('h2', { style: { color: 'white', marginBottom: '25px' } },
                        'üåç Global Prayer Network'
                    ),

                    prayers.length === 0 ? 
                        React.createElement('div', { className: 'network-info' },
                            React.createElement('h4', null, 'üå± Network Starting'),
                            React.createElement('p', null, 
                                'Be among the first to share a prayer request! Your browser is now connected to the ',
                                'global P2P humanitarian network. As more people join, our distributed system will ',
                                'automatically route requests to the most relevant helpers using FT-DFRP algorithms.'
                            )
                        ) :
                        prayers.map(prayer => 
                            React.createElement('div', {
                                key: prayer.id,
                                className: \`card prayer-card \${prayer.urgency === 'high' ? 'prayer-urgent' : ''}\`
                            },
                                React.createElement('div', { className: 'prayer-header' },
                                    React.createElement('div', { className: 'prayer-title' }, prayer.title),
                                    React.createElement('div', { className: 'prayer-distance' },
                                        prayer.authorAddress === user.address ? 'Your Request' : 
                                        \`Via P2P Network ‚Ä¢ \${prayer.nodeId ? prayer.nodeId.substr(0, 8) + '...' : 'Global'}\`
                                    )
                                ),
                                
                                React.createElement('div', { className: 'prayer-content' }, prayer.content),

                                prayer.needsAmount && React.createElement('div', {
                                    style: { 
                                        background: '#fff3e0', padding: '10px 15px', borderRadius: '8px',
                                        marginBottom: '15px', fontSize: '14px', color: '#ef6c00'
                                    }
                                },
                                    React.createElement('strong', null, 'Estimated Need: $' + prayer.needsAmount + ' USD')
                                ),

                                React.createElement('div', { className: 'prayer-footer' },
                                    React.createElement('div', { style: { fontSize: '13px', color: '#666' } },
                                        'üìç ' + (prayer.location || 'Location not specified'),
                                        ' ‚Ä¢ by ' + prayer.author,
                                        ' ‚Ä¢ ' + prayer.category,
                                        ' ‚Ä¢ ' + new Date(prayer.timestamp).toLocaleDateString()
                                    ),
                                    
                                    prayer.walletAddress && prayer.authorAddress !== user.address && user.address &&
                                        React.createElement('button', {
                                            onClick: () => contributeToPrayer(prayer),
                                            className: 'btn',
                                            disabled: loading,
                                            style: { fontSize: '13px', padding: '8px 16px' }
                                        }, loading ? React.createElement('span', { className: 'loading' }) : null,
                                            'üíù Contribute'
                                        )
                                )
                            )
                        )
                ),

                React.createElement('div', { className: 'network-info', style: { marginTop: '40px' } },
                    React.createElement('h4', null, 'üî¨ Global P2P Network Technology'),
                    React.createElement('p', null,
                        \`Your browser is running a FT-DFRP node with \${networkStats.connections} direct WebRTC connections \`,
                        \`and has discovered \${networkStats.discoveredPeers} global peers. Using O(‚àön log n) complexity algorithms, \`,
                        'you\'re helping route humanitarian aid efficiently across the global internet. ',
                        'Network operates with zero infrastructure costs while maintaining complete privacy and censorship resistance.'
                    )
                ),

                React.createElement('footer', { style: { textAlign: 'center', padding: '40px 0', color: 'rgba(255,255,255,0.7)' } },
                    React.createElement('p', null, 'Built with ‚ù§Ô∏è using Global P2P WebRTC ‚Ä¢ Powered by your browser'),
                    React.createElement('p', { style: { fontSize: '12px', marginTop: '10px' } },
                        'Decentralized ‚Ä¢ Zero-Infrastructure ‚Ä¢ WebRTC Mesh ‚Ä¢ O(‚àön log n) Efficient ‚Ä¢ Censorship-Resistant'
                    )
                )
            );
        }

        // Initialize the complete application after consent
        function initializeCompleteApplication() {
            ReactDOM.render(React.createElement(CompleteApplication), document.getElementById('root'));
        }
    </script>
</body>
</html>
